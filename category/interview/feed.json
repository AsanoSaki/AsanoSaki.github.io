{
    "version": "https://jsonfeed.org/version/1",
    "title": "AsanoSaki • All posts by \"interview\" category",
    "description": "",
    "home_page_url": "https://asanosaki.github.io",
    "items": [
        {
            "id": "https://asanosaki.github.io/posts/2329.html",
            "url": "https://asanosaki.github.io/posts/2329.html",
            "title": "Spring面试题总结",
            "date_published": "2023-11-24T09:09:00.000Z",
            "content_html": "<blockquote>\n<p>Spring 面试题总结，涉及 Spring、Spring MVC、Spring Boot、Spring Cloud、MyBatis 等内容，文章将不断更新。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"1-Spring\">1. Spring</h2>\n<h3 id=\"1-1-Spring-框架是什么？有什么优势？\">1.1 Spring 框架是什么？有什么优势？</h3>\n<p>Spring 框架是一个轻量级的 Java 开发框架，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的 JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发 Java 应用程序提供全面的基础架构支持。Spring 的最根本的使命是解决企业级应用开发的复杂性，即简化 Java 开发。Spring 框架的优势主要包括：</p>\n<ul>\n<li>方便解耦，简化开发：Spring 就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给 Spring 管理。</li>\n<li>AOP 编程的支持：Spring 提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</li>\n<li>声明式事务的支持：只需要通过配置就可以完成对事务的管理，而无需手动编程。</li>\n<li>方便程序的测试：Spring 对 Junit4 支持，可以通过注解方便地测试 Spring 程序。</li>\n<li>方便集成各种优秀框架：Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis 等）的直接支持。</li>\n<li>降低 JavaEE API 的使用难度：Spring 对 JavaEE 开发中非常难用的一些 API（如 JDBC、JavaMail、远程调用等），都提供了封装，使这些 API 应用难度大大降低。</li>\n</ul>\n<h3 id=\"1-2-什么是-Spring-IoC-容器？\">1.2 什么是 Spring IoC 容器？</h3>\n<p>Spring IoC（Spring Inversion of Control）容器，是 Spring 框架的核心部分。IoC 即<strong>控制反转</strong>，是一种设计思想，在 Java 开发中，IoC 意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p>\n<p>Spring IoC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。具体来说，Spring IoC 容器负责创建对象、管理对象（通过依赖注入）、装配对象、配置对象，并且管理这些对象的整个生命周期。</p>\n<p>使用 IoC 的目的，主要是为了降低类之间的耦合。通过控制反转，对象的创建和对象之间的依赖关系处理，交给 Spring 容器来管理，不用程序员自己创建和维护。这样，应用程序无需直接在代码中创建相关的对象，应用程序由 IoC 容器进行组装。这种方式不仅降低了类之间的耦合，也使得代码更加简洁，更易于测试和维护。</p>\n<h3 id=\"1-3-什么是依赖注入？\">1.3 什么是依赖注入？</h3>\n<p>依赖注入（Dependency Injection，DI）是一种设计模式，也是 Spring 框架的核心概念之一。它的主要作用是去除 Java 类之间的依赖关系，实现松耦合，以便于开发测试。</p>\n<p>在传统的程序设计过程中，当某个角色（可能是一个 Java 实例，调用者）需要另一个角色（另一个 Java 实例，被调用者）的协助时，通常由调用者来创建被调用者的实例。这种方式会导致调用者与被调用者之间产生紧密的耦合关系，使得代码难以修改和测试。</p>\n<p>依赖注入的思想是，不在类内部直接创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给需要的类来使用。例如，<code>A</code> 类要依赖 <code>B</code> 类，<code>A</code> 类不再直接创建 <code>B</code> 类，而是把这种依赖关系配置在外部 XML（或 Java Config）文件中，然后由 Spring 容器根据配置信息创建、管理 <code>bean</code> 类。</p>\n<p>这样，调用者不需要关心被调用者的创建和销毁，只需要关心如何使用被调用者，从而实现了调用者和被调用者之间的解耦。这种方式不仅降低了类之间的耦合，也使得代码更加简洁，更易于测试和维护。</p>\n<p>举一个例子，加入我们有一个接口和两个实现类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MessageService</span> &#123;</span><br><span class=\"line\">    String <span class=\"title function_\">getMessage</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TextMessageService</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MessageService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getMessage</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Text Message&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EmailMessageService</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MessageService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getMessage</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Email Message&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，我们有一个使用 <code>MessageService</code> 的 <code>MessagePrinter</code> 类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MessagePrinter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MessageService service;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过构造器注入依赖</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MessagePrinter</span><span class=\"params\">(MessageService service)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.service = service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printMessage</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"built_in\">this</span>.service.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 Spring 的配置文件中，我们可以定义 <code>MessageService</code> 和 <code>MessagePrinter</code> 的 <code>bean</code>，并通过构造器注入依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;messageService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.example.TextMessageService&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;messagePrinter&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.example.MessagePrinter&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;messageService&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在这个例子中，<code>MessagePrinter</code> 依赖于 <code>MessageService</code>。通过 Spring IoC 容器和依赖注入，我们可以在外部配置文件中定义这种依赖关系，而不需要在 <code>MessagePrinter</code> 类中硬编码依赖的实现类。这样，我们可以轻松地更改 <code>MessageService</code> 的实现，而无需修改 <code>MessagePrinter</code> 类的代码，这就是依赖注入的优势。</p>\n<p>如果我们运行 <code>MessagePrinter</code> 的 <code>printMessage()</code> 方法，它将打印出 <code>Text Message</code>。这是因为我们在 Spring 的配置文件中将 <code>TextMessageService</code> 定义为 <code>MessageService</code> 的实现类，然后通过构造器注入的方式将其注入到了 <code>MessagePrinter</code> 中。所以，当我们调用 <code>printMessage()</code> 方法时，它会调用 <code>TextMessageService</code> 的 <code>getMessage()</code> 方法。</p>\n<p>总的来说，依赖注入是一种消除类之间依赖关系的设计模式，它使得对象之间的依赖关系更加清晰，代码更加灵活，更易于测试和维护。</p>\n<h3 id=\"1-4-依赖注入有几种方式？\">1.4 依赖注入有几种方式？</h3>\n<p>在 Spring 中，有四种常见的依赖注入方式：</p>\n<p>（1）属性注入（Field Injection）：直接在需要注入的字段上使用 <code>@Autowired</code> 或 <code>@Resource</code> 等注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserMapper userMapper;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（2）Setter 注入（Setter Injection）：在 <code>setter</code> 方法上使用 <code>@Autowired</code> 或 <code>@Resource</code> 等注解。在 SpringBoot 中，由于 WebSocket 的特殊性，它是由容器管理的，而不是由 Spring 管理的 Bean，每次 WebSocket 连接都会创建一个新的 WebSocket 实例（非单例模式），因此不能直接使用属性注入的方式来注入 WebSocket。假如我们要在 WebSocket 中使用 Mapper，那么我们就可以用 Setter 注入的方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@ServerEndpoint(value = &quot;/websocket&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebSocketServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> UserMapper userMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setUserMapper</span><span class=\"params\">(UserMapper userMapper)</span> &#123;</span><br><span class=\"line\">        WebSocketServer.userMapper = userMapper;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（3）构造器注入（Constructor Injection）：在构造器上使用 <code>@Autowired</code> 或 <code>@Resource</code> 等注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserMapper userMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">UserService</span><span class=\"params\">(UserMapper userMapper)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userMapper = userMapper;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（4）静态工厂的方法注入：通过静态工厂方法创建 Bean，并在 Spring 配置文件中声明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeanFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> UserService <span class=\"title function_\">createUserService</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserService</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 Spring 配置文件中声明：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.example.BeanFactory&quot;</span> <span class=\"attr\">factory-method</span>=<span class=\"string\">&quot;createUserService&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1-5-如何理解-IoC-和-DI？\">1.5 如何理解 IoC 和 DI？</h3>\n<p>IoC（Inversion of Control，控制反转）和 DI（Dependency Injection，依赖注入）是 Spring 框架的核心概念，它们是面向对象编程的重要设计原则。IoC 和 DI 是同一个概念的不同角度描述，IoC 是一种设计思想，DI 是这种思想的一种实现方式。</p>\n<p>IoC 是一种设计思想，不是一种技术。在 Java 开发中，IoC 意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。这意味着，所有的类都会在 Spring 容器中登记，告诉 Spring 你是什么，你需要什么，然后 Spring 会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 Spring 来控制，也就是说控制对象生存周期的不再是引用它的对象，而是 Spring。</p>\n<p>DI 是 IoC 的一种实现方式。DI 是一种将调用者与被调用者分离的思想，组件之间的依赖关系由容器在运行时决定，形象的说，是由容器动态地将某个依赖关系注入到组件之中，这样你就可以使用 <code>@Autowired</code>、<code>@Resource</code> 等注解来实现自动注入。</p>\n<h3 id=\"1-6-什么是-AOP？\">1.6 什么是 AOP？</h3>\n<p>AOP（Aspect Oriented Programming），即<strong>面向切面编程</strong>，是一种通过预编译方式和运行期动态代理实现程序功能的统一维护的技术。它是 OOP（面向对象编程）的延续，也是 Spring 框架中的一个重要内容，是函数式编程的一种衍生范型。</p>\n<p>AOP 的主要目标是将业务处理逻辑与系统服务分离开来，然后通过声明性的方式将系统服务应用到业务处理逻辑中。简单来说，AOP 就是把我们程序重复的代码抽取出来，在需要执行的时候使用动态代理技术在不修改源码的基础上，对我们的已有方法进行增强。</p>\n<p>AOP 的主要术语包括：</p>\n<ul>\n<li>切面（Aspect）：切面是一个横切关注点的模块化，一个切面能够包含同一个类型的不同增强方法，比如说事务处理和日志处理可以理解为两个切面。</li>\n<li>连接点（JoinPoint）：程序执行过程中明确的点，如方法的调用或特定的异常被抛出。</li>\n<li>切入点（PointCut）：切入点是对连接点进行拦截的条件定义。</li>\n<li>通知（Advice）：通知是指拦截到连接点之后要执行的代码，包括了 <code>around</code>、<code>before</code> 和 <code>after</code> 等不同类型的通知。</li>\n<li>目标对象（Target）：目标对象指将要被增强的对象，即包含主业务逻辑的类对象。</li>\n<li>织入（Weaving）：织入是将切面和业务逻辑对象连接起来，并创建通知代理的过程。</li>\n</ul>\n<h3 id=\"1-7-AOP-的实现方式有哪些？\">1.7 AOP 的实现方式有哪些？</h3>\n<ul>\n<li>通过 Spring API 实现：这种方式的核心是通过编写增强类来继承 Spring API 提供的接口。例如，你可以编写业务接口和实现类，然后编写增强类，并实现 Spring API 相关接口的方法。然后在 <code>resource</code> 目录下新建 <code>applicationContext</code> 文件，实现 Java 类的创建和 AOP 的织入，最后编写测试类。</li>\n<li>通过自定义类来实现：这种方式比较推荐。你可以自定义切入类，然后在 Spring 中配置，最后编写测试类。</li>\n<li>使用注解实现：你可以自定义增强类（注解实现），然后在 Spring 配置文件中，注册 Bean，并增加支持注解的配置，最后编写测试类。</li>\n<li>使用 JDK 提供的代理方式：这种方式不依赖于 Spring。你可以使用 JDK 提供的代理方式来实现 AOP，包括静态和动态两种方式。</li>\n<li>使用 Spring 纯配置实现：你可以通过 Spring 的配置文件来实现 AOP。</li>\n<li>使用 Spring 注解：你可以通过 Spring 的注解来实现 AOP。</li>\n<li>动态代理和字节码增强：Spring AOP 的实现主要基于动态代理和字节码增强两种技术。动态代理是一种在运行时生成代理对象的技术，在代理对象中可以添加额外的逻辑，比如切面逻辑。Spring AOP 通过 JDK 动态代理和 CGLIB 动态代理两种方式实现代理对象的生成。</li>\n</ul>\n<h3 id=\"1-8-Spring-框架中用到了哪些设计模式？\">1.8 Spring 框架中用到了哪些设计模式？</h3>\n<p>（1）单例模式（Singleton）：Spring 中的 Bean 默认都是单例的，这就是单例模式的应用。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> MyService <span class=\"title function_\">myService</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyServiceImpl</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，<code>myService</code> Bean 在整个应用中只有一个实例。在单例模式中，Spring容器会确保每个由 <code>@Bean</code> 注解定义的 Bean 在整个应用中只有一个实例。</p>\n<p>（2）工厂模式（Factory）：Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 来创建 Bean。同单例模式的示例代码所示，在这个例子中，<code>AppConfig</code> 类就像一个工厂，<code>myService()</code> 方法就是工厂方法，用来创建 <code>MyService</code> 的实例。Spring 的 <code>@Bean</code> 注解同时实现了这两种模式。</p>\n<p>（3）模板方法模式（Template Method）：Spring 的 <code>JdbcTemplate</code> 和 <code>HibernateTemplate</code> 等都是模板方法模式的应用。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">JdbcTemplate</span> <span class=\"variable\">jdbcTemplate</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JdbcTemplate</span>(dataSource);</span><br><span class=\"line\">jdbcTemplate.execute(<span class=\"string\">&quot;CREATE TABLE CUSTOMERS (ID INTEGER, NAME VARCHAR(100))&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>（4）代理模式（Proxy）：Spring AOP 就是通过代理模式实现的。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;execution(* com.example.myapp.MyService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">logBefore</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before method: &quot;</span> + joinPoint.getSignature());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，<code>LoggingAspect</code> 创建了一个代理，它在 <code>MyService</code> 的所有方法执行前打印日志。</p>\n<p>（5）观察者模式（Observer）：Spring 事件处理就是观察者模式的一个例子。当一个事件被发布时，所有注册的监听器都会收到通知。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyEventListener</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ApplicationListener</span>&lt;MyEvent&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onApplicationEvent</span><span class=\"params\">(MyEvent event)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Received: &quot;</span> + event.getData());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（6）包装器设计模式：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</p>\n<p>（7）适配器模式：Spring AOP 的增强或通知（Advice）使用到了适配器模式、spring MVC 中也是用到了适配器模式适配 Controller。</p>\n<h3 id=\"1-9-Spring-提供了哪些配置方式？\">1.9 Spring 提供了哪些配置方式？</h3>\n<p>Spring 提供了以下三种主要的配置方式：</p>\n<ul>\n<li>基于 XML 的配置：在 Spring1.x 时代，都是基于 XML 来进行配置，用 XML 文件来管理 Bean 之间的关系。例如，你可以在 XML 文件中定义一个 Bean，然后在需要的地方引用这个 Bean。</li>\n<li>基于注解的配置：Spring2.5 以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代 XML 方式的 Bean 描述，可以将 Bean 描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。例如，你可以使用 <code>@Component</code> 或其子类（<code>@Repository</code>、<code>@Service</code>、<code>@Controller</code>）来定义 Bean。</li>\n<li>基于 Java API 的配置：Spring3.0 以后，提供了 Java 配置的能力，Spring4.x和SpringBoot都推荐使用Java配置2。例如，你可以使用@Configuration和@Bean注解来定义和配置bean12。</li>\n</ul>\n<p>注意 Spring 框架默认并不启用注解配置方式，你需要在配置文件中添加相应的配置才能启用注解配置方式：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 启用注解配置 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context:annotation-config</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 其他bean的定义 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>&lt;context:annotation-config/&gt;</code> 是 Spring 框架中的一个 XML 配置元素，用于启用注解驱动的 Spring 容器。它会自动扫描 Spring 容器中的所有组件，包括 <code>@Service</code>、<code>@Repository</code>、<code>@Controller</code>、<code>@Component</code> 等注解标注的类，并将它们注册到 Spring 容器中。</p>\n<p>也可以使用 <code>&lt;context:component-scan/&gt;</code>，如果使用了 <code>&lt;context:component-scan/&gt;</code>，那么 <code>&lt;context:annotation-config/&gt;</code> 就不再需要，因为 <code>&lt;context:component-scan/&gt;</code> 除了具有 <code>&lt;context:annotation-config/&gt;</code> 的功能之外，还可以在指定的 Package 下扫描以及注册 Java Bean。</p>\n<h3 id=\"1-10-Spring-中的-Bean-是什么？\">1.10 Spring 中的 Bean 是什么？</h3>\n<p>在 Spring 中，构成应用程序主干并由 Spring IoC 容器管理的对象称为 Bean。Bean 是一个由 Spring IoC 容器实例化、组装和管理的对象，即 Spring 容器中存储的主要就是 Bean 对象。简而言之，Spring Bean 是 Spring 框架在运行时管理的对象，是任何 Spring 应用程序的基本构建块，我们编写的大多数应用程序逻辑代码都将放在 Spring Bean 中。Spring Bean 的管理包括：创建一个对象，提供依赖项（例如其他 Bean，配置属性），拦截对象方法调用以提供额外的框架功能，销毁一个对象。</p>\n<h3 id=\"1-11-Bean-的作用域有哪些？\">1.11 Bean 的作用域有哪些？</h3>\n<ul>\n<li><code>singleton</code>：单例模式，在整个 Spring IoC 容器中，使用 <code>singleton</code> 定义的 Bean 将只有一个实例。这是 Spring 的默认作用域。</li>\n<li><code>prototype</code>：原型模式，每次通过容器的 <code>getBean()</code> 方法获取 <code>prototype</code> 定义的 Bean 时，都将产生一个新的 Bean 实例。</li>\n<li><code>request</code>：对于每次 HTTP 请求，使用 <code>request</code> 定义的 Bean 都将产生一个新实例。只有在 Web 应用中使用 Spring 时，该作用域才有效。</li>\n<li><code>session</code>：对于每次 HTTP Session，使用 <code>session</code> 定义的 Bean 都将产生一个新实例。同样只有在 Web 应用中使用 Spring 时，该作用域才有效。</li>\n<li><code>application</code>：限定一个 Bean 的作用域为 <code>ServletContext</code> 的生命周期。该作用域仅适用于 Web 的 Spring WebApplicationContext 环境。</li>\n<li><code>globalSession</code>：全局 Session 作用域，仅在基于 <code>portlet</code> 的 Web 应用中才有意义，Spring5 已经没有了。</li>\n</ul>\n<p>在 Spring 配置文件中，可以通过标签的 <code>scope</code> 属性来指定 Bean 的作用域。例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;myBean&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.example.MyBeanClass&quot;</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在 Spring Boot 或基于 Java 的配置中，可以通过 <code>@Scope</code> 注解来指定 Bean 的作用域。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> MyBeanClass <span class=\"title function_\">myBean</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyBeanClass</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-12-Bean-的生命周期有几个阶段？\">1.12 Bean 的生命周期有几个阶段？</h3>\n<ul>\n<li>实例化（Instantiation）：Spring 根据配置文件或注解等方式创建 Bean 的实例。</li>\n<li>属性赋值（Populate）：Spring 将实例化后的 Bean 的属性值设置到对应的属性中。</li>\n<li>初始化（Initialization）：如果 Bean 实现了 <code>InitializingBean</code> 接口或在配置文件中通过 <code>init-method</code> 指定了初始化方法，则在 Bean 初始化完成后调用该方法。</li>\n<li>销毁（Destruction）：如果 Bean 实现了 <code>DisposableBean</code> 接口或在配置文件中通过 <code>destroy-method</code> 指定了销毁方法，则在容器关闭时会调用该方法。</li>\n</ul>\n<h3 id=\"1-13-详细讲一下-Bean-的生命周期是什么？\">1.13 详细讲一下 Bean 的生命周期是什么？</h3>\n<p>Spring Bean 的生命周期是指一个 Bean 从被创建、初始化、使用到最终被销毁的整个过程。Spring 容器（<code>ApplicationContext</code> 或 <code>BeanFactory</code>）负责管理这个生命周期。</p>\n<p>Spring Bean 生命周期的详细阶段如下：</p>\n<ol>\n<li>\n<p>Bean 定义加载与解析：Spring 容器启动时（如 <code>ApplicationContext.refresh()</code>），读取配置文件，将配置信息解析为内部的 <code>BeanDefinition</code> 对象，存储在 <code>BeanFactory</code> 的注册表中，<code>BeanDefinition</code> 包含了创建 Bean 所需的所有元数据（类名、作用域、初始化/销毁方法名、属性值、构造函数参数等）。</p>\n</li>\n<li>\n<p>实例化（Instantiation）：容器根据 <code>BeanDefinition</code> 的信息，创建 Bean 的实例。通常通过反射调用构造函数（<code>Class.newInstance()</code> 或 <code>Constructor.newInstance()</code>）来完成。对于工厂方法创建的 Bean，则调用指定的静态工厂方法或实例工厂方法。此时 Bean 只是一个“空壳”，属性未被设置，依赖未被注入。</p>\n</li>\n<li>\n<p>属性赋值/依赖注入（Population of Properties）：容器根据 <code>BeanDefinition</code> 中的配置，为 Bean 实例设置属性值，包括注入其他 Bean 的引用（<code>@Autowired</code>、<code>@Resource</code>、<code>@Inject</code>），注入基本类型或 String 等值，注入集合（<code>List</code>、<code>Set</code>、<code>Map</code>、<code>Properties</code>），解析和注入 <code>@Autowired</code> 标注的字段、Setter 方法或构造函数参数。</p>\n</li>\n<li>\n<p>Bean 后置处理器（<code>BeanPostProcessor</code>）- 初始化前（<code>postProcessBeforeInitialization</code>）：如果容器中注册了实现了 <code>BeanPostProcessor</code> 接口的 Bean，容器会在每个 Bean 初始化之前调用其 <code>postProcessBeforeInitialization(Object bean, String beanName)</code> 方法，作用是在 Bean 初始化之前对 Bean 实例进行修改或包装（例如生成代理对象，如 AOP 代理通常在此阶段生成）。</p>\n</li>\n<li>\n<p>初始化（Initialization）：经过前置处理后，Bean 进入初始化阶段，容器会调用 Bean 上定义的初始化回调方法，作用是执行 Bean 创建后、使用前的自定义初始化逻辑，例如：建立数据库连接池、加载配置文件、验证依赖注入是否完整、启动后台线程、执行复杂的数据结构初始化。这些方法按固定顺序执行：</p>\n<ul>\n<li><code>@PostConstruct</code> 注解方法：由 JSR-250 规范定义。这是最常用、最推荐的方式。方法上标注 <code>@PostConstruct</code>。</li>\n<li><code>InitializingBean.afterPropertiesSet()</code>：Spring 特定接口。Bean 实现 <code>InitializingBean</code> 接口并覆写 <code>afterPropertiesSet()</code> 方法。不推荐使用，因为它将代码与 Spring 接口耦合。</li>\n<li>自定义 <code>init-method</code>：在配置中指定的方法（XML 的 <code>init-method</code> 属性，Java Config 的 <code>@Bean(initMethod = &quot;myInit&quot;)</code>）。方法签名通常是 <code>void xxx()</code> 无参方法。</li>\n</ul>\n</li>\n<li>\n<p>Bean 后置处理器（<code>BeanPostProcessor</code>）- 初始化后（<code>postProcessAfterInitialization</code>）：在 Bean 执行完自身的初始化方法后，容器会调用所有 <code>BeanPostProcessor</code> 的 <code>postProcessAfterInitialization(Object bean, String beanName)</code> 方法，作用是在 Bean 初始化之后对 Bean 实例进行最终的修改或增强，很多 Spring 的高级功能（如 AOP 的最终代理包装）在此阶段完成。</p>\n</li>\n<li>\n<p>Bean 就绪（Ready for Use）：此时，Bean 已经完成了创建、依赖注入、初始化和所有后处理，完全初始化完毕，驻留在 Spring 容器（通常是单例池 <code>singletonObjects</code>）中，应用程序可以通过 <code>getBean()</code> 方法或依赖注入的方式获取并使用这个 Bean。</p>\n</li>\n<li>\n<p>销毁（Destruction）：当容器关闭时（例如调用 <code>ApplicationContext.close()</code> 或在 Web 应用中容器关闭），对于作用域为 <code>singleton</code> 且实现了销毁回调的 Bean，容器会触发销毁过程，作用是执行 Bean 销毁前的自定义清理逻辑，例如：关闭数据库连接池，释放连接、停止后台线程、保存状态到文件、释放文件句柄以及网络连接等资源。销毁回调的执行顺序与初始化相反：</p>\n<ul>\n<li><code>@PreDestroy</code> 注解方法：JSR-250 规范定义。最常用、最推荐。方法上标注 <code>@PreDestroy</code>。</li>\n<li><code>DisposableBean.destroy()</code>：Spring 特定接口。Bean 实现 <code>DisposableBean</code> 并覆写 <code>destroy()</code> 方法。不推荐使用（耦合）。</li>\n<li>自定义 <code>destroy-method</code>：配置中指定的方法（XML 的 <code>destroy-method</code> 属性，Java Config 的 <code>@Bean(destroyMethod = &quot;myDestroy&quot;)</code>）。方法签名通常是 <code>void xxx()</code> 无参方法。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"1-14-Bean-加载-销毁前后，如果想实现某些逻辑，可以怎么做？\">1.14 Bean 加载/销毁前后，如果想实现某些逻辑，可以怎么做？</h3>\n<p>在 Spring 框架中，如果希望在 Bean 加载（即实例化、属性赋值、初始化等过程完成后）或销毁前后执行某些逻辑，可以使用 Spring 的生命周期回调接口或注解。这些接口和注解允许你定义在 Bean 生命周期的关键点执行的代码。</p>\n<p>（1）使用 <code>init-method</code> 和 <code>destroy-method</code>：</p>\n<p>在 XML 配置中，你可以通过 <code>init-method</code> 和 <code>destroy-method</code> 属性来指定 Bean 初始化后和销毁前需要调用的方法：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;myBean&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.example.MyBeanClass&quot;</span> <span class=\"attr\">init-method</span>=<span class=\"string\">&quot;init&quot;</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">&quot;destroy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后，在你的 Bean 类中实现这些方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyBeanClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">destroy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 销毀逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（2）实现 <code>InitializingBean</code> 和 <code>DisposableBean</code> 接口：</p>\n<p>Bean 类可以实现 <code>org.springframework.beans.factory.InitializingBean</code> 和 <code>org.springframework.beans.factory.DisposableBean</code> 接口，并分别实现 <code>afterPropertiesSet()</code> 和 <code>destroy()</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.DisposableBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyBeanClass</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InitializingBean</span>, DisposableBean &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">destroy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 销毀逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（3）使用 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> javax.annotation.PostConstruct;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.annotation.PreDestroy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyBeanClass</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">destroy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 销毀逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（4）使用 <code>@Bean</code> 注解的 <code>initMethod</code> 和 <code>destroyMethod</code> 属性：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> MyBeanClass <span class=\"title function_\">myBean</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyBeanClass</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-15-BeanFactory-和-ApplicationContext-有什么区别？\">1.15 BeanFactory 和 ApplicationContext 有什么区别？</h3>\n<p><code>BeanFactory</code> 和 <code>ApplicationContext</code> 都是 Spring 框架中用于创建和管理 Bean 的容器。</p>\n<p><code>BeanFactory</code> 是 Spring 框架的最基本的容器，它是 Spring 的核心部分。<code>BeanFactory</code> 通过一个配置文件来管理和创建 Bean。<code>BeanFactory</code> 中的 Bean 是懒加载的，也就是说只有在调用 <code>getBean()</code> 方法去请求某个 Bean 时才会创建实例，这样可以提高程序的性能和启动速度，帮助我们节省资源。</p>\n<p><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口，它是一个更加强大的容器。<code>ApplicationContext</code> 可以像 <code>BeanFactory</code> 一样创建和管理 Bean，但是它还可以提供其他的功能，比如支持国际化、事件传播、资源加载等。<code>ApplicationContext</code> 是在程序启动时就将所有的 Bean 全部实例化，因此在程序运行时可以直接获取已经创建好的 Bean，从而提高了程序的响应速度。</p>\n<h3 id=\"1-16-什么是-Spring-事务管理模型？\">1.16 什么是 Spring 事务管理模型？</h3>\n<p>Spring 事务是 Spring 框架提供的一个核心功能，旨在简化在 Java 应用中管理<strong>数据库事务</strong>（以及扩展到其他支持事务的资源）的复杂性。它提供了一套声明式和编程式的事务管理模型，将事务管理逻辑从业务代码中分离出来，使开发者能更专注于核心业务逻辑。</p>\n<p>事务（Transaction）是指一组数据库操作（如多个 SQL 语句）被视为一个单一的工作单元。这些操作要么全部成功提交（Commit），要么全部失败回滚（Rollback），这是保证数据一致性和完整性的关键机制。其具有 ACID 特性：</p>\n<ul>\n<li>A（原子性，Atomicity）：事务是<strong>不可分割</strong>的最小单元，要么全部执行，要么全部不执行。</li>\n<li>C（一致性，Consistency）：事务将数据库从一个<strong>一致</strong>状态转换到另一个<strong>一致</strong>状态。</li>\n<li>I（隔离性，Isolation）：并发执行的事务之间应该<strong>相互隔离</strong>，防止互相干扰。</li>\n<li>D（持久性，Durability）：一旦事务提交，它对数据库的改变就是<strong>永久性</strong>的，即使系统故障也不会丢失。</li>\n</ul>\n<p>Spring 提供两种主要的事务管理方式：</p>\n<ul>\n<li>编程式事务管理（Programmatic Transaction Management）：开发者直接在代码中通过 Spring 提供的 API 显式控制事务的边界（开始、提交、回滚）。优点为精细控制，事务边界清晰可见，缺点为事务管理代码侵入业务代码，代码重复度高，维护性稍差，适用于需要非常精细控制事务边界，或者声明式事务无法满足特定需求的情况。实现方式如下：\n<ul>\n<li>使用 <code>TransactionTemplate</code>：这是最常用的编程方式。它封装了事务管理的样板代码（try-catch-finally），开发者只需在 <code>execute()</code> 方法内部实现需要事务的业务逻辑（通过 <code>TransactionCallback</code> 或 Lambda 表达式）。</li>\n<li>使用 <code>PlatformTransactionManager</code>：直接调用 <code>getTransaction()</code>、<code>commit()</code>、<code>rollback()</code> 方法，更底层，更灵活，但也更繁琐。</li>\n</ul>\n</li>\n<li>声明式事务管理（Declarative Transaction Management）：这是 Spring 推荐且最常用的方式，开发者通过配置（注解或 XML）来声明哪些方法（或类）需要事务支持以及事务的属性（传播行为、隔离级别等）。事务管理的具体操作（开启、提交、回滚）由 Spring 框架在运行时（通常基于 AOP 代理）自动完成。其具有非侵入性、事务管理与业务逻辑分离、配置灵活、易于维护、减少样板代码等优点，适用于绝大多数需要事务管理的情况，实现方式如下：\n<ul>\n<li>基于 <code>@Transactional</code> 注解：将注解标注在方法或类上，标注在类上表示该类的所有 <code>public</code> 方法都应用该事务属性，方法上的注解会覆盖类上的注解，可以在注解中指定 <code>propagation</code>、<code>isolation</code>、<code>timeout</code>、<code>readOnly</code>、<code>rollbackFor</code>、<code>noRollbackFor</code> 等属性。需要注意的是 <code>@Transactional</code> 生效依赖于 AOP 代理。这意味着调用必须是通过代理对象进行的（从 Spring 容器中获取的 Bean 已经是代理对象）。</li>\n<li>基于 XML 配置（<code>&lt;tx:advice&gt;</code> 和 <code>&lt;aop:config&gt;</code>）：在 XML 文件中定义事务通知（<code>&lt;tx:advice&gt;</code>）并配置其属性（传播行为等），使用 AOP 切面配置（<code>&lt;aop:config&gt;</code>）将事务通知织入到指定的方法（通常通过切入点表达式 <code>pointcut</code>）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-17-Spring-的事务什么情况下会失效？\">1.17 Spring 的事务什么情况下会失效？</h3>\n<p>Spring Boot 通过 Spring 框架的事务管理模块来支持事务操作。事务管理在 Spring Boot 中通常是通过 <code>@Transactional</code> 注解来实现的。事务可能会失效的一些常见情况包括：</p>\n<ol>\n<li>未捕获异常：如果一个事务方法中发生了未捕获的异常，并且异常未被处理或传播到事务边界之外，那么事务会失效，所有的数据库操作会回滚。</li>\n<li>非受检异常：Spring 默认只在抛出 <code>RuntimeException</code> 及其子类或 <code>Error</code> 时回滚事务。如果方法抛出的是检查型异常（Checked Exception，如 <code>IOException</code>、<code>SQLException</code>）或其自定义非运行时异常，事务默认会提交！</li>\n<li>事务传播属性设置不当：如果在多个事务之间存在事务嵌套，且事务传播属性配置不正确，可能导致事务失效。特别是在方法内部调用有 <code>@Transactional</code> 注解的方法时要特别注意。</li>\n<li>多数据源的事务管理：如果在使用多数据源时，事务管理没有正确配置或者存在多个 <code>@Transactional</code> 注解时，可能会导致事务失效。</li>\n<li>跨方法调用事务问题：如果一个事务方法内部调用另一个方法，而这个被调用的方法没有 <code>@Transactional</code> 注解，这种情况下外层事务可能会失效。</li>\n<li>事务在非公开方法中失效：Spring 的事务管理（基于 AOP 代理或 AspectJ）默认只对 <code>public</code> 方法生效，如果 <code>@Transactional</code> 注解标注在私有方法上或者非 <code>public</code> 方法上，事务也会失效。</li>\n</ol>\n<h3 id=\"1-18-Spring-的事务，使用-this-调用是否生效？\">1.18 Spring 的事务，使用 this 调用是否生效？</h3>\n<p>在 Spring 中使用 <code>this</code> 关键字调用同一个类中的 <code>@Transactional</code> 方法，事务是<strong>不会生效</strong>的，这是 Spring 事务失效最常见的原因之一，被称为<strong>自调用</strong>问题。</p>\n<p>Spring 的声明式事务管理 <code>@Transactional</code> 是通过 AOP（面向切面编程）实现的。当你在一个 Bean 上标注 <code>@Transactional</code> 时，Spring 容器会为该 Bean 创建一个<strong>代理对象</strong>（JDK 动态代理或 CGLIB 代理）。当外部代码（其他 Bean 的代码）调用这个 Bean 的事务方法时，实际上是调用了代理对象的方法。代理对象在调用目标方法（你写的原始方法）之前和之后，会插入事务管理的逻辑（开启事务、提交/回滚事务）。</p>\n<p>当你在同一个 Bean 的一个非事务方法 <code>A()</code> 中，使用 <code>this.事务方法B()</code> 来调用本 Bean 的事务方法 <code>B()</code> 时，<code>A()</code> 在被调用时，确实是代理对象在拦截执行（如果 <code>A()</code> 本身有事务，事务会生效）。但在 <code>A()</code> 方法体内部，<code>this</code> 关键字指向的是目标对象本身（即你写的原始 Bean 实例），而不是 Spring 创建的代理对象。所以 <code>this.B()</code> 这个调用是直接发生在目标对象内部，<strong>完全绕过了代理对象</strong>。代理对象的事务拦截逻辑（<code>TransactionInterceptor</code>）根本没有机会介入到 <code>B()</code> 的调用过程中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> OrderRepository orderRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 非事务方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">placeOrder</span><span class=\"params\">(Order order)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... 一些业务逻辑 ...</span></span><br><span class=\"line\">        <span class=\"comment\">// 自调用事务方法 - 事务会失效！</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.deductInventory(order.getProductId(), order.getQuantity());  <span class=\"comment\">// 使用 this 调用</span></span><br><span class=\"line\">        <span class=\"comment\">// ... 其他逻辑 ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 事务方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">deductInventory</span><span class=\"params\">(Long productId, <span class=\"type\">int</span> quantity)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 更新库存 - 期望在事务中执行</span></span><br><span class=\"line\">        productInventoryRepository.reduceStock(productId, quantity);</span><br><span class=\"line\">        <span class=\"comment\">// 如果这里发生异常，期望事务回滚，库存恢复</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如何解决自调用导致的事务失效呢？首选且推荐的最佳实践是将事务方法抽取到另一个独立的 Spring Bean 中，然后通过依赖注入进行调用。将需要事务管理的方法 <code>B()</code> 移动到另一个 Service 类中（例如 <code>InventoryService</code>），在原来的 Service（<code>OrderService</code>）中注入这个新的 <code>InventoryService</code>，然后在 <code>A()</code> 方法中调用 <code>inventoryService.deductInventory(...)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InventoryService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">deductInventory</span><span class=\"params\">(Long productId, <span class=\"type\">int</span> quantity)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... 事务性库存扣减 ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> InventoryService inventoryService;  <span class=\"comment\">// 注入新 Bean</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">placeOrder</span><span class=\"params\">(Order order)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        inventoryService.deductInventory(order.getProductId(), order.getQuantity());  <span class=\"comment\">// 调用其他Bean的方法</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为 <code>inventoryService</code> 是另一个 Spring Bean，对它方法的调用必然通过其代理对象，事务拦截器就能正常工作。</p>\n<h2 id=\"2-Spring-MVC\">2. Spring MVC</h2>\n<h3 id=\"2-1-什么是-Spring-MVC？工作原理是什么？\">2.1 什么是 Spring MVC？工作原理是什么？</h3>\n<p>Spring MVC 是 Spring 框架的一部分，它是一个基于 Java 的全功能 MVC Web 应用程序框架。MVC（Model-View-Controller）代表模型-视图-控制器，这是一种<strong>设计模式</strong>，用于将应用程序的数据访问、用户界面和业务逻辑分离开来。MVC 具体介绍如下：</p>\n<ul>\n<li>视图（View）：为用户提供使用界面，与用户直接进行交互。</li>\n<li>模型（Model）：代表一个存取数据的对象或 Java POJO（Plain Old Java Object，简单 Java 对象）。它也可以带有逻辑，主要用于承载数据，并对用户提交请求进行计算的模块。模型分为两类，一类称为数据承载 Bean，一类称为业务处理 Bean。所谓数据承载 Bean 是指实体类（如 <code>User</code> 类），专门为用户承载业务数据的；而业务处理 Bean 则是指 Service 或 Dao 对象，专门用于处理用户提交请求的。</li>\n<li>控制器（controller）：用于将用户请求转发给相应的 Model 进行处理，并根据 Model 的计算结果向用户提供相应响应，它使视图与模型分离。</li>\n</ul>\n<p>Spring MVC 的工作原理如下：</p>\n<ul>\n<li>用户发送请求：用户通过浏览器发送一个 HTTP 请求，直接请求到 <code>DispatcherServlet</code>。</li>\n<li><code>DispatcherServlet</code>（前端控制器）：请求被 Spring MVC 的 <code>DispatcherServlet</code> 捕获。<code>DispatcherServlet</code> 的作用类似于一个中央处理器，它会负责调用其他组件来处理请求。</li>\n<li><code>HandlerMapping</code>（控制器映射器）：<code>DispatcherServlet</code> 会调用 <code>HandlerMapping</code> 解析请求对应的 <code>Handler</code>，即找出处理这个请求的 <code>Controller</code>。</li>\n<li><code>Controller</code>（控制器）：找到合适的 <code>Controller</code> 后，<code>DispatcherServlet</code> 会将请求交给它。<code>Controller</code> 是真正处理请求的地方，它会处理用户的请求，并返回一个 <code>ModelAndView</code> 对象。<code>ModelAndView</code> 包含了模型（Model）数据和视图（View）名称。</li>\n<li><code>ViewResolver</code>（视图解析器）：<code>DispatcherServlet</code> 会把 <code>ModelAndView</code> 对象传给 <code>ViewResolver</code>。<code>ViewResolver</code> 会根据视图名称解析出真正的视图。</li>\n<li><code>View</code>（视图）：最后，<code>DispatcherServlet</code> 会渲染视图，并把模型数据填充进去。这个视图就是最终呈现给用户的页面。</li>\n</ul>\n<h3 id=\"2-2-介绍一下-Spring-MVC-的核心组件\">2.2 介绍一下 Spring MVC 的核心组件</h3>\n<p>Spring MVC 的核心组件主要包括以下几个：</p>\n<ul>\n<li><code>DispatcherServlet</code>（前端控制器）：这是 Spring MVC 框架的核心，负责将请求路由到其他组件。它处理所有的 HTTP 请求和响应。</li>\n<li><code>HandlerMapping</code>（控制器映射器）：它的任务是根据请求的 URL 找到正确的 <code>Controller</code>。</li>\n<li><code>Controller</code>（控制器）：这是应用程序的实际控制器，负责处理用户请求并返回一个模型和视图。</li>\n<li><code>HandlerAdapter</code>（控制器适配器）：它负责调用 <code>Controller</code> 中的方法。</li>\n<li><code>ViewResolver</code>（视图解析器）：它负责解析视图名并返回一个具体的视图对象。</li>\n<li><code>View</code>（视图）：这是最终呈现给用户的页面。</li>\n</ul>\n<p>除此之外，Spring MVC 还有一些其他的组件：</p>\n<ul>\n<li><code>HandlerExceptionResolver</code>（处理器异常解析器）：它负责处理在 <code>Controller</code> 执行过程中抛出的异常。</li>\n<li><code>LocaleResolver</code>（区域解析器）：它用于确定用户的区域，这对于国际化和本地化非常重要。</li>\n<li><code>MultipartResolver</code>（多部分解析器）：它用于处理 <code>multipart</code> 请求，例如文件上传。</li>\n<li><code>ThemeResolver</code>（主题解析器）：它用于确定应用程序的主题，这对于个性化布局非常有用。</li>\n<li><code>RequestToViewNameTranslator</code>（请求到视图名转换器）：它用于在 <code>Controller</code> 没有明确返回视图名时，提供一个默认的视图名。</li>\n<li><code>FlashMapManager</code>（Flash 映射管理器）：它用于存储和检索 FlashMap 模型，FlashMap 模型用于在重定向场景中存储属性。</li>\n</ul>\n<h3 id=\"2-3-HandlerMapping-和-HandlerAdapter-有了解吗？\">2.3 HandlerMapping 和 HandlerAdapter 有了解吗？</h3>\n<p>（1）HandlerMapping</p>\n<ul>\n<li>作用：HandlerMapping 负责将请求映射到控制器（Controller）。</li>\n<li>功能：根据请求的 URL、请求参数等信息，找到处理请求的控制器。</li>\n<li>类型：Spring 提供了多种 HandlerMapping 实现，如 BeanNameUrlHandlerMapping、<br>\nRequestMappingHandlerMapping 等。</li>\n<li>工作流程：根据请求信息确定要请求的控制器。HandlerMapping 可以根据 URL、请求参数等规则确定对应的控制器。</li>\n</ul>\n<p>（2）HandlerAdapter</p>\n<ul>\n<li>作用：HandlerAdapter 负责调用控制器来处理请求。</li>\n<li>功能：控制器可能有不同的接口类型（Controller 接口、HttpRequestHandler 接口等），HandlerAdapter 根据接口类型来选择合适的方法调用控制器。</li>\n<li>类型：Spring 提供了多个 HandlerAdapter 实现，用于适配不同类型的控制器。</li>\n<li>工作流程：根据控制器的接口类型，选择相应的 HandlerAdapter 来调用控制器。</li>\n</ul>\n<p>（3）工作流程</p>\n<ol>\n<li>当客户端发送请求时，HandlerMapping 根据请求信息找到对应的控制器。</li>\n<li>HandlerAdapter 根据控制器接口的类型选择合适的方法来调用控制器。</li>\n<li>控制器执行相应的业务逻辑，生成 ModelAndView。</li>\n<li>HandlerAdapter 将控制器的执行结果包装成 ModelAndView。</li>\n<li>视图解析器根据 ModelAndView 找到对应的视图（View）进行渲染。</li>\n<li>将渲染后的视图返回给客户端。</li>\n</ol>\n<p>HandlerMapping 和 HandlerAdapter 协同工作，通过将请求映射到控制器，并调用控制器来处理请求，实现了请求处理的流程。它们的灵活性使得在 Spring MVC 中可以支持多种处理器和处理方式，提高了框架的扩展性和适应性。</p>\n<h2 id=\"3-Spring-注解\">3. Spring 注解</h2>\n<h3 id=\"3-1-Spring-中常用的注解有哪些？\">3.1 Spring 中常用的注解有哪些？</h3>\n<ul>\n<li><code>@Component</code>：标注一个普通的 Spring Bean 类，当一个类被 <code>@Component</code> 注解标记时，Spring 会将其实例化为一个 Bean，并将其添加到 Spring 容器中。</li>\n<li><code>@Configuration</code>：用于标记一个类作为 Spring 的配置类。配置类可以包含 <code>@Bean</code> 注解的方法，用于定义和配置 Bean，作为全局配置：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyConfiguration</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> MyBean <span class=\"title function_\">myBean</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyBean</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>@Controller</code>：标注一个控制器组件类，它是 <code>@Component</code> 注解的特例，用于标记控制层的 Bean。这是 MVC 结构的另一个部分，加在控制层：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyController</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>@Bean</code>：用于标记一个方法作为 Spring 的 Bean 工厂方法。当一个方法被 <code>@Bean</code> 注解标记时，Spring 会将该方法的返回值作为一个 Bean，并将其添加到 Spring 容器中，如果自定义配置，经常用到这个注解。</li>\n<li><code>@Service</code>：标注一个业务逻辑层组件类，它也是 <code>@Component</code> 注解的特例，用于标记服务层的 Bean，一般标记在业务 Service 的实现类：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyServiceImpl</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>@Repository</code>：标注一个数据访问层组件类，它也是 <code>@Component</code> 注解的特例，用于标记数据访问层的 Bean。这个注解很容易被忽略，导致数据库无法访问。</li>\n<li><code>@Autowired</code>：由 Spring 提供的注解，用于自动装配 Bean，当 Spring 容器中存在与要注入的属性类型匹配的 Bean 时，它会自动将 Bean 注入到属性中。就跟我们 <code>new</code> 对象一样：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyService</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span>  <span class=\"comment\">// Spring会自动将MyService类型的Bean注入到myService属性中</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyService myService;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>@RequestMapping</code>：用于映射 Web 请求，包括访问路径和参数。</li>\n<li><code>@ResponseBody</code>：支持将返回值放在 <code>response</code> 内，而不是一个页面，通常用户返回 JSON 数据。</li>\n<li><code>@RestController</code>：该注解为一个组合注解，相当于 <code>@Controller</code> 和 <code>@ResponseBody</code> 的组合，注解在类上，意味着，该 <code>Controller</code> 的所有方法都默认加上了 <code>@ResponseBody</code>。</li>\n<li><code>@ExceptionHandler</code>：用于全局处理控制器里的异常。</li>\n<li><code>@PathVariable</code>：用于接收路径参数，比如 <code>@RequestMapping(&quot;/hello/&#123;name&#125;&quot;)</code> 申明的路径，将注解放在参数中前，即可获取该路径的 <code>name</code> 值，通常作为 RESTful 的接口实现方法。</li>\n<li><code>@EnableAsync</code>：在配置类中，通过此注解开启对异步任务的支持。</li>\n<li><code>@Async</code>：在实际执行的 Bean 方法使用该注解来申明其是一个异步任务。</li>\n<li><code>@EnableScheduling</code>：在配置类上使用，开启计划任务的支持。</li>\n<li><code>@Scheduled</code>：来申明这是一个任务，包括 <code>cron</code>、<code>fixDelay</code>、<code>fixRate</code> 等类型。</li>\n</ul>\n<h3 id=\"3-2-Controller-和-RestController-有什么区别？\">3.2 @Controller 和 @RestController 有什么区别？</h3>\n<p>（1）<code>@Controller</code>：<code>@Controller</code> 注解表示该类是一个 Web 控制器，通常与 <code>@RequestMapping</code> 注解一起使用，用于处理 HTTP 请求。在 <code>@Controller</code> 中，我们可以返回一个视图（View），这在 Spring Web MVC 中非常常见。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/books&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BookController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"meta\">@ResponseBody</span> Book <span class=\"title function_\">getBook</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> <span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> findBookById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Book <span class=\"title function_\">findBookById</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，<code>BookController</code> 类被标记为一个控制器，<code>/books</code> 是它的请求映射路径。<code>getBook()</code> 方法用于处理对 <code>/books/&#123;id&#125;</code> 路径的 GET 请求，其中 <code>&#123;id&#125;</code> 是路径变量。</p>\n<p>（2）<code>@RestController</code>：<code>@RestController</code> 是 <code>@Controller</code> 的特化，它包含了 <code>@Controller</code> 和 <code>@ResponseBody</code> 两个注解。这意味着，当一个类被 <code>@RestController</code> 注解标记后，该类的所有方法都会默认添加 <code>@ResponseBody</code> 注解。因此通常用于创建 RESTful Web 服务。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/books&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BookRestController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Book <span class=\"title function_\">getBook</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> <span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> findBookById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Book <span class=\"title function_\">findBookById</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，<code>BookRestController</code> 类被 <code>@RestController</code> 注解标记，因此不需要再每个请求处理方法上都添加 <code>@ResponseBody</code> 注解。</p>\n<p>总的来说二者的主要区别在于，<code>@Controller</code> 通常用于处理返回视图的请求，而 <code>@RestController</code> 通常用于处理返回 JSON 或 XML 响应的请求。</p>\n<h3 id=\"3-3-GetMapping、-PostMapping-和-RequestMapping-有什么区别？\">3.3 @GetMapping、@PostMapping 和 @RequestMapping 有什么区别？</h3>\n<p>（1）<code>@RequestMapping</code>：这是一个通用的注解，可以处理所有类型的 HTTP 请求。你可以通过 <code>method</code> 属性来指定处理的 HTTP 方法类型（如 GET、POST 等）。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.GET)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Users <span class=\"title function_\">getUsers</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(value = &quot;/users&quot;, method = RequestMethod.POST)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> User <span class=\"title function_\">createUser</span><span class=\"params\">(User user)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（2）<code>@GetMapping</code>：这是 <code>@RequestMapping</code> 的一个特化版本，用于处理 GET 请求，等价于 <code>@RequestMapping(method = RequestMethod.GET)</code>。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/users&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Users <span class=\"title function_\">getUsers</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（3）<code>@PostMapping</code>：同样是 <code>@RequestMapping</code> 的一个特化版本，用于处理 POST 请求，等价于 <code>@RequestMapping(method = RequestMethod.POST)</code>。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping(&quot;/users&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> User <span class=\"title function_\">createUser</span><span class=\"params\">(User user)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-RequestParam-和-PathVariable-有什么区别？\">3.4 @RequestParam 和 @PathVariable 有什么区别？</h3>\n<p>（1）<code>@RequestParam</code>：用于从请求参数中提取值。例如，对于 URL：<code>http://localhost:8080/books?id=1</code>，你可以使用 <code>@RequestParam</code> 来获取 <code>id</code> 参数的值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/books&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">getBook</span><span class=\"params\">(<span class=\"meta\">@RequestParam(&quot;id&quot;)</span> String id)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（2）<code>@PathVariable</code>：用于从 URI 路径中提取值。例如，对于 URL：<code>http://localhost:8080/books/1</code>，你可以使用 <code>@PathVariable</code> 来获取 <code>id</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/books/&#123;id&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">getBook</span><span class=\"params\">(<span class=\"meta\">@PathVariable(&quot;id&quot;)</span> String id)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-详细讲一下-Autowired-有什么用？\">3.5 详细讲一下 @Autowired 有什么用？</h3>\n<p>在 Spring 框架中，<code>@Autowired</code> 注解用于实现自动依赖注入。这意味着你不需要在代码中明确指定依赖关系，Spring 会自动为你完成这个工作，从而简化了代码并提高了可维护性。</p>\n<p><code>@Autowired</code> 注解可以应用于字段、构造器和方法：</p>\n<p>（1）字段上的 <code>@Autowired</code>：当 <code>@Autowired</code> 注解应用于字段时，Spring 会在创建 Bean 时自动注入相应的依赖。在下面这个例子中，<code>myService</code> 字段会被自动注入一个 <code>MyService</code> 类型的 Bean：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> MyService myService;</span><br></pre></td></tr></table></figure>\n<p>（2）构造器上的 <code>@Autowired</code>：当 <code>@Autowired</code> 注解应用于构造器时，Spring 会在创建 Bean 时自动注入构造器的参数。在下面这个例子中，<code>MyClass</code> 的构造器会被自动注入一个 <code>MyService</code> 类型的 Bean：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyService myService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyClass</span><span class=\"params\">(MyService myService)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.myService = myService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（3）方法上的 <code>@Autowired</code>：当 <code>@Autowired</code> 注解应用于方法时，Spring 会在创建 Bean 时自动注入方法的参数。这通常用于 Setter 方法，但也可以用于其他任何方法。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMyService</span><span class=\"params\">(MyService myService)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.myService = myService;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-Spring-Boot\">4. Spring Boot</h2>\n<h3 id=\"4-1-为什么要用-Spring-Boot？\">4.1 为什么要用 Spring Boot？</h3>\n<p>Spring Boot 是 Spring 框架的一个扩展，它的目标是简化 Spring 应用程序的配置和部署，Spring Boot 具有以下优势：</p>\n<ul>\n<li>快速开发：Spring Boot 通过提供一系列的开箱即用的组件和自动配置，简化了项目的配置和开发过程，开发人员可以更专注于业务逻辑的实现，而不需要花费过多时间在繁琐的配置上。例如，使用 Spring MVC 需要大量的 XML Bean 定义和自定义 <code>servlet</code> 类，但使用 Spring Boot 只需要添加一个 <code>starter</code> 依赖即可，无需任何代码生成或 XML 配置。</li>\n<li>快速启动：Spring Boot 提供了快速的应用程序启动方式，可通过内嵌的 Tomcat、Jetty 或 Undertow 等容器快速启动应用程序，无需额外的部署步骤，方便快捷。</li>\n<li>自动化配置：Spring Boot 通过自动配置功能，根据项目中的依赖关系和约定俗成的规则来配置应用程序，减少了配置的复杂性，使开发者更容易实现应用的最佳实践。</li>\n<li>有用的 Starters：Spring Boot Starters 是包含库和一些自动配置的 Maven 描述符。这些 Starters 可以为 Spring Boot 应用程序提供功能。例如，你想设置数据库连接，或者你想与消息队列进行通信或发送电子邮件，Spring Boot 都可以覆盖。</li>\n<li>嵌入式 Web 服务器：Spring Boot 提供了对嵌入式 Tomcat、Jetty 和 Undertow 服务器的开箱即用支持。这样，开发人员不必担心在传统的应用服务器中部署 Web 应用程序。</li>\n<li>丰富的 IDE 支持：所有主要的 IDE 都为 Spring Boot 提供了代码辅助支持。</li>\n<li>生产就绪的功能：Spring Boot 提供了开箱即用的监控、度量和日志记录功能。这些功能使开发人员可以避免额外的配置。</li>\n</ul>\n<h3 id=\"4-2-Spring-Boot-比-Spring-好在哪里？\">4.2 Spring Boot 比 Spring 好在哪里？</h3>\n<ul>\n<li>Spring Boot 提供了自动化配置，大大简化了项目的配置过程。通过约定优于配置的原则，很多常用的配置可以自动完成，开发者可以专注于业务逻辑的实现。</li>\n<li>Spring Boot 提供了快速的项目启动器，通过引入不同的 Starter，可以快速集成常用的框架和库（如数据库、消息队列、Web 开发等），极大地提高了开发效率。</li>\n<li>Spring Boot 默认集成了多种内嵌服务器（如 Tomcat、Jetty、Undertow），无需额外配置，即可将应用打包成可执行的 JAR 文件，方便部署和运行。</li>\n</ul>\n<h3 id=\"4-3-Spring-Boot-用到哪些设计模式？\">4.3 Spring Boot 用到哪些设计模式？</h3>\n<ul>\n<li>代理模式：Spring 的 AOP 通过动态代理实现方法级别的切面增强，有静态和动态两种代理方式，采用动态代理方式。</li>\n<li>策略模式：Spring AOP 支持 JDK 和 CGLIB 两种动态代理实现方式，通过策略接口和不同策略类，运行时动态选择，其创建一般通过工厂方法实现。</li>\n<li>装饰器模式：Spring 用 TransactionAwareCacheDecorator 解决缓存与数据库事务问题增加对事务的支持。</li>\n<li>单例模式：Spring Bean 默认是单例模式，通过单例注册表（如 HashMap）实现。</li>\n<li>简单工厂模式：Spring 中的 BeanFactory 是简单工厂模式的体现，通过工厂类方法获取 Bean 实例。</li>\n<li>工厂方法模式：Spring 中的 FactoryBean 体现工厂方法模式，为不同产品提供不同工厂。</li>\n<li>观察者模式：Spring 观察者模式包含 Event 事件、Listener 监听者、Publisher 发送者，通过定义事件、监听器和发送者实现，观察者注册在 ApplicationContext 中，消息发送由 ApplicationEventMulticaster 完成。</li>\n<li>模板模式：Spring Bean 的创建过程涉及模板模式，体现扩展性，类似 Callback 回调实现方式。</li>\n<li>适配器模式：Spring MVC 中针对不同方式定义的 Controller，利用适配器模式统一函数定义，定义了统一接口 HandlerAdapter 及对应适配器类。</li>\n</ul>\n<h3 id=\"4-4-怎么理解-Spring-Boot-中的约定优于配置？\">4.4 怎么理解 Spring Boot 中的约定优于配置？</h3>\n<p>约定优于配置是 Spring Boot 的核心设计理念，它通过<strong>预设合理的默认行为和项目规范</strong>，大幅减少开发者需要手动配置的步骤，从而提升开发效率和项目标准化程度。</p>\n<p>理解 Spring Boot 中的“约定优于配置”原则，可以从以下几个方面来解释：</p>\n<ul>\n<li>自动化配置：Spring Boot 提供了大量的自动化配置，通过分析项目的依赖和环境，自动配置应用程序的行为。开发者无需显式地配置每个细节，大部分常用的配置都已经预设好了。例如，引入 <code>spring-boot-starter-web</code> 后，Spring Boot 会自动配置内嵌 Tomcat 和 Spring MVC，无需手动编写 XML。</li>\n<li>默认配置：Spring Boot 为诸多方面提供大量默认配置，如连接数据库、设置 Web 服务器、处理日志等。开发人员无需手动配置这些常见内容，框架已做好决策。例如，默认的日志配置可让应用程序快速输出日志信息，无需开发者额外繁琐配置日志级别、输出格式与位置等。</li>\n<li>约定的项目结构：Spring Boot 提倡特定项目结构，通常主应用程序类（含 Main 方法）置于根包，控制器类、服务类、数据访问类等分别放在相应子包，如 <code>com.example.demo.controller</code> 放控制器类，<code>com.example.demo.service</code> 放服务类等。此约定使团队成员更易理解项目结构与组织，新成员加入项目时能快速定位各功能代码位置，提升协作效率。</li>\n</ul>\n<h3 id=\"4-5-Spring-Boot-的项目结构是怎么样的？\">4.5 Spring Boot 的项目结构是怎么样的？</h3>\n<ul>\n<li>开放接口层：定义系统<strong>对外暴露</strong>的协议（HTTP/RPC）和 API 规范，Controller 是其具体实现载体。</li>\n<li>终端显示层（半对应 Controller）：处理前端交互（渲染 HTML/JSON），在前后端分离架构中弱化此层。当前主要是 velocity 渲染、JS 渲染、JSP 渲染、移动端展示等。</li>\n<li>Web 层（直接对应 Controller）：处理 HTTP 请求路由、参数校验、返回响应，主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</li>\n<li>Service 层（直接对应 Service）：业务逻辑层，实现核心业务逻辑，一般还会分为 Service 接口层和 Service 实现层，用面向接口的编程思想，为后续功能的解耦和扩展留下余地。</li>\n<li>Manager 层：通用业务处理层，它有如下特征：\n<ul>\n<li>对第三方平台封装的层，预处理返回结果及转化异常信息，适配上层接口。</li>\n<li>对 Service 层通用能力的下沉，如缓存方案、中间件通用处理。</li>\n<li>与 DAO 层交互，对多个 DAO 的组合复用。</li>\n</ul>\n</li>\n<li>DAO 层（直接对应 Mapper）：数据访问（持久）层，与底层 MySQL、Oracle、Hbase、OceanBase 等进行数据交互。</li>\n<li>Pojo 层（直接对应 Model）：数据载体层，Entity 对应纯数据库映射对象（与 DB 强耦合），DTO/VO 用于传输，DTO 对应业务数据传输对象（包含业务字段），VO 对应前端展示对象（包含 UI 特定字段）。</li>\n<li>第三方服务：包括其它部门 RPC 服务接口，基础平台，其它公司的 HTTP 接口，如淘宝开放平台、支付宝付款服务、高德地图服务等，通常作为 Service 的依赖组件。</li>\n<li>外部接口：外部（应用）数据存储服务提供的接口，多见于数据迁移场景中。</li>\n</ul>\n<h3 id=\"4-6-Spring-Boot-自动装配原理是什么？\">4.6 Spring Boot 自动装配原理是什么？</h3>\n<p>Spring Boot 的自动装配原理是基于 Spring Framework 的条件化配置和 <code>@EnableAutoConfiguration</code> 注解实现的。这种机制允许开发者在项目中引入相关的依赖，Spring Boot 将根据这些依赖自动配置应用程序的上下文和功能。</p>\n<p>Spring Boot 定义了一套接口规范，这套规范规定：Spring Boot 在启动时会扫描类路径下以及外部引用 Jar 包中的所有 <code>META-INF/spring.factories</code> 文件（Spring Boot 2.x）或 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件（Spring Boot 3.x+），将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 Jar 来说，只需要按照 Spring Boot 定义的标准，就能将自己的功能装置进 Spring Boot。</p>\n<p>通俗来讲，自动装配就是通过注解或一些简单的配置就可以在 Spring Boot 的帮助下开启和配置各种功能，比如数据库访问、Web 开发。</p>\n<p>点进 <code>@SpringBootApplication</code> 注解的内部可以看到：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(</span></span><br><span class=\"line\"><span class=\"meta\">    excludeFilters = &#123;@Filter(</span></span><br><span class=\"line\"><span class=\"meta\">    type = FilterType.CUSTOM,</span></span><br><span class=\"line\"><span class=\"meta\">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class=\"line\"><span class=\"meta\">), @Filter(</span></span><br><span class=\"line\"><span class=\"meta\">    type = FilterType.CUSTOM,</span></span><br><span class=\"line\"><span class=\"meta\">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class=\"line\"><span class=\"meta\">)&#125;</span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> SpringBootApplication &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这些注解的作用如下：</p>\n<ul>\n<li><code>@Target(&#123;ElementType.TYPE&#125;)</code>：该注解指定了这个注解可以用来标记在类上。在这个特定的例子中，这表示该注解用于标记配置类。</li>\n<li><code>@Retention(RetentionPolicy.RUNTIME)</code>：这个注解指定了注解的生命周期，即在运行时保留。这是因为 Spring Boot 在运行时扫描类路径上的注解来实现自动配置，所以这里使用了 <code>RUNTIME</code> 保留策略。</li>\n<li><code>@Documented</code>：该注解表示这个注解应该被包含在 Java 文档中。它是用于生成文档的标记，使开发者能够看到这个注解的相关信息。</li>\n<li><code>@Inherited</code>：这个注解指示一个被标注的类型是被继承的。在这个例子中，它表明这个注解可以被继承，如果一个类继承了带有这个注解的类，它也会继承这个注解。</li>\n<li><code>@SpringBootConfiguration</code>：这个注解表明这是一个 Spring Boot 配置类。如果点进这个注解内部会发现与标准的 <code>@Configuration</code> 没啥区别，只是为了表明这是一个专门用于 Spring Boot 的配置。</li>\n<li><code>@EnableAutoConfiguration</code>：这个注解是 Spring Boot <strong>自动装配的核心</strong>。它告诉 Spring Boot 启用自动配置机制，根据项目的依赖和配置自动配置应用程序的上下文。通过这个注解，Spring Boot 将尝试根据类路径上的依赖自动配置应用程序。</li>\n<li><code>@ComponentScan</code>：这个注解用于配置组件扫描的规则。在这里，它告诉 Spring Boot 在指定的包及其子包中查找组件，这些组件包括被注解的类、<code>@Component</code> 注解的类等。其中的 <code>excludeFilters</code> 参数用于指定排除哪些组件，这里使用了两个自定义的过滤器，分别是 <code>TypeExcludeFilter</code> 和 <code>AutoConfigurationExcludeFilter</code>。</li>\n</ul>\n<h3 id=\"4-7-Spring-Boot-中如何实现对不同环境的属性配置文件的支持？\">4.7 Spring Boot 中如何实现对不同环境的属性配置文件的支持？</h3>\n<p>在 Spring Boot 中，你可以使用 Spring 的 Profile 功能来支持不同环境的属性配置文件。你可以为每个环境创建一个单独的配置文件，然后在运行应用程序时指定要使用的配置文件。</p>\n<p>例如，假设你有开发环境（dev）、质量保证环境（qa）和生产环境（prod）。你可以在与 <code>application.properties</code> 文件相同的位置创建三个文件：</p>\n<ul>\n<li><code>application-dev.properties</code>：用于开发环境。</li>\n<li><code>application-qa.properties</code>：用于质量保证环境。</li>\n<li><code>application-prod.properties</code>：用于生产环境。</li>\n</ul>\n<p>然后，你只需要在 <code>application.properties</code> 文件中设置 <code>spring.profiles.active</code> 属性，来指定当前的环境。例如，如果你想使用质量保证环境，你可以设置 <code>spring.profiles.active=qa</code>。</p>\n<p>此外，你还可以通过 JVM 参数来指定活动的配置文件。例如，你可以在启动应用程序时设置 <code>-Dspring.profiles.active=dev</code>。</p>\n<h3 id=\"4-8-如何理解-Spring-Boot-中的-Starters？\">4.8 如何理解 Spring Boot 中的 Starters？</h3>\n<p>在 Spring Boot 中，Starters 可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包。你可以一站式集成 Spring 及其他技术，快速地添加和管理项目的依赖，而不需要到处找示例代码和依赖包。</p>\n<p>例如，如果你想使用 Spring JPA 访问数据库，只要加入 <code>spring-boot-starter-data-jpa</code> 启动器依赖就能使用了。同样，如果你想创建一个 RESTful 的 Web 应用，你可以添加 <code>spring-boot-starter-web</code>。</p>\n<h3 id=\"4-9-Spring-Boot-Starters-的工作原理是什么？\">4.9 Spring Boot Starters 的工作原理是什么？</h3>\n<p>Spring Boot Starters 的工作原理主要包括以下几个步骤：</p>\n<ul>\n<li>引入模块所需的相关 Jar 包：Spring Boot Starter 会将具备某种功能的 Jar 包打包到一起，可以简化依赖导入的过程。例如，我们导入 <code>spring-boot-starter-web</code> 这个 Starter，则和 Web 开发相关的 Jar 包都一起导入到项目中了。</li>\n<li>自动配置各个模块所需的属性：Spring Boot 在启动时会去依赖的 Starter 包中寻找 <code>resources/META-INF/spring.factories</code> 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包。接着根据 <code>spring.factories</code> 配置加载 <code>AutoConfigure</code> 类。根据 <code>@Conditional</code> 注解的条件，进行自动配置并将 Bean 注入 Spring Context。</li>\n<li>Bean 的发现和加载：Spring Boot 默认扫描启动类所在的包下的主类与子类的所有组件，但并没有包括依赖包中的类，那么依赖包中的 Bean 是如何被发现和加载的？Spring Boot 在启动类上我们一般会加入 <code>@SpringBootApplication</code> 注解，此注解的源码中的 <code>@EnableAutoConfiguration</code> 注解引入了 <code>@Import</code> 这个注解，该注解导入自动配置功能类 <code>AutoConfigurationImportSelector</code>，主要方法 <code>getCandidateConfigurations()</code> 使用了 <code>SpringFactoriesLoader.loadFactoryNames()</code> 方法加载 <code>META-INF/spring.factories</code> 的文件（<code>spring.factories</code> 声明具体自动配置）。</li>\n</ul>\n<h3 id=\"4-10-介绍几个-Starter？\">4.10 介绍几个 Starter？</h3>\n<ul>\n<li><code>spring-boot-starter-web</code>：这是最常用的起步依赖之一，它包含了 Spring MVC 和 Tomcat 嵌入式服务器，用于快速构建 Web 应用程序。</li>\n<li><code>spring-boot-starter-security</code>：提供了 Spring Security 的基本配置，帮助开发者快速实现应用的安全<br>\n性，包括认证和授权功能。</li>\n<li><code>mybatis-spring-boot-starter</code>：这个 Starter 是由 MyBatis 团队提供的，用于简化在 Spring Boot 应用中集成 MyBatis 的过程。它自动配置了 MyBatis 的相关组件，包括 SqlSessionFactory、MapperScannerConfigurer 等，使得开发者能够快速地开始使用 MyBatis 进行数据库操作。</li>\n<li><code>spring-boot-starter-data-jpa</code> 或 <code>spring-boot-starter-jdbc</code>：如果使用的是 Java Persistence API（JPA）进行数据库操作，那么应该使用 <code>spring-boot-starter-data-jpa</code>。这个 Starter 包含了 Hibernate 等 JPA 实现以及数据库连接池等必要的库，可以让你轻松地与 MySQL 数据库进行交互。你需要在 <code>application.properties</code> 或 <code>application.yml</code> 中配置 MySQL 的连接信息。如果倾向于直接使用 JDBC 而不通过 JPA，那么可以使用 <code>spring-boot-starter-jdbc</code>，它提供了基本的 JDBC 支持。</li>\n<li><code>spring-boot-starter-data-redis</code>：用于集成 Redis 缓存和数据存储服务。这个 Starter 包含了与 Redis 交互所需的客户端（默认是 Jedis 客户端，也可以配置为 Lettuce 客户端），以及 Spring Data Redis 的支持，使得在 Spring Boot 应用中使用 Redis 变得非常便捷。同样地，需要在配置文件中设置 Redis 服务器的连接详情。</li>\n<li><code>spring-boot-starter-test</code>：包含了单元测试和集成测试所需的库，如 JUnit、Spring Test、AssertJ 等，便于进行测试驱动开发（TDD）。</li>\n</ul>\n<h3 id=\"4-11-Spring-Boot-的核心注解是什么？主要由哪几个注解组成？\">4.11 Spring Boot 的核心注解是什么？主要由哪几个注解组成？</h3>\n<p>Spring Boot 的核心注解是 <code>@SpringBootApplication</code>。这个注解实际上是以下三个注解的组合：</p>\n<ul>\n<li><code>@SpringBootConfiguration</code>：组合了 <code>@Configuration</code> 注解，实现配置文件的功能。</li>\n<li><code>@EnableAutoConfiguration</code>：打开自动配置的功能，也可以关闭某个自动配置的选项。如关闭数据源的自动配置功能：<code>@SpringBootApplication(exclude = &#123; DataSourceAutoConfiguration.class &#125;)</code>。</li>\n<li><code>@ComponentScan</code>：Spring 组件扫描功能，让 Spring Boot 扫描到 <code>Configuration</code> 类并把它加入到程序上下文。</li>\n</ul>\n<h3 id=\"4-12-Spring-Boot-中如何使用-Bean？\">4.12 Spring Boot 中如何使用 Bean？</h3>\n<p>在 Spring Boot 中，你可以通过使用 <code>@Bean</code> 注解来声明一个 Bean。<code>@Bean</code> 注解告诉 Spring 一个方法会返回一个对象，这个对象应该被注册为 Spring 应用上下文中的 Bean。默认情况下，Bean 的名称是由方法名决定的，但你也可以在 <code>@Bean</code> 注解中通过 <code>name</code> 属性来设置 Bean 的名称。</p>\n<p>例如，以下是一个简单的 <code>@Bean</code> 注解的使用示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> MyBean <span class=\"title function_\">myBean</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyBean</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，<code>myBean()</code> 方法被注解为 <code>@Bean</code>，所以它会返回一个新的 <code>MyBean</code> 实例，这个实例将被注册为 Spring 应用上下文中的 Bean。</p>\n<p>总的来说，你不需要在 Spring Boot 中手动配置 Bean，你只需要使用 <code>@Bean</code> 注解，Spring Boot 就会自动为你创建和管理 Bean。</p>\n<h3 id=\"4-13-RESTful-是什么？\">4.13 RESTful 是什么？</h3>\n<p>RESTful 是一种软件架构风格，它主要用于客户端和服务器交互类的软件。在 RESTful 风格中，用户发起请求的发送方式有 GET、POST、DELETE、PUT 等方式对请求的处理方法进行区分。这样可以在前后端分离式的开发中使得前端开发人员不会对请求的资源地址产生混淆和大量的检查方法名的麻烦，形成一个统一的接口，使得 Web 服务变得更加简洁、有层次，易于实现缓存等机制。</p>\n<p>在 Spring Boot 中，开发 RESTful 接口非常简单，通过不同的注解来支持前端的请求，除了经常使用的 <code>@RestController</code> 注解外，Spring Boot 还提供了一些组合注解。这些注解来帮助简化常用的 HTTP 方法的映射，并更好地表达被注解方法的语义。</p>\n<p>例如，Spring Boot 提供了与 REST 操作方式（GET、POST、PUT、DELETE）对应的注解：</p>\n<ul>\n<li><code>@GetMapping</code>：处理 GET 请求。</li>\n<li><code>@PostMapping</code>：处理 POST 请求。</li>\n<li><code>@PutMapping</code>：用于更新资源。</li>\n<li><code>@DeleteMapping</code>：处理删除请求。</li>\n<li><code>@PatchMapping</code>：用于更新部分资源。</li>\n</ul>\n<p>这些注解就是我们使用的 <code>@RequestMapping</code> 的简写版本：<code>@GetMapping</code> 其实就等于 <code>@RequestMapping(value = &quot;/xxx&quot;, method = RequestMethod.GET)</code>。</p>\n<h2 id=\"5-Spring-Cloud\">5. Spring Cloud</h2>\n<h3 id=\"5-1-什么是-Spring-Cloud？\">5.1 什么是 Spring Cloud？</h3>\n<p>Spring Cloud 是一系列框架的有序集合，它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发。Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理、服务发现、断路器、智能路由、微代理、控制总线）。分布式系统的协调导致了样板模式，使用 Spring Cloud 开发人员可以快速地支持实现这些模式的服务和应用程序。</p>\n<p>Spring Cloud 并不重复造轮子，而是将市面上开发得比较好的模块集成进去，进行封装，从而减少了各模块的开发成本。</p>\n<p>总的来说，Spring Cloud 是微服务系统架构的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶。</p>\n<h3 id=\"5-2-详细介绍一下分布式项目与微服务架构\">5.2 详细介绍一下分布式项目与微服务架构</h3>\n<p>分布式项目是指将一个大型的项目切割成多个小项目，每个小项目都是一套<strong>独立的</strong>系统。这些小项目被打成 Jar 包，然后通过互相引用（以 Jar 包的形式）来组装成原来的完整项目。每个子业务都是一套独立的系统，子业务之间相互协作，最终完成整体的大业务。这种方式可以提高系统的<strong>可扩展性</strong>和<strong>高可用性</strong>，解决<strong>高并发</strong>的问题，并且可以利用分布式存储将数据分片到多个节点上，不仅可以提高性能，同时也可以使用多个节点对同一份数据进行备份。</p>\n<p>微服务架构是一种软件开发框架，它将一个大型的应用程序划分为许多小的、独立的服务。每个服务都有自己的技术栈，包括数据库和数据管理模型。这些服务通常通过 REST API、事件流和消息代理进行通信，并按照业务能力进行组织。</p>\n<p>微服务架构的主要优点包括：</p>\n<ul>\n<li>代码更容易更新：可以直接添加新特性或功能，而不必更新整个应用。</li>\n<li>团队可以对不同的组件使用不同的技术栈和不同的编程语言。</li>\n<li>组件可以相互独立地扩展，从而减少与必须扩展整个应用相关的浪费和成本。</li>\n</ul>\n<p>然而，微服务架构也带来了一些挑战，例如管理复杂性的增加、日志记录数据的增加、新版本可能导致的向后兼容性问题、应用涉及更多网络连接可能导致的延迟和连接问题等。尽管如此，微服务架构仍然被广泛采用，因为它可以提高开发效率，使组织能够更快地响应业务需求。</p>\n<p>微服务架构和分布式系统是两个不同的概念，它们的主要区别在于设计目标和实现方式：</p>\n<ul>\n<li>分布式系统：分布式系统的核心就是<strong>拆分</strong>，只要是将一个项目拆分成了多个模块，并将这些模块分开部署，那就算是分布式。分布式解决的是系统性能问题，即解决系统部署上单点的问题，尽量让组成系统的子系统分散在不同的机器上进而提高系统的吞吐能力。分布式是<strong>部署层面</strong>的东西，即强调物理层面的组成，系统的各子系统部署在不同计算机上。</li>\n<li>微服务架构：微服务架构通过<strong>更细粒度的服务切分</strong>，使得整个系统的迭代速度和并行程度更高，但是运维的复杂度和性能会随着服务的粒度更细而增加。微服务重在<strong>解耦合</strong>，使每个模块都独立。微服务是<strong>设计层面</strong>的东西，一般考虑如何将系统从<strong>逻辑上</strong>进行拆分，也就是垂直拆分。微服务可以是分布式的，即可以将不同服务部署在不同计算机上，当然如果量小也可以部署在单机上。</li>\n</ul>\n<p>总的来说，分布式系统和微服务架构都是为了提高系统的可扩展性和可维护性，但它们的关注点和实现方式有所不同。</p>\n<h3 id=\"5-3-使用-Spring-Cloud-有什么优势？\">5.3 使用 Spring Cloud 有什么优势？</h3>\n<ul>\n<li>约定优于配置：Spring Cloud 提供了一套默认的配置，使得开发人员可以更专注于业务逻辑的开发。</li>\n<li>适用于各种环境：无论是开发环境、部署 PC Server，还是各种云环境（例如阿里云、AWS 等），Spring Cloud 都可以适用。</li>\n<li>隐藏了组件的复杂性：Spring Cloud 提供了声明式、无 XML 的配置方式，隐藏了组件的复杂性。</li>\n<li>开箱即用、快速启动：Spring Cloud 提供了一套完整的微服务解决方案，使得开发人员可以快速启动项目。</li>\n<li>轻量级的组件：Spring Cloud 整合的组件大多比较轻量。</li>\n<li>组件丰富、选型中立、功能齐全：Spring Cloud 为微服务架构提供了非常完整的支持，有丰富的组件选择，开发人员可以根据需求选择合适的组件。</li>\n<li>灵活：Spring Cloud 的组成部分是解耦合的，开发人员可以按需灵活挑选技术选型。</li>\n<li>服务拆分粒度更细：有利于资源重复利用，提高开发效率。</li>\n<li>采用去中心化思想：服务之间采用轻量级通讯，适合互联网时代，产品迭代周期更短。</li>\n</ul>\n<h3 id=\"5-4-服务注册和发现是什么意思？Spring-Cloud-如何实现？\">5.4 服务注册和发现是什么意思？Spring Cloud 如何实现？</h3>\n<p>服务注册是指将服务的元数据（例如服务名、IP 地址、端口号等）注册到注册中心中，以便其他服务可以发现它。例如，一个微服务启动后，会将自己的信息（通常是这个服务的 IP 和端口）注册到一个公共的组件上去（比如 ZooKeeper、Consul）。</p>\n<p>服务发现是指客户端从注册中心中查找和选择可用的服务实例，并通过负载均衡策略来分配请求。也就是说，新注册的这个服务模块能够及时的被其他调用者发现。不管是服务新增和服务删减都能实现自动发现。</p>\n<p>Spring Cloud 实现服务注册和发现的方式主要有以下几种：</p>\n<ul>\n<li>Eureka：Eureka 是 Netflix 开源的一款提供服务注册和发现的产品。Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务治理。在微服务应用启动后，Eureka Client 会向 Eureka Server 发送心跳。如果 Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，则会将该节点移除。</li>\n<li>Consul：Consul 是一种服务网格解决方案，提供了包括服务发现、配置和分段功能。这些功能中的每一个都可以根据需要独立使用，也可以一起使用以构建全堆栈服务网格。Consul 是适用于底层服务发现和配置的工具。</li>\n<li>ZooKeeper：ZooKeeper 是一个开源的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，是 Hadoop 和 Hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</li>\n</ul>\n<h3 id=\"5-5-负载均衡有什么作用？\">5.5 负载均衡有什么作用？</h3>\n<p>负载均衡是一种重要的网络技术，它可以有效地提高网络服务的性能、可用性和安全性。负载均衡的主要作用包括：</p>\n<ul>\n<li>解决并发压力：通过将客户端的请求分发到多个服务器，负载均衡可以有效地解决并发压力，提高应用处理性能，增加吞吐量，加强网络处理能力。</li>\n<li>提供故障转移：负载均衡可以检测后端服务的运行状况，自动检测异常实例，并快速实施故障转移；当实例恢复正常时，它将自动恢复负载。这样，即使某个服务器出现故障，负载均衡也可以保证服务的高可用性。</li>\n<li>提供网站伸缩性（扩展性）：当业务压力增加时，可以通过将主机添加到后端服务器池来提高性能。当压力降低时，可以减少宿主。这样，负载均衡可以根据业务需求动态地添加或减少服务器数量，提供网站的伸缩性。</li>\n<li>安全防护：负载均衡设备上可以做一些过滤，黑白名单等处理，提供安全防护。</li>\n</ul>\n<h3 id=\"5-6-Spring-Cloud-和-Dubbo-有什么区别？\">5.6 Spring Cloud 和 Dubbo 有什么区别？</h3>\n<p>Spring Cloud 和 Dubbo 都是现在主流的微服务框架，但它们之间存在一些主要的区别：</p>\n<ul>\n<li>初始定位不同：Spring Cloud 定位为微服务架构下的一站式解决方案，而 Dubbo 是 SOA（Service-Oriented Architecture，面向服务的架构）时代的产物，它的关注点主要在于服务的调用和治理。</li>\n<li>生态环境不同：Spring Cloud 依托于 Spring 平台，具备更加完善的生态体系；而 Dubbo 一开始只是做 RPC（Remote Procedure Call，远程过程调用）通信协议的远程调用，生态相对匮乏，现在才逐渐丰富起来。</li>\n<li>调用方式不同：Spring Cloud 是采用 HTTP 协议做远程调用，接口一般是 REST 风格，比较灵活；Dubbo 是采用 Dubbo 协议，接口一般是 Java 的 Service 接口，格式固定。</li>\n<li>服务网关：Dubbo 没有服务网关，而 Spring Cloud 使用的是 Spring Cloud Netflix Zuul。</li>\n<li>分布式配置：Dubbo 没有分布式配置，而 Spring Cloud 使用的是 Spring Cloud Config。</li>\n<li>服务跟踪：Dubbo 没有服务跟踪，而 Spring Cloud 使用的是 Spring Cloud Sleuth。</li>\n<li>消息总线：Dubbo 没有消息总线，而 Spring Cloud 使用的是 Spring Cloud Bus。</li>\n<li>数据流：Dubbo 没有数据流，而 Spring Cloud 使用的是 Spring Cloud Stream。</li>\n</ul>\n<h3 id=\"5-7-Sping-Cloud-微服务之间如何通讯？\">5.7 Sping Cloud 微服务之间如何通讯？</h3>\n<p>在 Spring Cloud 中，微服务之间的通信主要有两种方式：</p>\n<ul>\n<li>同步通信：Dubbo 通过 RPC 远程过程调用，而 Spring Cloud 通过 REST 接口 JSON 调用等（HTTP 通信）。</li>\n<li>异步通信：消息队列，如：RabbitMq、ActiveMq、Kafka 等。</li>\n</ul>\n<h2 id=\"6-MyBatis\">6. MyBatis</h2>\n",
            "tags": [
                "Interview"
            ]
        },
        {
            "id": "https://asanosaki.github.io/posts/53737.html",
            "url": "https://asanosaki.github.io/posts/53737.html",
            "title": "Java进阶面试题总结",
            "date_published": "2023-11-24T02:32:00.000Z",
            "content_html": "<blockquote>\n<p>Java 进阶面试题总结，涉及集合、JVM、并发等内容，文章将不断更新。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"1-Java集合\">1. Java集合</h2>\n<h3 id=\"1-1-Java中常见的集合有哪些？\">1.1 Java中常见的集合有哪些？</h3>\n<p>Java 中的集合主要可以分为四个部分：<code>List</code>、<code>Set</code>、<code>Map</code> 和工具类（如 <code>Iterator</code> 迭代器、<code>Enumeration</code> 枚举类、<code>Arrays</code> 和 <code>Collections</code>）。这些集合类主要由两个接口派生而来，即 <code>Collection</code>（包含 <code>List</code>、<code>Set</code>、<code>Queue</code>）和 <code>Map</code>，它们是集合框架的根接口。</p>\n<ul>\n<li><code>List</code>：一种有序列表的集合，例如，按索引排列的元素的 <code>List</code>。常见的实现类有 <code>ArrayList</code>、<code>LinkedList</code> 和 <code>Vector</code>。</li>\n<li><code>Set</code>：一种保证没有重复元素的集合。常见的实现类有 <code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code>。</li>\n<li><code>Map</code>：一种通过键值（Key-Value）查找的映射表集合。常见的实现类有 <code>HashMap</code> 和 <code>TreeMap</code>。</li>\n</ul>\n<h3 id=\"1-2-线程安全的集合有哪些？\">1.2 线程安全的集合有哪些？</h3>\n<p>Java 中的线程安全集合主要包括以下几种：</p>\n<ul>\n<li><code>Vector</code>：这是一个线程安全的动态数组，它提供了与 <code>ArrayList</code> 类似的功能，但每个方法都是同步的，这意味着在多线程环境下，它的性能会比 <code>ArrayList</code> 差。</li>\n<li><code>Hashtable</code>：这是一个线程安全的哈希表实现，类似于 <code>HashMap</code>，但是 <code>Hashtable</code> 的方法都是同步的。</li>\n<li><code>Stack</code>：这是一个线程安全的栈实现，它继承自 <code>Vector</code>。</li>\n<li><code>ConcurrentLinkedQueue</code>：这是一个线程安全的队列实现，使用了非阻塞算法。</li>\n<li><code>BlockingQueue</code> 接口的实现类，如 <code>ArrayBlockingQueue</code>，<code>LinkedBlockingQueue</code> 等。</li>\n<li><code>CopyOnWriteArrayList</code> 和 <code>CopyOnWriteArraySet</code>：这是两个线程安全的集合，它们会在修改操作时复制一份数据，避免了修改时的并发问题。</li>\n<li><code>ConcurrentHashMap</code>：这是一个线程安全的 <code>HashMap</code>，它通过将数据分段，从而达到并发控制，性能要优于 <code>Hashtable</code>。</li>\n<li><code>ConcurrentSkipListMap</code>：线程安全且排序的哈希表。</li>\n</ul>\n<p>值得注意的是，为了保证集合是线程安全的，相应的效率也比较低；线程不安全的集合效率相对会高一些。如果你的代码只在一个线程中运行，或者多个线程只是读取集合而不修改集合，那么你可以选择线程不安全的集合，因为它们的性能通常会更好。</p>\n<h3 id=\"1-3-ArrayList和LinkedList的异同点？\">1.3 ArrayList和LinkedList的异同点？</h3>\n<p><code>ArrayList</code> 和 <code>LinkedList</code> 都是 Java 中常用的 <code>List</code> 实现类，它们有一些共同点，也有一些不同点。</p>\n<p>共同点：</p>\n<ul>\n<li><code>ArrayList</code> 和 <code>LinkedList</code> 都是单列集合中 <code>List</code> 接口的实现类，它们都是存取允许重复，且有序的元素。</li>\n</ul>\n<p>不同点：</p>\n<ul>\n<li>内部实现：<code>ArrayList</code> 是基于动态数组实现的，底层使用数组来存储元素。而 <code>LinkedList</code> 是基于链表实现的，底层使用双向链表来存储元素。</li>\n<li>随机访问：对于随机访问 <code>get</code> 和 <code>set</code> 方法，<code>ArrayList</code> 的速度通常优于 <code>LinkedList</code>，因为 <code>ArrayList</code> 可以根据下标以 <code>O(1)</code> 的时间复杂度对元素进行随机访问，而 <code>LinkedList</code> 的每一个元素都依靠地址指针和它后一个元素连接在一起，查找某个元素的时间复杂度是 <code>O(n)</code>。</li>\n<li>插入和删除操作：对于插入和删除操作，<code>LinkedList</code> 的速度通常优于 <code>ArrayList</code>，因为当元素被添加到 <code>LinkedList</code> 任意位置的时候，不需要像 <code>ArrayList</code> 那样重新计算大小或者是更新索引。</li>\n<li>内存占用：<code>LinkedList</code> 比 <code>ArrayList</code> 更占内存，因为 <code>LinkedList</code> 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。而 <code>ArrayList</code> 使用数组来存储元素，因此插入和删除元素时需要移动其他元素占用内存，所以在频繁进行插入和删除操作时，<code>ArrayList</code> 的性能会比较低，且可能会造成内存浪费。</li>\n</ul>\n<h3 id=\"1-4-ArrayList的扩容机制是什么？\">1.4 ArrayList的扩容机制是什么？</h3>\n<p><code>ArrayList</code> 的扩容机制是其核心特性之一。在 <code>ArrayList</code> 中添加元素时，如果当前的数组已经满了，那么 <code>ArrayList</code> 会创建一个新的、更大的数组，并将原有数组的元素复制到新的数组中，这个过程就叫做扩容。</p>\n<p>具体来说，<code>ArrayList</code> 的扩容机制如下：</p>\n<ol>\n<li>当向 <code>ArrayList</code> 中添加元素时，首先会检查 <code>ArrayList</code> 的当前大小（也就是它内部的数组大小）是否能够容纳新的元素。如果可以，那么新元素就直接被添加到 <code>ArrayList</code> 中。</li>\n<li>如果 <code>ArrayList</code> 的当前大小不足以容纳新的元素，那么 <code>ArrayList</code> 就需要进行扩容操作。在扩容操作中，<code>ArrayList</code> 会创建一个新的数组，新数组的大小是原数组大小的1.5倍，这个值是在 JDK 的源码中定义的。</li>\n<li>接着，<code>ArrayList</code> 会使用 <code>System.arraycopy</code> 方法，将原有数组中的所有元素复制到新的数组中。</li>\n<li>最后，新的数组会替代原有的数组，成为 <code>ArrayList</code> 的内部数组。</li>\n</ol>\n<p>值得注意的是，<code>ArrayList</code> 的扩容操作需要重新分配内存空间，并将原来的元素复制到新的数组中，这可能会导致性能问题。因此，在实例化 <code>ArrayList</code> 时设置足够的初始容量，并且尽可能减少数组扩容的次数，可以帮助提高性能：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;Integer&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(<span class=\"number\">100</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-5-HashMap的底层数据结构是什么？\">1.5 HashMap的底层数据结构是什么？</h3>\n<p><code>HashMap</code> 的底层数据结构主要包括哈希表（数组）、链表和红黑树。</p>\n<ul>\n<li>哈希表（数组）：<code>HashMap</code> 主要依赖于哈希表来存储数据。哈希表中的每个元素被称为 <code>bucket</code>。数组的每个位置都可以存放一个元素（键值对），数组的索引是通过<strong>键的哈希码</strong>经过<strong>哈希函数</strong>计算得来的。这样我们就可以通过键快速定位到数组的某个位置，取出相应的值，这就是 <code>HashMap</code> 快速获取数据的原理。</li>\n<li>链表：在理想的情况下，哈希函数将每个键均匀地散列到哈希表的各个位置。但在实际中，我们可能会遇到两个不同的键计算出相同的哈希值，这就是所谓的<strong>哈希冲突</strong>。<code>HashMap</code> 通过使用链表来解决这个问题。当哈希冲突发生时，<code>HashMap</code> 会在冲突的 <code>bucket</code> 位置增加一个链表，新的元素会被添加到链表的末尾。每个链表中的元素都包含了相同哈希值的键值对。</li>\n<li>红黑树：从 Java 8 开始，如果链表的长度超过一定的阈值（默认为8），那么链表会被转换为红黑树。红黑树是一种自平衡的二叉查找树，通过保持树的平衡，可以提高查找效率。</li>\n</ul>\n<h3 id=\"1-6-为什么在解决Hash冲突的时候，不直接用红黑树，而是先用链表，再转红黑树？\">1.6 为什么在解决Hash冲突的时候，不直接用红黑树，而是先用链表，再转红黑树？</h3>\n<p>在解决 Hash 冲突的时候，<code>HashMap</code> 在链表长度大于8的时候才会将链表转换为红黑树，而不是直接使用红黑树，这主要有以下几个原因：</p>\n<ul>\n<li>查询效率：红黑树的平均查找长度是 <code>log(n)</code>，当链表长度为8时，查找长度为 <code>log(8) = 3</code>，而链表的平均查找长度为 <code>n/2</code>，当长度为8时，平均查找长度为 <code>8 / 2 = 4</code>。因此，当链表长度小于等于8时，使用链表的查询效率其实并不比红黑树差。</li>\n<li>插入效率和空间效率：链表的插入操作比红黑树快，且链表的空间占用也比红黑树小。因此，在元素数量较少时，使用链表比红黑树更高效1。</li>\n<li>防止频繁转换：如果链表长度在8左右徘徊，且频繁地进行插入和删除操作，可能会导致链表和红黑树之间频繁地转换，这会降低效率。因此，<code>HashMap</code> 设计了两个阈值，链表长度超过8时转为红黑树，少于6时转回链表，这样可以减少转换的频率。</li>\n</ul>\n<p>总的来说，这种设计是为了在保证查询效率的同时，尽可能地提高插入效率和空间效率，以及减少因频繁转换而带来的开销。</p>\n<h3 id=\"1-7-什么是负载因子？为什么HashMap的默认负载因子为0-75？\">1.7 什么是负载因子？为什么HashMap的默认负载因子为0.75？</h3>\n<p>负载因子是用于表示哈希表中元素填满的程度的一个参数。在哈希表（如 Java 的 <code>HashMap</code>）中，负载因子是和扩容机制有关的，当哈希表中的元素个数超过了容量乘以负载因子时，就会进行扩容。例如，如果当前的容器容量是16，负载因子是0.75，<code>16 * 0.75 = 12</code>，也就是说，当容量达到了12的时候就会进行扩容操作。</p>\n<p>负载因子的大小对哈希表的性能有重要影响。如果负载因子过大，那么哈希表中的冲突会更频繁，导致<strong>查找效率降低</strong>。反之，如果负载因子过小，那么哈希表的空间利用率就会降低，导致<strong>内存浪费</strong>。因此，选择一个合适的负载因子，可以在时间效率和空间效率之间达到一个平衡。在 Java 的 <code>HashMap</code> 中，负载因子的默认值是0.75，这是一个在时间和空间效率之间的折衷选择。</p>\n",
            "tags": [
                "Interview"
            ]
        },
        {
            "id": "https://asanosaki.github.io/posts/36915.html",
            "url": "https://asanosaki.github.io/posts/36915.html",
            "title": "Java基础面试题总结",
            "date_published": "2023-11-23T08:13:00.000Z",
            "content_html": "<blockquote>\n<p>Java 基础常见面试题总结，涉及 Java 基本概念、OOP、反射等内容，文章将不断更新。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"1-Java基本概念\">1. Java基本概念</h2>\n<h3 id=\"1-1-Java语言有哪些特点？\">1.1 Java语言有哪些特点？</h3>\n<ul>\n<li>面向对象（封装、继承、多态）：Java 是一种面向对象编程（OOP）的语言，它对类、对象、继承、封装、多态、接口、包等内容均有很好的支持。为了简单起见，Java 只支持类之间的单继承，但是可以使用接口来实现多继承。</li>\n<li>平台无关性：Java是“一次编写，到处运行”（Write Once, Run Anywhere）的语言，因此采用 Java 语言编写的程序具有很好的<strong>可移植性</strong>，而保证这一点的正是 Java 的虚拟机机制，在引入虚拟机之后，Java 语言在不同的平台上运行不需要重新编译。</li>\n<li>可靠性、安全性：Java 是被设计成编写高可靠和稳健软件的。Java 消除了某些编程错误，使得用它写可靠软件相当容易。</li>\n<li>支持多线程：C++ 没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 具备内置的多线程功能，可以将一个程序的不同程序段设置为不同的线程，使各线程并发、独立执行，提高系统的运行效率。</li>\n<li>支持网络编程：Java 诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便。</li>\n<li>编译与解释并存：Java 是一种先编译后解释的语言，Java 程序在 Java 平台运行时会被编译成字节码文件，然后可以在有 Java 环境的操作系统上运行。</li>\n<li>动态性：Java 语言设计成适应于变化的环境，它是一个动态的语言。例如，Java 中的类是根据需要载入的，甚至有些是通过网络获取的。</li>\n</ul>\n<h3 id=\"1-2-Java和C-有什么联系和区别？\">1.2 Java和C++有什么联系和区别？</h3>\n<p>联系：</p>\n<ul>\n<li>面向对象：Java 和 C++ 都支持面向对象编程，包括类、对象、继承、封装和多态。</li>\n<li>语法：Java 的语法在很大程度上受到了 C++ 的影响，因此这两种语言在语法上有很多相似之处。</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>内存管理：Java 有垃圾回收机制，可以自动回收不再使用的内存，而 C++ 需要程序员手动管理内存。</li>\n<li>指针和引用：C++ 支持指针，但 Java 没有指针的概念。相反，Java 使用引用来实现某些相似的功能。</li>\n<li>继承：C++ 支持多重继承，而 Java 不支持多重继承，但允许一个类实现多个接口。</li>\n<li>运行环境：Java 程序在 Java 平台上运行，可以在任何安装了 Java 虚拟机的系统上运行，而 C++ 程序是直接编译成特定操作系统的机器码。</li>\n<li>异常处理：Java 有一套完整的异常处理机制，而 C++ 的异常处理机制相对较弱。</li>\n</ul>\n<h3 id=\"1-3-Java和Python有什么联系和区别？\">1.3 Java和Python有什么联系和区别？</h3>\n<p>联系：</p>\n<ul>\n<li>面向对象：两者均支持面向对象编程（封装、继承、多态），但 Python 还支持函数式编程、过程式编程等范式。</li>\n<li>跨平台性：Java 通过 JVM（Java 虚拟机）实现“一次编写，到处运行”；Python 通过解释器（如 CPython、PyPy）实现跨平台，但需安装对应环境。</li>\n<li>丰富的生态系统：两者都有庞大的第三方库和框架支持。Java：Spring（企业级开发）、Hibernate（ORM）、Android SDK（移动开发）；Python：Django/Flask（Web 开发）、NumPy/Pandas（数据分析）、TensorFlow/PyTorch（机器学习）。</li>\n<li>自动内存管理：均通过垃圾回收机制（GC）自动管理内存，开发者无需手动分配/释放内存。</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>语言设计哲学：Java 为静态类型（编译时检查类型），而 Python 为动态类型（运行时推断类型）；Java 语法严格，需分号和大括号，而 Python 语法简洁，依赖缩进（强制代码可读性）；Java “一次编写，到处运行”（强调稳定性和性能），而 Python “优雅、明确、简单”（强调开发效率和可读性）。</li>\n<li>执行方式：Java 先编译为字节码（<code>.class</code>），再由 JVM 执行，而 Python 解释执行（逐行翻译），但会生成字节码（<code>.pyc</code>）缓存；Java 接近 C++，适合高性能场景（如服务器、大型系统），而 Python 解释执行较慢，但可通过 C 扩展（如 NumPy）或 JIT（PyPy）优化。</li>\n<li>应用场景：Java 代码量大，适合长期维护的大型项目，如企业级应用、Android 开发、金融系统、大数据（Hadoop/Spark），而 Python 代码简洁，适合快速原型开发，如数据分析、机器学习、中小型 Web 开发、脚本自动化、科学计算。</li>\n<li>并发模型：Java 原生支持多线程，JVM 利用操作系统线程，通过 <code>java.util.concurrent</code> 包实现高效并发，而 Python 受 GIL（全局解释器锁）限制，多线程在 CPU 密集型任务中效率低，可使用多进程（<code>multiprocessing</code> 模块）或异步编程（<code>asyncio</code>）绕过 GIL 限制。</li>\n</ul>\n<h3 id=\"1-4-JVM、JRE和JDK的关系是什么？\">1.4 JVM、JRE和JDK的关系是什么？</h3>\n<p>JVM、JRE 和 JDK 是 Java 开发和运行的三个核心组件，它们之间的关系可以概括为：JDK 包含 JRE，而 JRE 包含 JVM。下面是对这三者的详细介绍：</p>\n<ul>\n<li>JVM（Java Virtual Machine）：Java 虚拟机，是 Java 能够实现跨平台的核心机制。JVM 只认识 <code>.class</code> 后缀的文件，它能将 <code>class</code> 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。</li>\n<li>JRE（Java Runtime Environment）：Java 运行环境，包括 Java 虚拟机（JVM）和 Java 程序所需的核心类库等。如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可。</li>\n<li>JDK（Java Development Kit）：Java 的开发工具包，是提供给 Java 开发人员使用的，其中包含了 Java 的开发工具和 JRE。其中的开发工具包括：运行工具（<code>java.exe</code>）、编译工具（<code>javac.exe</code>）、打包工具（<code>jar.exe</code>）等。</li>\n</ul>\n<p>所以，简单来说，JDK 是用于开发 Java 应用的，JRE 是用于运行 Java 应用的，而 JVM 则是使 Java 能够跨平台的核心。</p>\n<h3 id=\"1-5-什么是字节码？采用字节码的好处是什么？\">1.5 什么是字节码？采用字节码的好处是什么？</h3>\n<p>字节码是一种中间状态的<strong>二进制文件</strong>，是由源码编译过来的，可读性没有源码的高。CPU 并不能直接读取字节码，在 Java 中，字节码需要经过 JVM 转译成机器码之后，CPU 才能读取并运行。采用字节码的好处主要有以下几点：</p>\n<ul>\n<li>跨平台性：字节码可以在不同的平台上运行，只需要有一个能够识别并解释字节码的解释器即可。</li>\n<li>高效率：字节码可以在运行时动态编译为机器代码，这样就可以在保证程序执行效率的同时避免了额外的编译步骤。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点，所以 Java 程序运行时比较高效。</li>\n<li>可调试性：字节码是可读的，因此可以方便地进行调试和分析。</li>\n<li>可扩展性：字节码可以被扩展以支持新的特性，而不需要更改现有的机器代码。</li>\n</ul>\n<h3 id=\"1-6-Java有哪些数据类型？\">1.6 Java有哪些数据类型？</h3>\n<p>Java 的数据类型可以分为两大类：基本数据类型和引用数据类型。</p>\n<p>基本数据类型包括以下八种：</p>\n<ul>\n<li><code>byte</code>：8位有符号二进制整数，取值范围为 <code>-128~127</code>。</li>\n<li><code>short</code>：16位有符号二进制整数，取值范围为 <code>-32768~32767</code>。</li>\n<li><code>int</code>：32位有符号二进制整数，取值范围为 <code>-2147483648~2147483647</code>。</li>\n<li><code>long</code>：64位有符号二进制整数，取值范围为 <code>-9223372036854775808~9223372036854775807</code>。</li>\n<li><code>float</code>：32位单精度浮点数。</li>\n<li><code>double</code>：64位双精度浮点数。</li>\n<li><code>boolean</code>：布尔值，只有两个取值：<code>true</code> 和 <code>false</code>。</li>\n<li><code>char</code>：单个16位 Unicode 字符，取值范围为 <code>\\u0000~\\uffff</code>。</li>\n</ul>\n<p>引用数据类型包括：</p>\n<ul>\n<li>类（Class）：由程序员定义的一种数据类型，它将数据和对数据的操作封装在一起。</li>\n<li>接口（Interface）：一种引用类型，类似于类，由完全抽象的方法和常量组成。</li>\n<li>数组（Array）：可以保存多个同类型变量的容器。</li>\n</ul>\n<h2 id=\"2-面向对象\">2. 面向对象</h2>\n<h3 id=\"2-1-面向对象的三大特性是什么？\">2.1 面向对象的三大特性是什么？</h3>\n<ul>\n<li>封装：封装是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。</li>\n<li>继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</li>\n<li>多态：多态是指允许不同类的对象对同一消息做出响应。也就是说，同一个接口可以具有多种实现方式。</li>\n</ul>\n<h3 id=\"2-2-访问修饰符的区别？\">2.2 访问修饰符的区别？</h3>\n<p>Java 有四种访问修饰符，它们分别是 <code>public</code>、<code>protected</code>、<code>default</code>（默认，无修饰符）和 <code>private</code>。以下是它们的详细介绍：</p>\n<ul>\n<li><code>public</code>：公共访问修饰符，被声明为 <code>public</code> 的类、方法、构造方法和接口能够被任何其他类访问。如果几个相互访问的 <code>public</code> 类分布在不同的包中，则需要导入相应 <code>public</code> 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。</li>\n<li><code>protected</code>：受保护的访问修饰符，被声明为 <code>protected</code> 的变量、方法和构造器能被同一个包中的任何其他类访问；同时，被 <code>protected</code> 所修饰的成员也能被该类的所有子类继承下来，无论子类和基类是否在同一包中。</li>\n<li><code>default</code>（默认，无修饰符）：包私有访问修饰符，表示只能在当前包中的类访问该成员。被 <code>default</code> 所修饰的成员只能被该类所在同一个包中的子类所继承下来。</li>\n<li><code>private</code>：私有访问修饰符，表示只能在当前类中访问该成员，除了当前类都不能访问。私有访问修饰符是最严格的访问级别，所有被声明为 <code>private</code> 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 <code>private</code>。</li>\n</ul>\n<h3 id=\"2-3-Java语言是如何实现多态的？\">2.3 Java语言是如何实现多态的？</h3>\n<p>我们通常所说的多态指的都是运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定，这也是为什么有时候多态方法又被称为延迟方法的原因。Java 语言实现多态主要依赖于以下三个条件：</p>\n<ul>\n<li>继承：必须存在子类继承父类的继承关系，只有在存在继承关系的前提下，子类才能继承父类的属性和方法，从而实现多态。</li>\n<li>重写：子类需要对父类中的一些方法进行重写，当调用这些方法时，会调用子类重写的方法，而不是原本父类的方法。</li>\n<li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样，该引用才能够具备调用父类的方法和子类的方法的能力。</li>\n</ul>\n<h3 id=\"2-4-重载和重写的区别？\">2.4 重载和重写的区别？</h3>\n<p>Java 中的重载和重写都是实现多态的方式，但它们的实现方式和使用场景有所不同：</p>\n<p>重载（Overload）：</p>\n<ul>\n<li>重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载。</li>\n<li>重载的方法可以改变返回类型；可以相同也可以不同，但不能通过返回类型是否相同来判断重载。</li>\n<li>重载是编译时的多态性。</li>\n</ul>\n<p>重写（Override）：</p>\n<ul>\n<li>重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型。</li>\n<li>重写的方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。</li>\n<li>重写是运行时的多态性。</li>\n</ul>\n<p>注意：构造器不能被继承，因此不能被重写，但可以被重载。每一个类必须有自己的构造函数，负责构造自己这部分的构造内容。子类不会覆盖父类的构造函数，相反必须在构造函数的一开始就调用父类的构造函数。</p>\n<h3 id=\"2-5-抽象类和接口的区别？\">2.5 抽象类和接口的区别？</h3>\n<p>语法层面上的区别：</p>\n<ul>\n<li>接口只能定义抽象方法不能实现方法，抽象类既可以定义抽象方法，也可以实现方法。</li>\n<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <code>public static final</code> 类型的。</li>\n<li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法。</li>\n<li>抽象类是单继承，而接口是多继承。一个类只能继承一个抽象类，但可以实现多个接口。</li>\n<li>抽象类的方法访问控制符无限制，只是抽象类中的 <code>abstract</code> 方法不能被 <code>private</code> 修饰；而接口有限制，接口默认为 <code>public</code> 控制符。</li>\n<li>抽象类可以有构造方法，接口中不能有构造方法。</li>\n</ul>\n<p>设计层面上的区别：</p>\n<ul>\n<li>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（只有行为）进行抽象。</li>\n<li>二者的设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。</li>\n</ul>\n<h3 id=\"2-6-什么是不可变对象？有什么好处？\">2.6 什么是不可变对象？有什么好处？</h3>\n<p>在 Java 中，不可变对象（Immutable Object）是指一旦被创建后，对象所有的状态及属性在其生命周期内不会发生任何变化。也就是说，一个对象在创建后，不能对该对象进行任何更改。如 <code>String</code>、<code>Integer</code> 以及其它包装类。不可变对象有很多优点：</p>\n<ul>\n<li>构造、测试和使用都很简单：由于对象状态不会改变，所以可以避免了很多复杂的状态检查和同步。</li>\n<li>线程安全且没有同步问题：线程安全是最大的好处，在并发环境下，不可变对象无需进行额外的同步操作，因此可以极大地简化并发编程。</li>\n<li>不需要担心数据会被其它线程修改：这是因为对象的状态不会改变，所以不会出现一个线程正在读取对象状态，而另一个线程同时修改该状态的情况。</li>\n<li>当用作类的属性时不需要保护性拷贝：如果类的属性是可变的，那么在返回属性值或者接收新的属性值时，需要进行保护性拷贝以防止属性被外部代码修改。而对于不可变对象，由于其状态不能被修改，所以无需进行保护性拷贝。</li>\n<li>可以很好的用作 <code>Map</code> 键值和 <code>Set</code> 元素：由于不可变对象一旦创建就不能改变，所以它们是值得信赖的键值，可以确保在对象被用作键值的过程中始终保持一致性。</li>\n</ul>\n<p>然而，不可变对象也有一些缺点，最大的缺点就是创建对象的开销，因为每一步修改操作都会产生一个新的对象。</p>\n<h3 id=\"2-7-equals方法和-的区别？\">2.7 equals方法和==的区别？</h3>\n<p>在 Java 中，<code>==</code> 和 <code>equals()</code> 方法都可以用来比较两个对象，但它们的比较方式和使用场景有所不同：</p>\n<p>首先 <code>==</code> 是一个运算符，而 <code>equals()</code> 是一个方法，二者比较的内容有以下不同：</p>\n<ul>\n<li><code>==</code>：如果比较的是<strong>基本数据类型</strong>，则比较的是<strong>数值</strong>是否相等；如果比较的是<strong>引用数据类型</strong>，则比较的是两个对象的<strong>内存地址</strong>是否相等。</li>\n<li><code>equals()</code>：默认情况下，比较的是两个对象的<strong>内存地址</strong>。但是，许多类（如 <code>String</code>、<code>Integer</code> 等）已经<strong>重写</strong>了 <code>equals()</code> 方法，使其能够比较两个对象的<strong>内容</strong>是否相等。</li>\n</ul>\n<p>二者的一般使用场景如下：</p>\n<ul>\n<li><code>==</code>：通常用于比较基本数据类型，或者比较两个对象是否指向同一内存地址。</li>\n<li><code>equals()</code>：通常用于比较两个对象的内容是否相等。</li>\n</ul>\n<h3 id=\"2-8-String、StringBuffer、StringBuilder的区别是什么？\">2.8 String、StringBuffer、StringBuilder的区别是什么？</h3>\n<ul>\n<li>可变性：<code>String</code> 是不可变的，也就是说，一旦 <code>String</code> 对象被创建，其值就不能被改变。如果需要修改 <code>String</code>，Java 会创建一个新的 <code>String</code> 对象。<code>StringBuffer</code> 和 <code>StringBuilder</code> 是可变的，也就是说，它们可以在原地修改字符串，而不需要创建新的对象。</li>\n<li>线程安全性：<code>StringBuffer</code> 是线程安全的，因为它的所有公共方法都是同步的。这意味着在多线程环境下，<code>StringBuffer</code> 可以安全地使用。<code>StringBuilder</code> 不是线程安全的。因此，如果你的代码只在单线程环境下运行，使用 <code>StringBuilder</code> 通常会比 <code>StringBuffer</code> 更快。</li>\n<li>性能：对于需要频繁修改字符串的情况，使用 <code>StringBuffer</code> 或 <code>StringBuilder</code> 通常比使用 <code>String</code> 更高效。这是因为每次修改 <code>String</code> 时，都会创建一个新的对象，这会对性能产生影响。在大部分情况下，<code>StringBuilder</code> 的性能优于 <code>StringBuffer</code>，这主要是因为 <code>StringBuilder</code> 不需要考虑线程安全。</li>\n</ul>\n<h3 id=\"2-9-为什么Java中的String要设计成不可变的？\">2.9 为什么Java中的String要设计成不可变的？</h3>\n<ul>\n<li>安全性：不可变对象本身是线程安全的，可以在多线程环境下安全使用，无需额外的同步。此外，<code>String</code> 经常被用作许多 Java 类的参数，例如网络连接和文件路径，如果是可变的，那么它的值可能在你不知情的情况下被改变，这可能会导致安全问题。</li>\n<li>哈希码缓存：由于 <code>String</code> 是不可变的，所以它的哈希码是固定的，可以被缓存，这对于哈希映射（如 <code>HashMap</code>）来说非常有用，可以提高查找效率。</li>\n<li>字符串池：在 Java 中，相同的字符串字面量只会在内存中存在一份，这被称为字符串池（String Pool）。这种设计可以节省内存，提高效率。如果 <code>String</code> 是可变的那么字符串池就无法实现了。</li>\n<li>类加载器安全：<code>String</code> 是 Java 类加载器使用的关键类，如果是可变的那么可能会影响到类加载器的安全性。</li>\n</ul>\n<h3 id=\"2-10-基本类型和包装类型有什么区别？什么是自动装箱-拆箱？\">2.10 基本类型和包装类型有什么区别？什么是自动装箱/拆箱？</h3>\n<p>基本类型和包装类型的主要区别如下：</p>\n<ul>\n<li>初始值：基本类型有初始值，而包装类型的默认值是 <code>null</code>。</li>\n<li><code>null</code> 值：包装类型可以为 <code>null</code>，而基本类型不可以。</li>\n<li>存储位置：如果一个基本类型是成员变量就存储在堆内存里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用。</li>\n<li>泛型：包装类型可用于泛型，而基本类型不可以。</li>\n<li>比较：在使用 <code>==</code> 进行判断的时候，基本类型使用 <code>==</code> 直接判断其值是否相等，而包装类型判断的是其指向的地址是否相等。</li>\n</ul>\n<p>自动装箱和自动拆箱是 Java 语言的特性，使得基本类型和包装类型之间的转换更加方便：</p>\n<ul>\n<li>自动装箱：就是将基本数据类型自动转换为对应的包装类。例如，<code>Integer i = 10;</code>，这里的10是一个 <code>int</code> 类型，但 Java 会自动将其转换（装箱）为 <code>Integer</code> 类型。</li>\n<li>自动拆箱：就是将包装类自动转换为基本数据类型。例如，<code>int a = i;</code>，这里的 <code>i</code> 是 <code>Integer</code> 类型，但 Java 会自动将其转换（拆箱）为 <code>int</code> 类型。</li>\n</ul>\n<p>这些特性使得我们在编写 Java 代码时可以更自然地混合使用基本类型和包装类型，而不需要关心它们之间的转换细节。</p>\n<h3 id=\"2-11-B-S和C-S架构分别是什么？\">2.11 B/S和C/S架构分别是什么？</h3>\n<p>B/S 架构和 C/S 架构是两种常见的软件系统体系结构。</p>\n<ul>\n<li>B/S 架构，全称为 Browser/Server，即浏览器/服务器结构。它是 Web 兴起后的一种网络结构模式，Web 浏览器是客户端最主要的应用软件。这种模式统一了客户端，将系统功能实现的核心部分集中到服务器上，简化了系统的开发、维护和使用。客户端只需要安装一个浏览器，通过 Web 服务器与数据库服务器进行数据交互。B/S 架构利用了 Web 浏览器技术和 Internet 协议，实现了异构系统的连接和信息的共享。</li>\n<li>C/S 架构，全称是 Client/Server，即客户端/服务器体系结构，主要应用于局域网内。它是一种网络体系结构，通常采取两层结构，服务器负责数据的管理，客户端负责完成与用户的交互任务。即客户端是用户运行应用程序的 PC 端或者工作站，客户端要依靠服务器来获取资源。</li>\n</ul>\n<h2 id=\"3-反射\">3. 反射</h2>\n<h3 id=\"3-1-什么是反射？\">3.1 什么是反射？</h3>\n<p>在 Java 中，反射是一种强大的工具，它允许程序在<strong>运行时</strong>访问类或对象的信息，并<strong>动态地</strong>操作它们。以下是反射的一些主要特性和用途：</p>\n<ul>\n<li>动态创建对象：反射可以在运行时动态地创建任意一个类的对象。</li>\n<li>获取类的信息：反射可以获取任意一个类的所有属性和方法，包括私有的。</li>\n<li>动态调用方法和属性：反射可以在运行时动态地调用任意一个对象的任意方法和属性。</li>\n<li>动态修改属性：反射可以改变对象的属性，甚至可以打破封装性，导致 Java 对象的属性不安全。</li>\n</ul>\n<p>反射在许多 Java 框架中都有应用，例如 Spring 和 Hibernate，它们使用反射来实现依赖注入和对象关系映射。然而，反射也有其缺点，例如可能会消耗更多的系统资源，如果不需要动态地创建一个对象，那么就不需要用反射。此外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</p>\n<h3 id=\"3-2-举一下反射使用的例子？\">3.2 举一下反射使用的例子？</h3>\n<p>（1）获取 <code>Class</code> 对象：我们可以通过三种方式获取 <code>Class</code> 对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 通过类名.class的方式</span></span><br><span class=\"line\">Class&lt;String&gt; c1 = String.class;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 通过对象的getClass()方法</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\">Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">String</span>&gt; c2 = s.getClass();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 通过Class类的静态方法forName(String className)</span></span><br><span class=\"line\">Class&lt;?&gt; c3 = Class.forName(<span class=\"string\">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>（2）创建对象：我们可以通过 <code>Class</code> 对象的 <code>newInstance()</code> 方法来创建对应类的对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; c = Class.forName(<span class=\"string\">&quot;java.lang.String&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> (String) c.newInstance();</span><br></pre></td></tr></table></figure>\n<p>（3）获取方法并调用：我们可以通过 <code>Class</code> 对象的 <code>getMethod()</code> 方法来获取一个类的方法，然后通过 <code>Method</code> 对象的 <code>invoke()</code> 方法来调用这个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; c = Class.forName(<span class=\"string\">&quot;java.lang.String&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> c.getMethod(<span class=\"string\">&quot;substring&quot;</span>, <span class=\"type\">int</span>.class, <span class=\"type\">int</span>.class);</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> (String) method.invoke(<span class=\"string\">&quot;Hello World&quot;</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>);  <span class=\"comment\">// Hello</span></span><br></pre></td></tr></table></figure>\n<p>（4）获取和设置字段：我们可以通过 <code>Class</code> 对象的 <code>getField()</code> 方法来获取一个类的公有字段，然后通过 <code>Field</code> 对象的 <code>get()</code> 和 <code>set()</code> 方法来获取和设置这个字段的值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; c = Class.forName(<span class=\"string\">&quot;java.awt.Dimension&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> c.newInstance();</span><br><span class=\"line\"><span class=\"type\">Field</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> c.getField(<span class=\"string\">&quot;width&quot;</span>);</span><br><span class=\"line\">f.set(o, <span class=\"number\">100</span>);</span><br><span class=\"line\">System.out.println(f.getInt(o));  <span class=\"comment\">// 100</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-介绍一下反射在JDBC和Spring中的应用\">3.3 介绍一下反射在JDBC和Spring中的应用</h3>\n<p>（1）在 JDBC 中的应用：我们在使用 JDBC 连接数据库时，会使用 <code>Class.forName()</code> 通过反射加载数据库的驱动程序。例如，假设我们有 <code>com.mysql.cj.jdbc.Driver</code> 这个类，如果我们使用 MySQL 数据库，那么就传入 MySQL 的驱动类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加载并注册JDBC驱动</span></span><br><span class=\"line\">Class.forName(<span class=\"string\">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建数据库连接</span></span><br><span class=\"line\"><span class=\"type\">Connection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> DriverManager.getConnection(<span class=\"string\">&quot;jdbc:mysql://localhost:3306/&lt;DatabaseName&gt;&quot;</span>, <span class=\"string\">&quot;&lt;username&gt;&quot;</span>, <span class=\"string\">&quot;&lt;password&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>（2）在 Spring 中的应用：Spring 通过配置文件配置各种各样的 <code>bean</code>，你需要用到哪些 <code>bean</code> 就配哪些，Spring 容器就会根据你的需求去动态加载。Spring 的 IoC 容器可以动态地加载和管理 <code>bean</code>，创建对象。这是通过反射实现的，Spring 会读取配置文件中的类全名，然后通过反射来创建对象：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Spring配置文件 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;myBean&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.example.MyClass&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;myProperty&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Hello World&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从Spring IoC容器中获取bean</span></span><br><span class=\"line\"><span class=\"type\">ApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;beans.xml&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">MyClass</span> <span class=\"variable\">myBean</span> <span class=\"operator\">=</span> (MyClass) context.getBean(<span class=\"string\">&quot;myBean&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出：Hello World</span></span><br><span class=\"line\">System.out.println(myBean.getMyProperty());</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-反射机制的原理是什么？\">3.4 反射机制的原理是什么？</h3>\n<p>Java 反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质上，当 JVM 得到 <code>Class</code> 对象之后，再通过 <code>Class</code> 对象进行反编译，从而获取对象的各种信息。Java 属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到 JVM。通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。</p>\n<p>反射的原理可以通过以下步骤来理解：</p>\n<ul>\n<li>加载：首先，将 <code>.class</code> 文件读入内存，并为之创建一个 <code>Class</code> 对象。</li>\n<li>反编译：然后，通过 <code>Class</code> 对象进行反编译，从而获取对象的各种信息。</li>\n</ul>\n<p>反射机制的优点是在运行时获得类的各种内容，进行反编译，对于 Java 这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。</p>\n",
            "tags": [
                "Interview"
            ]
        },
        {
            "id": "https://asanosaki.github.io/posts/48028.html",
            "url": "https://asanosaki.github.io/posts/48028.html",
            "title": "MySQL面试题总结",
            "date_published": "2022-12-04T09:13:00.000Z",
            "content_html": "<blockquote>\n<p>MySQL 常见面试题总结，文章将不断更新。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"1-基础\">1. 基础</h2>\n<h3 id=\"1-1-数据库的三范式是什么？\">1.1 数据库的三范式是什么？</h3>\n<ul>\n<li>第一范式（1NF）：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li>\n<li>第二范式（2NF）：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li>\n<li>第三范式（3NF）：任何非主属性不依赖于其它非主属性。</li>\n</ul>\n<h3 id=\"1-2-MySQL支持哪些存储引擎？\">1.2 MySQL支持哪些存储引擎？</h3>\n<p>MySQL 支持多种存储引擎，比如 InnoDB、MyISAM、Memory、Archive 等等。在大多数的情况下，直接选择使用 InnoDB 引擎都是最合适的，InnoDB 也是 MySQL 的默认存储引擎。</p>\n<p>MyISAM 和 InnoDB 的区别有哪些：</p>\n<ul>\n<li>InnoDB 支持<strong>事务</strong>，MyISAM 不支持。</li>\n<li>InnoDB 支持<strong>外键</strong>，MyISAM 不支持。</li>\n<li>InnoDB 是<strong>聚集索引</strong>，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高；MyISAM 是<strong>非聚集索引</strong>，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。</li>\n<li>InnoDB 不支持<strong>全文索引</strong>，MyISAM 支持全文索引，查询效率上 MyISAM 更高。</li>\n<li>InnoDB 不保存表的具体行数，MyISAM 用一个变量保存了整个表的行数。</li>\n<li>MyISAM 采用<strong>表级锁</strong>（table-level locking）；InnoDB 支持<strong>行级锁</strong>（row-level locking）和表级锁，默认为行级锁。</li>\n</ul>\n<h3 id=\"1-3-超键、候选键、主键、外键分别是什么？\">1.3 超键、候选键、主键、外键分别是什么？</h3>\n<ul>\n<li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。<strong>超键包含候选键和主键</strong>。</li>\n<li>候选键：是<strong>最小超键</strong>，即没有冗余元素的超键。</li>\n<li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（NULL）。</li>\n<li>外键：在一个表中存在的另一个表的主键称此表的外键。</li>\n</ul>\n<h3 id=\"1-4-SQL约束有哪几种？\">1.4 SQL约束有哪几种？</h3>\n<ul>\n<li><code>NOT NULL</code>：用于控制字段的内容一定不能为空（NULL）。</li>\n<li><code>UNIQUE</code>：控制字段内容不能重复，一个表允许有多个 <code>UNIQUE</code> 约束。</li>\n<li><code>PRIMARY KEY</code>：也是用于控制字段内容不能重复，但它在一个表只允许出现一个。</li>\n<li><code>FOREIGN KEY</code>：用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li>\n<li><code>CHECK</code>：用于控制字段的值范围。</li>\n</ul>\n<h3 id=\"1-5-MySQL中的varchar和char有什么区别？\">1.5 MySQL中的varchar和char有什么区别？</h3>\n<p><code>char</code> 是一个<strong>定长</strong>字段，假如申请了 <code>char(10)</code> 的空间，那么无论实际存储多少内容，该字段都占用10个字符；而 <code>varchar</code> 是<strong>变长</strong>的，也就是说申请的只是<strong>最大长度</strong>，占用的空间为实际字符长度 + 1，最后一个字符存储使用了多长的空间。</p>\n<p>在检索效率上来讲，<code>char &gt; varchar</code>，因此在使用中，如果确定某个字段的值的长度，可以使用 <code>char</code>，否则应该尽量使用 <code>varchar</code>，例如存储用户 MD5 加密后的密码，则可以使用 <code>char</code>。</p>\n<h3 id=\"1-6-MySQL中in和exists区别？\">1.6 MySQL中in和exists区别？</h3>\n<p>MySQL 中的 <code>in</code> 语句是把外表和内表作 Hash 连接，而 <code>exists</code> 语句是对外表作 Loop 循环，每次 Loop 循环再对内表进行查询。一直大家都认为 <code>exists</code> 比 <code>in</code> 语句的效率要高，这种说法其实是不准确的。这个是要区分环境的：</p>\n<ul>\n<li>如果查询的两个表大小相当，那么用 <code>in</code> 和 <code>exists</code> 差别不大。</li>\n<li>如果两个表中一个较小，一个是大表，则子查询表大的用 <code>exists</code>，子查询表小的用 <code>in</code>。</li>\n<li><code>not in</code> 和 <code>not exists</code>：如果查询语句使用了 <code>not in</code>，那么内外表都进行全表扫描，没有用到索引；而 <code>not extsts</code> 的子查询依然能用到表上的索引。所以无论哪个表大，用 <code>not exists</code> 都比 <code>not in</code> 要快。</li>\n</ul>\n<h3 id=\"1-7-drop、delete与truncate的区别？\">1.7 drop、delete与truncate的区别？</h3>\n<p>三者都表示删除，但是三者有一些差别：</p>\n<table>\n    <thead>\n        <tr>\n            <th></th>\n            <th>delete</th>\n            <th>truncate</th>\n            <th>drop</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>类型</td>\n            <td>属于 DML</td>\n            <td>属于 DDL</td>\n            <td>属于 DDL</td>\n        </tr>\n        <tr>\n            <td>回滚</td>\n            <td>可回滚</td>\n            <td>不可回滚</td>\n            <td>不可回滚</td>\n        </tr>\n        <tr>\n            <td>删除内容</td>\n            <td>表结构还在，删除表的全部或者一部分数据</td>\n            <td>表结构还在，删除表中的所有数据</td>\n            <td>从数据库中删除表，所有的数据行、索引和权限也会被删除</td>\n        </tr>\n        <tr>\n            <td>删除速度</td>\n            <td>删除速度慢，需要逐行删除</td>\n            <td>删除速度快</td>\n            <td>删除速度最快</td>\n        </tr>\n    </tbody>\n</table>\n<h3 id=\"1-8-什么是存储过程？有哪些优缺点？\">1.8 什么是存储过程？有哪些优缺点？</h3>\n<p>存储过程是一些预编译的 SQL 语句。</p>\n<ol>\n<li>更加直白的理解：存储过程可以说是一个记录集，它是由一些 T-SQL 语句组成的代码块，这些 T-SQL 语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用它就行了。</li>\n<li>存储过程是一个预编译的代码块，执行效率比较高，一个存储过程替代大量 T-SQL 语句，可以降低网络通信量，提高通信速率，可以一定程度上确保数据安全。</li>\n</ol>\n<p>但是，在互联网项目中，其实是不太推荐存储过程的，比较出名的就是阿里的《Java 开发手册》中禁止使用存储过程，我个人的理解是，在互联网项目中，迭代太快，项目的生命周期也比较短，人员流动相比于传统的项目也更加频繁，在这样的情况下，存储过程的管理确实是没有那么方便，同时，复用性也没有写在服务层那么好。</p>\n<h3 id=\"1-9-MySQL执行查询的过程？\">1.9 MySQL执行查询的过程？</h3>\n<ol>\n<li>客户端通过 TCP 连接发送连接请求到 MySQL 连接器，连接器会对该请求进行权限验证及连接资源分配。</li>\n<li>查缓存（当判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用 SQL 语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中）。</li>\n<li>语法分析（SQL 语法是否写错了）：如何把语句给到预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义。</li>\n<li>优化：是否使用索引，生成执行计划。</li>\n<li>交给执行器，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。</li>\n</ol>\n<p>更新语句执行会复杂一点，需要检查表是否有排它锁，写 <code>binlog</code>、刷盘、是否执行 <code>commit</code>。</p>\n<h2 id=\"2-事务\">2. 事务</h2>\n<h3 id=\"2-1-什么是数据库事务？\">2.1 什么是数据库事务？</h3>\n<p>事务是一个<strong>不可分割</strong>的数据库操作序列，也是数据库<strong>并发控制的基本单位</strong>，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>\n<p>事务最经典也经常被拿出来说例子就是转账了。</p>\n<p>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>\n<h3 id=\"2-2-事务具有的四个特征？\">2.2 事务具有的四个特征？</h3>\n<p>事务就是一组<strong>原子性</strong>的操作，这些操作要么全部发生，要么全部不发生。事务把数据库从一种一致性状态转换成另一种一致性状态。</p>\n<ul>\n<li>原子性（Atomicity）：事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。</li>\n<li>一致性（Consistency）：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。</li>\n<li>隔离性（Isolation）：一个事务的执行不能被其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>\n<li>持续性（Durability）：也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</li>\n</ul>\n<h3 id=\"2-3-MySQL的四种隔离级别？\">2.3 MySQL的四种隔离级别？</h3>\n<ul>\n<li>Read Uncommitted（读取未提交内容）<br>\n在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为<strong>脏读</strong>（Dirty Read）。</li>\n<li>Read Committed（读取提交内容）<br>\n这是大多数数据库系统的默认隔离级别（但不是 MySQL 默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交的事务所做的改变。这种隔离级别也支持所谓的<strong>不可重复读</strong>（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的 <code>commit</code>，所以同一 <code>select</code> 可能返回不同结果。</li>\n<li>Repeatable Read（可重读）<br>\n这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：<strong>幻读</strong>（Phantom Read）。</li>\n<li>Serializable（可串行化）<br>\n通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</li>\n</ul>\n<table>\n    <thead>\n        <tr>\n            <th>隔离级别</th>\n            <th>脏读</th>\n            <th>不可重复读</th>\n            <th>幻影读</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>Read Uncommitted</td>\n            <td>有</td>\n            <td>有</td>\n            <td>有</td>\n        </tr>\n        <tr>\n            <td>Read Committed</td>\n            <td>无</td>\n            <td>有</td>\n            <td>有</td>\n        </tr>\n        <tr>\n            <td>Repeatable Read</td>\n            <td>无</td>\n            <td>无</td>\n            <td>有</td>\n        </tr>\n        <tr>\n            <td>Serializable</td>\n            <td>无</td>\n            <td>无</td>\n            <td>无</td>\n        </tr>\n    </tbody>\n</table>\n<p>MySQL 默认采用的是 <code>REPEATABLE-READ</code> 隔离级别，Oracle 默认采用的是 <code>READ-COMMITTED</code> 隔离级别。</p>\n<p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是 MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p>\n<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <code>READ-COMMITTED</code>（读取提交内容），但是你要知道的是 InnoDB 存储引擎默认使用 <code>REPEATABLE-READ</code>（可重读）并不会有任何性能损失。</p>\n<p>InnoDB 存储引擎在分布式事务的情况下一般会用到 <code>SERIALIZABLE</code>（可串行化）隔离级别。</p>\n<h3 id=\"2-4-什么是脏读、不可重复读与幻读？\">2.4 什么是脏读、不可重复读与幻读？</h3>\n<ul>\n<li>脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。</li>\n<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。</li>\n<li>幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>\n</ul>\n<p>总结：不可重复读侧重于修改，幻读侧重于新增或删除（多了或少了行），脏读是一个事务回滚影响另外一个事务。</p>\n<h3 id=\"2-5-事务的实现原理？\">2.5 事务的实现原理？</h3>\n<p>事务是基于重做日志文件（redo log）和回滚日志（undo log）实现的。</p>\n<p>每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。</p>\n<p>每当有修改事务时，还会产生 undo log，如果需要回滚，则根据 undo log 的反向语句进行逻辑操作，比如 <code>insert</code> 一条记录就 <code>delete</code> 一条记录。undo log 主要实现数据库的一致性。</p>\n<h3 id=\"2-6-介绍一下MySQL事务日志？\">2.6 介绍一下MySQL事务日志？</h3>\n<p>InnoDB 事务日志包括 redo log 和 undo log。</p>\n<p>undo log 指事务开始之前，在操作任何数据之前，首先将需操作的数据备份到一个地方。redo log 指事务中操作的任何数据，将最新的数据备份到一个地方。</p>\n<p>事务日志的目的：实例或者介质失败，事务日志文件就能派上用场。</p>\n<ul>\n<li>redu log<br>\nredo log 不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入 redo log 中。具体的落盘策略可以进行配置。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。redo log 是为了实现事务的持久性而出现的产物。</li>\n<li>undo log<br>\nundo log 用来回滚行记录到某个版本。事务未提交之前，undo log 保存了未提交之前的版本数据，undo log 中的数据可作为数据旧版本快照供其他并发事务进行快照读。是为了实现事务的原子性而出现的产物，在 MySQL InnoDB 存储引擎中用来实现多版本并发控制。</li>\n</ul>\n<h3 id=\"2-7-什么是MySQL的binlog？\">2.7 什么是MySQL的binlog？</h3>\n<p>MySQL 的 binlog 是记录所有数据库<strong>表结构变更</strong>（例如 <code>CREATE</code>、<code>ALTER TABLE</code>）以及<strong>表数据修改</strong>（例如 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）的二进制日志。binlog 不会记录 <code>SELECT</code> 和 <code>SHOW</code> 这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看 MySQL 执行过的所有语句。</p>\n<p>MySQL binlog 以事件形式记录，还包含语句执行所消耗的时间，MySQL 的二进制日志是事务安全型的。binlog 的主要目的是复制和恢复。</p>\n<p>binlog 有三种格式，各有优缺点：</p>\n<ul>\n<li><code>statement</code>：基于 SQL 语句的模式，某些语句和函数如 <code>UUID</code>、<code>LOAD DATA INFILE</code> 等在复制过程中可能导致数据不一致甚至出错。</li>\n<li><code>row</code>：基于行的模式，记录的是行的变化，很安全。但是 binlog 会比其他两种模式大很多，在一些大表中清除大量数据时在 binlog 中会生成很多条语句，可能导致从库延迟变大。</li>\n<li><code>mixed</code>：混合模式，根据语句来选用是 <code>statement</code> 还是 <code>row</code> 模式。</li>\n</ul>\n<h3 id=\"2-8-在事务中可以混合使用存储引擎吗？\">2.8 在事务中可以混合使用存储引擎吗？</h3>\n<p>尽量不要在同一个事务中使用多种存储引擎，MySQL 服务器层不管理事务，事务是由下层的存储引擎实现的。</p>\n<p>如果在事务中混合使用了事务型和非事务型的表（例如 InnoDB 和 MyISAM 表），在正常提交的情况下不会有什么问题。</p>\n<p>但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。所以，为每张表选择合适的存储引擎非常重要。</p>\n<h3 id=\"2-9-什么是MVCC？\">2.9 什么是MVCC？</h3>\n<p>MVCC，即多版木并发控制。MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p>\n<h3 id=\"2-10-MVCC的实现\">2.10 MVCC的实现</h3>\n<p>对于 InnoDB，聚簇索引记录中包含3个隐藏的列：</p>\n<ul>\n<li>ROW ID：隐藏的自增 ID，如果表没有主键，InnoDB 会自动按 ROW ID 产生一个聚集索引树。</li>\n<li>事务 ID：记录最后一次修改该记录的事务 ID。</li>\n<li>回滚指针：指向这条记录的上一个版本。</li>\n</ul>\n<p>我们举个例子，假如现在有两个事务：</p>\n<ul>\n<li>事务1：<code>insert into t1(a, b) values (1, 1);</code></li>\n<li>事务2：<code>update t1 set b = 666 where a = 1;</code></li>\n</ul>\n<p>如图，首先 <code>insert</code> 语句向表 <code>t1</code> 中插入了一条数据，<code>a</code> 字段为1，<code>b</code> 字段为1，ROW ID 也为1，事务 ID 假设为1，回滚指针假设为 <code>null</code>。当执行 <code>update t1 set b = 666 where a = 1</code> 时，大致步骤如下：</p>\n<ul>\n<li>数据库会先对满足 <code>a = 1</code> 的行加排他锁；</li>\n<li>然后将原记录复制到 undo 表空间中；</li>\n<li>修改 <code>b</code> 字段的值为666，修改事务 ID 为2；</li>\n<li>并通过隐藏的回滚指针指向 undo log 中的历史记录；</li>\n<li>事务提交，释放前面对满足 <code>a = 1</code> 的行所加的排他锁。</li>\n</ul>\n<p>因此可以总结出 MVCC 实现的原理大致是：</p>\n<p>InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。</p>\n<p>MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。通过 MVCC，保证了事务 ACID 中的隔离性。</p>\n<h2 id=\"3-锁\">3. 锁</h2>\n<h3 id=\"3-1-为什么要加锁？\">3.1 为什么要加锁？</h3>\n<p>当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能读取和存储不正确的数据，破坏数据库的一致性。因此需要加锁使得在多用户环境下保证数据库的完整性和一致性。</p>\n<h3 id=\"3-2-按照锁的粒度分数据库锁有哪些？\">3.2 按照锁的粒度分数据库锁有哪些？</h3>\n<p>在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁（InnoDB 引擎）、表级锁(MyISAM 引擎）和页级锁（BDB引擎）。</p>\n<ul>\n<li>行级锁\n<ul>\n<li>行级锁是 MySQL 中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。</li>\n<li>开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>\n</ul>\n</li>\n<li>表级锁\n<ul>\n<li>表级锁是 MySQL 中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MyISAM 与 InnoDB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</li>\n<li>开销小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>\n</ul>\n</li>\n<li>页级锁\n<ul>\n<li>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁之间的一种锁。表级锁速度快，但冲突多，行级锁冲突少，但速度慢。所以取了折衷的页级锁，一次锁定相邻的一组记录。BDB 支持页级锁。</li>\n<li>开销和加锁时间界于表锁和行锁之间，会出现死锁，锁定粒度界于表锁和行锁之间，并发度一般。</li>\n</ul>\n</li>\n</ul>\n<p>MyISAM 和 InnoDB 存储引擎使用的锁：</p>\n<ul>\n<li>MyISAM 采用表级锁（table-level locking）。</li>\n<li>InnoDB 支持行级锁（row-level locking）和表级锁，默认为行级锁。</li>\n</ul>\n<h3 id=\"3-3-从锁的类别上分MySQL都有哪些锁呢？\">3.3 从锁的类别上分MySQL都有哪些锁呢？</h3>\n<p>从锁的类别上来讲，有共享锁和排他锁。</p>\n<ul>\n<li>共享锁：又叫做读锁，当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</li>\n<li>排他锁：又叫做写锁，当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，它和其它的排他锁，共享锁都相斥。</li>\n</ul>\n<p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p>\n<p>锁的粒度取决于具体的存储引擎，InnoDB 实现了行级锁，页级锁，表级锁。他们的加锁开销从大到小，并发能力也是从大到小。</p>\n<h3 id=\"3-4-数据库的乐观锁和悲观锁是什么？怎么实现的？\">3.4 数据库的乐观锁和悲观锁是什么？怎么实现的？</h3>\n<p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>\n<ul>\n<li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制。</li>\n<li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过 version 的方式来进行锁定。实现方式：乐观锁一般会使用版本号机制或 CAS 算法实现。</li>\n</ul>\n<p>两种锁的使用场景：</p>\n<p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p>\n<p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行 <code>retry</code>，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p>\n<h3 id=\"3-5-InnoDB引擎的行锁是怎么实现的？\">3.5 InnoDB引擎的行锁是怎么实现的？</h3>\n<p>InnoDB 是基于索引来完成行锁的。</p>\n<p>例如：<code>select * from tab_with_index where id = 1 for update;</code></p>\n<p><code>for update</code> 可以根据条件来完成行锁锁定，并且 <code>id</code> 是有索引键的列，如果 <code>id</code> 不是索引键那么 InnoDB 将完成表锁，并发将无从谈起。</p>\n<h3 id=\"3-6-什么是死锁？怎么解决？\">3.6 什么是死锁？怎么解决？</h3>\n<p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。常见的解决死锁的方法有：</p>\n<ul>\n<li>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li>\n<li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率。</li>\n<li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。</li>\n</ul>\n<p>如果业务处理不好可以用分布式事务锁或者使用乐观锁。</p>\n<h3 id=\"3-7-隔离级别与锁的关系？\">3.7 隔离级别与锁的关系？</h3>\n<ul>\n<li>在 Read Uncommitted 级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突。</li>\n<li>在 Read Committed 级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁。</li>\n<li>在 Repeatable Read 级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</li>\n<li>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</li>\n</ul>\n<h3 id=\"3-8-优化锁方面的意见？\">3.8 优化锁方面的意见？</h3>\n<ul>\n<li>使用较低的隔离级别。</li>\n<li>设计索引，尽量使用索引去访问数据，加锁更加精确，从而减少锁冲突。</li>\n<li>选择合理的事务大小，给记录显示加锁时，最好一次性请求足够级别的锁。例如，修改数据的话最好申请排他锁，而不是先申请共享锁，修改时再申请排他锁，这样会导致死锁。</li>\n<li>不同的程序访问一组表的时候，应尽量约定一个相同的顺序访问各表，对于一个表而言，尽可能固定顺序地获取表中的行，这样将大大减少死锁的机会。</li>\n<li>尽量使用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。</li>\n<li>不要申请超过实际需要的锁级别。</li>\n<li>数据查询的时候不是必要，不要使用加锁。MySQL 的 MVCC 可以实现事务中的查询不用加锁，优化事务性能：MVCC 只在 Read Committed（读提交）和 Repeatable Read（可重复读）两种隔离级别。</li>\n<li>对于特定的事务，可以使用表锁来提高处理速度或者减少死锁的可能。</li>\n</ul>\n<h2 id=\"4-索引\">4. 索引</h2>\n<h3 id=\"4-1-索引是什么？\">4.1 索引是什么？</h3>\n<p>索引是一种特殊的文件（InnoDB 数据表上的索引是表空间的一个组成部分），它们包含着对数据表里所有记录的引用指针。</p>\n<p>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用 B 树及其变种 B+ 树。更通俗地说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。而且索引是一个文件，它是要占据物理空间的。</p>\n<p>MySQL 索引的建立对于 MySQL 的高效运行是很重要的，索引可以大大提高 MySQL 的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，打开字典的页数就可以知道我们要搜索的某一个 key 的全部值的信息了。</p>\n<h3 id=\"4-2-索引有哪些优缺点？\">4.2 索引有哪些优缺点？</h3>\n<p>索引的优点：</p>\n<ul>\n<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>\n<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>\n</ul>\n<p>索引的缺点：</p>\n<ul>\n<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增删改的执行效率。</li>\n<li>空间方面：索引需要占用物理空间。</li>\n</ul>\n<h3 id=\"4-3-MySQL有哪几种索引类型？\">4.3 MySQL有哪几种索引类型？</h3>\n<ul>\n<li>从存储结构上来划分：BTree 索引（B-Tree 或 B+Tree 索引）、Hash 索引、full-index 全文索引、R-Tree 索引。这里所描述的是索引存储时保存的形式。</li>\n<li>从应用层次来分：普通索引、唯一索引、复合索引。\n<ul>\n<li>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引。</li>\n<li>唯一索引：索引列的值必须唯一，但允许有空值。</li>\n<li>复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li>\n<li>聚簇索引（聚集索引）：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB 的聚簇索引其实就是在同一个结构中保存了 B-Tree 索引（技术上来说是 B+Tree）和数据行。</li>\n<li>非聚簇索引：不是聚簇索引，就是非聚簇索引。</li>\n</ul>\n</li>\n<li>根据表中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引。</li>\n</ul>\n<h3 id=\"4-4-说一说索引的底层实现？\">4.4 说一说索引的底层实现？</h3>\n<ul>\n<li>Hash 索引：基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且 Hash 索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。</li>\n<li>B-Tree 索引（MySQL 使用 B+Tree）：B-Tree 能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。</li>\n<li>B+Tree 索引：B-Tree 的改进版本，同时也是数据库索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比 B-Tree 来说，进行范围查找时只需要查找两个节点，进行遍历即可。而 B-Tree 需要获取所有节点，相比之下 B+Tree 效率更高。<br>\nB+Tree 性质：\n<ul>\n<li><code>n</code> 棵子树的节点包含 <code>n</code> 个关键字，不用来保存数据而是保存数据的索引。</li>\n<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身根据关键字的大小自小而大顺序链接。</li>\n<li>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li>\n<li>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</li>\n<li>B+ 树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-5-为什么索引结构默认使用B-Tree，而不是B-Tree，Hash，二叉树，红黑树？\">4.5 为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？</h3>\n<ul>\n<li>B-tree：从两个方面来回答：\n<ul>\n<li>B+ 树的磁盘读写代价更低：B+ 树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对 B 树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对 IO 读写次数就降低了。</li>\n<li>由于 B+ 树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是 B 树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以 B+ 树更加适合区间查询的情况，所以通常 B+ 树用于数据库索引。</li>\n</ul>\n</li>\n<li>Hash：\n<ul>\n<li>虽然可以快速定位，但是没有顺序，IO 复杂度高；</li>\n<li>基于 Hash 表实现，只有 Memory 存储引擎显式支持哈希索引；</li>\n<li>适合<strong>等值查询</strong>，如 <code>=</code>、<code>in()</code>、<code>&lt;=&gt;</code>，不支持范围查询；</li>\n<li>因为不是按照索引值顺序存储的，就不能像 B+Tree 索引一样利用索引完成排序；</li>\n<li>Hash 索引在查询等值时非常快；</li>\n<li>因为 Hash 索引始终索引<strong>所有列的全部内容</strong>，所以不支持部分索引列的匹配查找；</li>\n<li>如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在<strong>哈希碰撞</strong>问题。</li>\n</ul>\n</li>\n<li>二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且 IO 代价高。</li>\n<li>红黑树：树的高度随着数据量增加而增加，IO 代价高。</li>\n</ul>\n<h3 id=\"4-6-讲一讲聚簇索引与非聚簇索引？\">4.6 讲一讲聚簇索引与非聚簇索引？</h3>\n<p>在 InnoDB 里，索引 B+Tree 的叶子节点存储了整行数据为主键索引，也被称之为聚簇索引，即将数据存储与索引放到了一块，找到索引也就找到了数据。</p>\n<p>而索引 B+Tree 的叶子节点存储了主键的值为非主键索引，也被称之为非聚簇索引、二级索引。</p>\n<p>聚簇索引与非聚簇索引的区别：</p>\n<ul>\n<li>非聚簇索引与聚簇索引的区别在于非聚簇索引的叶子节点不存储表中的数据，而是存储该列对应的主键（行号）。</li>\n<li>对于 InnoDB 来说，想要查找数据我们还需要根据主键再去聚簇索引中进行查找，这个再根据聚簇索引查找数据的过程，我们称为<strong>回表</strong>。第一次索引一般是顺序 IO，回表的操作属于随机 IO。需要回表的次数越多，即随机 IO 次数越多，我们就越倾向于使用全表扫描。</li>\n<li>通常情况下，主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。当然，如果是覆盖索引的话，查一次即可。</li>\n</ul>\n<p>注意：MyISAM 无论主键索引还是二级索引都是非聚簇索引，而 InnoDB 的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建立的索引基本都是非聚簇索引。</p>\n<h3 id=\"4-7-非聚簇索引一定会回表查询吗？\">4.7 非聚簇索引一定会回表查询吗？</h3>\n<p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为“覆盖索引”。举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行 <code>select score from stuaent where score &gt; 90</code> 的查询时，在索引的叶子节点上，已经包含了 <code>score</code> 信息，不会再次进行回表查询。</p>\n<h3 id=\"4-8-联合索引是什么？为什么需要注意联合索引中的顺序？\">4.8 联合索引是什么？为什么需要注意联合索引中的顺序？</h3>\n<p>MySQL 可以<strong>使用多个字段同时建立一个索引</strong>，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。具体原因为：</p>\n<ul>\n<li>MySQL 使用索引时需要索引有序，假设现在建立了 <code>name, age, school</code> 的联合索引，那么索引的排序为：先按照 <code>name</code> 排序，如果 <code>name</code> 相同，则按照 <code>age</code> 排序，如果 <code>age</code> 的值也相等，则按照 <code>school</code> 进行排序。</li>\n<li>当进行查询时，此时索引仅仅按照 <code>name</code> 严格有序，因此必须首先使用 <code>name</code> 字段进行<strong>等值查询</strong>，之后对于匹配到的列而言，其按照 <code>age</code> 字段严格有序，此时可以使用 <code>age</code> 字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</li>\n</ul>\n<h3 id=\"4-9-MySQL的最左前缀原则是什么？\">4.9 MySQL的最左前缀原则是什么？</h3>\n<p>最左前缀原则就是<strong>最左优先</strong>，在创建多列索引时，要根据业务需求，<code>where</code> 子句中使用<strong>最频繁</strong>的一列放在最左边。MySQL 会一直向右匹配直到遇到<strong>范围查询</strong>（<code>&gt;</code>、<code>&lt;</code>、<code>between</code>、<code>like</code>）就停止匹配，比如：对于 <code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，如果建立 <code>(a, b, c)</code> 顺序的索引，<code>d</code> 是用不到索引的，如果建立 <code>(a, b, d, c)</code> 的索引则都可以用到，<code>a, b, d</code> 的顺序可以任意调整。<code>=</code> 和 <code>in</code> 可以<strong>乱序</strong>，比如 <code>a = 1 and b = 2 and c = 3</code> 建立 <code>(a, b, c)</code> 索引可以任意顺序，MySQL 的查询优化器会帮你优化成索引可以识别的形式。</p>\n<h3 id=\"4-10-前缀索引是什么？\">4.10 前缀索引是什么？</h3>\n<p>因为可能我们索引的字段非常长，这既占内存空间，也不利于维护。所以我们就想，如果只把很长字段的前面的公共部分作为一个索引，就会产生超级加倍的效果。但是，我们需要注意，<code>order by</code> 不支持前缀索引。</p>\n<p>创建前缀索引的流程如下：</p>\n<ul>\n<li>先计算完整列的选择性：<code>select count(distinct col_1)/count(1) from table_1</code>；</li>\n<li>再计算不同前缀长度的选择性：<code>select count(distinct left(col_1, 4))/count(1) from table_1</code>；</li>\n<li>找到最优长度之后，创建前缀索引：<code>create index idx_front on table_1 (col_1(4))</code>。</li>\n</ul>\n<h3 id=\"4-11-如何创建索引？\">4.11 如何创建索引？</h3>\n<p>创建索引有以下三种方式：</p>\n<p>（1）在执行 <code>CREATE TABLE</code> 时创建索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> table_name (</span><br><span class=\"line\">    id <span class=\"type\">INT</span> auto_increment <span class=\"keyword\">PRIMARY</span> KEY,</span><br><span class=\"line\">    first_name <span class=\"type\">VARCHAR</span> (<span class=\"number\">16</span>),</span><br><span class=\"line\">    last_name <span class=\"type\">VARCHAR</span> (<span class=\"number\">16</span>),</span><br><span class=\"line\">    id_card <span class=\"type\">VARCHAR</span> (<span class=\"number\">18</span>),</span><br><span class=\"line\">    information text,</span><br><span class=\"line\">    KEY name (first_name, last_name),</span><br><span class=\"line\">    FULLTEXT KEY (information) ,  <span class=\"comment\">-- 在information字段上建立全文索引</span></span><br><span class=\"line\">    <span class=\"keyword\">UNIQUE</span> KEY (id_card)  <span class=\"comment\">-- 在id_card字段上建立唯一索引</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>（2）使用 <code>ALTER TABLE</code> 命令添加索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> table_name <span class=\"keyword\">ADD</span> INDEX index_name (column_list);</span><br></pre></td></tr></table></figure>\n<p><code>ALTER TABLE</code> 用来创建普通索引、<code>UNIQUE</code> 索引或 <code>PRIMARY KEY</code> 索引。</p>\n<p>其中 <code>table_name</code> 是要增加索引的表名，<code>column_list</code> 指出对哪些列进行索引，如果索引多列则各列之间用逗号分隔。</p>\n<p>索引名 <code>index_name</code> 可自己命名，缺省时，MySQL 将根据第一个索引列赋一个名称。另外，<code>ALTER TABLE</code> 允许在单个语句中更改多个表，因此可以同时创建多个索引。</p>\n<p>（3）使用 <code>CREATE INDEX</code> 命令创建索引：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX index_name <span class=\"keyword\">ON</span> table_name (column_list);</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-12-创建索引时需要注意什么？\">4.12 创建索引时需要注意什么？</h3>\n<ul>\n<li>非空字段：应该指定列为 <code>NOT NULL</code>，除非你想存储 <code>NULL</code>。在 MySQL 中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0或者一个特殊的值或者一个空串代替空值；</li>\n<li>取值离散（变量各个取值之间的差异程度）大的字段的列放到联合索引的前面，可以通过 <code>count()</code> 函数查看字段的差异值，返回值越大说明字段的唯一值越多，字段的离散程度高；</li>\n<li>索引字段越小越好：数据库的数据存储以页为单位，一页存储的数据越多则一次 I/O 操作获取的数据越多，效率越高。</li>\n</ul>\n",
            "tags": [
                "Interview"
            ]
        },
        {
            "id": "https://asanosaki.github.io/posts/54431.html",
            "url": "https://asanosaki.github.io/posts/54431.html",
            "title": "计算机网络面试题总结",
            "date_published": "2022-11-24T03:14:00.000Z",
            "content_html": "<blockquote>\n<p>计算机网络常见面试题总结，文章将不断更新。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"1-概述\">1. 概述</h2>\n<h3 id=\"1-1-计算机网络的各层协议及作用？\">1.1 计算机网络的各层协议及作用？</h3>\n<p>计算机网络体系可以大致分为三种：OSI 七层模型、TCP/IP 四层模型和五层模型。</p>\n<ul>\n<li>OSI 七层模型：大而全，但是比较复杂、而且是先有了理论模型，没有实际应用。</li>\n<li>TCP/IP 四层模型：是由实际应用发展总结出来的，从实质上讲，TCP/IP 只有最上面两层，最下面一层没有什么具体内容，TCP/IP 参考模型没有真正描述这一层的实现。</li>\n<li>TCP/IP 五层模型：五层模型只出现在计算机网络教学过程中，这是对七层模型和四层模型的一个折中，既简洁又能将概念阐述清楚。</li>\n</ul>\n<p>七层网络体系结构各层的主要功能：</p>\n<ul>\n<li>应用层：为应用程序提供交互服务。在互联网中的应用层协议有很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等。</li>\n<li>表示层：主要负责数据格式的转换，如加密解密、转换翻译、压缩解压缩等。</li>\n<li>会话层：负责在网络中的两节点之间建立、维持和终止通信，如服务器验证用户登录便是由会话层完成的。</li>\n<li>运输层：有时也译为传输层，向主机进程提供通用的数据传输服务。该层主要有以下两种协议：\n<ul>\n<li>TCP：提供面向连接的、可靠的数据传输服务。</li>\n<li>UDP：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。</li>\n</ul>\n</li>\n<li>网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括 IP 协议。</li>\n<li>数据链路层：数据链路层通常简称为链路层。将网络层传下来的 IP 数据包组装成帧，并在相邻节点的链路上传送帧。</li>\n<li>物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异。</li>\n</ul>\n<h2 id=\"2-TCP-IP\">2. TCP/IP</h2>\n<h3 id=\"2-1-TCP和UDP的区别？\">2.1 TCP和UDP的区别？</h3>\n<table>\n    <thead>\n        <tr>\n            <th></th>\n            <th>TCP</th>\n            <th>UDP</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>是否连接</td>\n            <td>面向连接</td>\n            <td>无连接</td>\n        </tr>\n        <tr>\n            <td>是否可靠</td>\n            <td>可靠传输，使用流量控制和拥塞控制</td>\n            <td>不可靠传输，不使用流量控制和拥塞控制</td>\n        </tr>\n        <tr>\n            <td>是否有序</td>\n            <td>有序，消息在传输过程中可能会乱序，TCP 会重新排序</td>\n            <td>无序</td>\n        </tr>\n        <tr>\n            <td>传输速度</td>\n            <td>慢</td>\n            <td>快</td>\n        </tr>\n        <tr>\n            <td>连接对象个数</td>\n            <td>只能一对一通信</td>\n            <td>支持一对一、一对多、多对一和多对多交互通信</td>\n        </tr>\n        <tr>\n            <td>传输方式</td>\n            <td>面向字节流</td>\n            <td>面向报文</td>\n        </tr>\n        <tr>\n            <td>首部开销</td>\n            <td>首部开销大，最小20字节，最大60字节</td>\n            <td>首部开销小，仅8字节</td>\n        </tr>\n        <tr>\n            <td>适用场景</td>\n            <td>适用于要求可靠传输的应用，例如文件传输</td>\n            <td>适用于实时应用例如 IP 电话、视频会议、直播等</td>\n        </tr>\n    </tbody>\n</table>\n<p>总结：TCP 用于在传输层有必要实现可靠传输的情况，UDP 用于对高速传输和实时性有较高要求的通信。TCP 和 UDP 应该根据应用目的按需使用。</p>\n<h3 id=\"2-2-TCP和UDP对应的应用场景是什么？\">2.2 TCP和UDP对应的应用场景是什么？</h3>\n<ul>\n<li>TCP 是面向连接的，能保证数据的可靠性交付，因此经常用于：\n<ul>\n<li>FTP 文件传输。</li>\n<li>HTTP/HTTPS。</li>\n<li>SMTP 简单邮件传输。</li>\n</ul>\n</li>\n<li>UDP 是无连接的，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：\n<ul>\n<li>包总量较少的通信，如 DNS、SNMP 等。</li>\n<li>视频、音频等多媒体通信。</li>\n<li>广播通信。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-3-TCP的三次握手机制？\">2.3 TCP的三次握手机制？</h3>\n<ul>\n<li>第一次握手：客户端请求建立连接，向服务端发送一个同步报文（<code>SYN = 1</code>），同时选择一个随机数 <code>seq = x</code> 作为初始序列号，并进入 <code>SYN_SENT</code>（同步已发送）状态，等待服务器确认。</li>\n<li>第二次握手：服务端收到连接请求报文后，如果同意建立连接，则向客户端发送同步确认报文（<code>SYN = 1, ACK = 1</code>），确认号为 <code>ack = x + 1</code>，同时选择一个随机数 <code>seq = y</code> 作为初始序列号，此时服务器进入 <code>SYN_RECV</code>（同步收到）状态。</li>\n<li>第三次握手：客户端收到服务端的确认后，向服务端发送一个确认报文（<code>ACK = 1</code>），确认号为 <code>ack = y + 1</code>，序列号为 <code>seq = x + 1</code>，客户端和服务器进入 <code>ESTABLISHED</code>（已建立连接）状态，完成三次握手。</li>\n</ul>\n<p>理想状态下，TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>\n<h3 id=\"2-4-为什么需要三次握手，而不是两次？\">2.4 为什么需要三次握手，而不是两次？</h3>\n<p>主要有三个原因：</p>\n<ol>\n<li>防止已过期的连接请求报文突然又传送到服务器，因而产生错误和资源浪费。<br>\n在双方两次握手即可建立连接的情况下，假设客户端发送报文段A请求建立连接，由于网络原因造成A暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段。<br>\n客户端在长时间得不到应答的情况下重新发送请求报文段B，这次B顺利到达服务器，服务器随即返回确认报文并进入 <code>ESTABLISHED</code> 状态，客户端在收到确认报文后也进入 <code>ESTABLISHED</code> 状态，双方建立连接并传输数据，之后正常断开连接。<br>\n此时姗姗来迟的报文段A才到达服务器，服务器随即返回确认报文并进入 <code>ESTABLISHED</code> 状态，但是已经进入 <code>CLOSED</code> 状态的客户端无法再接受确认报文段，更无法进入 <code>ESTABLISHED</code> 状态，这将导致服务器长时间单方面等待，造成资源浪费。</li>\n<li>三次握手才能让双方均确认自己和对方的发送和接收能力都正常。<br>\n第一次握手：客户端只是发送处请求报文段，什么都无法确认，而服务器可以确认自己的接收能力和对方的发送能力正常。<br>\n第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常。<br>\n第三次握手：服务器可以确认<strong>自己发送能力</strong>和接收能力正常，<strong>对方</strong>发送能力和<strong>接收能力</strong>正常。<br>\n可见三次握手才能让双方都确认自己和对方的发送和接收能力全部正常，这样就可以愉快地进行通信了。</li>\n<li>告知对方自己的初始序号值，并确认收到对方的初始序号值。<br>\nTCP 实现了可靠的数据传输，原因之一就是 TCP 报文段中维护了序号字段和确认序号字段，通过这两个字段双方都可以知道在自己发出的数据中，哪些是已经被对方确认接收的。这两个字段的值会在初始序号值的基础上递增，如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的初始序号则得不到确认。</li>\n</ol>\n<h3 id=\"2-5-为什么需要三次握手，而不是四次？\">2.5 为什么需要三次握手，而不是四次？</h3>\n<p>因为三次握手已经可以确认双方的发送和接收能力正常，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值的确认，也就无需第四次握手了。</p>\n<ul>\n<li>第一次握手：服务端确认<strong>自己收、对方发</strong>报文功能正常。</li>\n<li>第二次握手：客户端确认<strong>自己发、自己收、对方收、对方发</strong>报文功能正常，客户端认为连接己建立。</li>\n<li>第三次握手：服务端确认<strong>自己发、对方收</strong>报文功能正常，此时双方均建立连接，可以正常通信。</li>\n</ul>\n<h3 id=\"2-6-什么是SYN洪泛攻击？如何防范？\">2.6 什么是SYN洪泛攻击？如何防范？</h3>\n<p>SYN 洪泛攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的<strong>半连接</strong>请求，耗费 CPU 和内存资源。</p>\n<p>原理：</p>\n<ul>\n<li>在三次握手过程中，服务器发送 <code>[SYN/ACK]</code> 包（即第二个包）之后、收到客户端的 <code>[ACK]</code> 包（即第三个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 <code>SYN_RECV</code>（等待客户端响应）状态。如果接收到客户端的 <code>[ACK]</code>，则 TCP 连接成功，如果未接收到，则会不断重发请求直至成功。</li>\n<li>SYN 攻击的攻击者在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 <code>[SYN]</code> 包，服务器回复 <code>[SYN/ACK]</code> 包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时。</li>\n<li>这些伪造的 <code>[SYN]</code> 包将长时间占用未连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络堵塞甚至系统瘫痪。</li>\n</ul>\n<p>检测：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。</p>\n<p>防范：</p>\n<ul>\n<li>通过防火墙、路由器等过滤网关防护。</li>\n<li>通过加固 TCP/IP 协议栈防范，如增加最大半连接数，缩短超时时间。</li>\n<li>SYN Cookies 技术。SYN Cookies 是对 TCP 服务器端的三次握手做一些修改，专门用来防范 SYN 洪泛攻击的一种手段。</li>\n</ul>\n<h3 id=\"2-7-三次握手连接阶段，如果最后一次ACK包丢失，会发生什么？\">2.7 三次握手连接阶段，如果最后一次ACK包丢失，会发生什么？</h3>\n<p>服务端：</p>\n<ul>\n<li>第三次的 <code>ACK</code> 包在网络中丢失，那么服务端该 TCP 连接的状态为 <code>SYN_RECV</code>,并且会根据 TCP 的超时重传机制，会等待3秒、6秒、12秒后重新发送 <code>SYN + ACK</code> 包，以便客户端重新发送 <code>ACK</code> 包。</li>\n<li>如果重发指定次数之后，仍然未收到客户端的 ACK 应答，那么一段时间后，服务端自动关闭这个连接。</li>\n</ul>\n<p>客户端：</p>\n<ul>\n<li>客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以 <code>RST</code> 包（Reset，表示复位，用于异常的关闭连接）响应。此时，客户端便知道第三次握手失败。</li>\n</ul>\n<h3 id=\"2-8-TCP的四次挥手过程？\">2.8 TCP的四次挥手过程？</h3>\n<ul>\n<li>第一次挥手：客户端向服务端发送连接释放报文（<code>FIN = 1, ACK = 1</code>），主动关闭连接，同时等待服务端的确认，客户端进入 <code>FIN_WAIT_1</code>（终止等待1）状态。序列号 <code>seq = u</code>，为客户端上次发送的报文的最后一个字节的序号 + 1。</li>\n<li>第二次挥手：服务端收到连接释放报文后，立即发出确认报文（<code>ACK = 1</code>），序列号 <code>seq = v</code>，为服务端上次发送的报文的最后一个字节的序号 + 1，确认号 <code>ack = u + 1</code>，服务端进入 <code>CLOSE_WAIT</code>（关闭等待）状态。<br>\n此时 TCP 连接处于<strong>半关闭</strong>状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。这表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。</li>\n<li>第三次挥手：客户端收到服务端的确认后进入 <code>FIN_WAIT_2</code>（终止等待2）状态，等待服务端发出连接释放报文段。服务端向客户端发送连接释放报文（<code>FIN = 1, ACK = 1</code>），主动关闭连接，同时等待A的确认，服务端进入 <code>LAST_ACK</code>（最后确认）状态。\n<ul>\n<li>序列号 <code>seq = w</code>，即服务端上次发送的报文的最后一个字节的序号 + 1，可能在半关闭状态服务端又发送了一些数据。</li>\n<li>确认号 <code>ack = u + 1</code>，与第二次挥手相同，因为这段时间客户端没有发送数据。</li>\n</ul>\n</li>\n<li>第四次挥手：客户端收到服务端的连接释放报文后，立即发出确认报文（<code>ACK = 1</code>），序列号 <code>seq = u + 1</code>，确认号为 <code>ack = w + 1</code>。<br>\n此时，客户端就进入了 <code>TIME_WAIT</code>（时间等待）状态。注意此时客户端到 TCP 连接还没有释放，必须经过2 * MSL（最长报文段寿命）的时间后，才进入 <code>CLOSED</code> 状态。而服务端只要收到客户端发出的确认，就立即进入 <code>CLOSED</code> 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。</li>\n</ul>\n<h3 id=\"2-9-为什么连接的时候是三次握手，关闭的时候却是四次握手？\">2.9 为什么连接的时候是三次握手，关闭的时候却是四次握手？</h3>\n<p>服务器在收到客户端的 <code>FIN</code> 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 <code>ACK</code> 报文段.</p>\n<p>接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 <code>FIN</code> 报文，表示数据已经发送完毕，请求关团连接。服务器的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而导致多了一次，因此一共需要四次挥手。</p>\n<h3 id=\"2-10-为什么客户端的TIME-WAIT状态必须等待2MSL？\">2.10 为什么客户端的TIME_WAIT状态必须等待2MSL？</h3>\n<p>主要有两个原因:</p>\n<ol>\n<li>确保最后一个 <code>ACK</code> 报文段能够到达服务端，从而使服务端正常关闭连接。<br>\n第四次挥手时，客户端第四次挥手的 <code>ACK</code> 报文段不一定会到达服务端。服务端会超时重传 <code>FIN/ACK</code> 报文段，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 <code>FIN/ACK</code> 报文段的确认，就无法正常断开连接。<br>\nMSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即：客户端 <code>ACK</code> 报文段 1MSL 超时 + 服务端 <code>FIN</code> 报文段 1MSL 传输，就能够收到服务端重传的 <code>FIN/ACK</code> 报文段，然后客户端重传一次 <code>ACK</code> 报文段，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。<br>\n如果服务端重发的 <code>FIN</code> 报文段没有成功地在 2MSL 时间里传给客户端，服务端则会继续超时重试直到断开连接。</li>\n<li>防止已失效的连接请求报文段出现在之后的连接中。<br>\nTCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 <code>ACK</code> 报文段后，再经过时间 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。</li>\n</ol>\n<h3 id=\"2-11-如果已经建立了连接，但是客户端出现故障了怎么办？\">2.11 如果已经建立了连接，但是客户端出现故障了怎么办？</h3>\n<p>通过<strong>定时器 + 超时重试机制</strong>，尝试获取确认，直到最后会自动断开连接。</p>\n<p>具体而言，TCP 设有一个<strong>保活计时器</strong>。服务器每收到一次客户端的数据，都会重新设置这个计时器，时间通常是设置为2小时。若2小时还没有收到客户端的任何数据，服务器就发送一个探测报文段，之后则每隔75秒钟发送一次，若一连发送10个探测报文段后客户端依然没有响应，那么服务器就认为客户端出现故障，接着就关闭这个连接。</p>\n<h3 id=\"2-12-TIME-WAIT是服务器端还是客户端的状态\">2.12 TIME_WAIT是服务器端还是客户端的状态?</h3>\n<p><code>TIME_WAIT</code> 是<strong>主动断开连接</strong>的一方会进入的状态，一般情况下，都是客户端所处的状态，服务器端一般设置不主动关闭连接。</p>\n<p><code>TIME_WAIT</code> 需要等待 2MSL，在大量短连接的情况下，<code>TIME_WAIT</code> 会太多，这也会消耗很多系统资源。对于服务器来说，在 HTTP 协议里指定 KeepAlive（浏览器重用一个 TCP 连接来处理多个 HTTP 请求），由浏览器来主动断开连接，可以一定程度上减少服务器的这个问题。</p>\n<h3 id=\"2-13-TCP协议如何保证可靠性，即如何实现可靠传输？\">2.13 TCP协议如何保证可靠性，即如何实现可靠传输？</h3>\n<p>TCP 主要提供了检验和、序列号/确认应答、超时重传、滑动窗口、拥塞控制和流量控制等方法实现了可靠性传输。</p>\n<ul>\n<li>检验和：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃 TCP 报文段，重新发送。</li>\n<li>序列号/确认应答：序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。<br>\nTCP 传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送 ACK 报文段，这个 ACK 报文段当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</li>\n<li>滑动窗口：滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。</li>\n<li>超时重传：超时重传的时间是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。</li>\n<li>拥塞控制：在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证 TCP 可靠性的同时，提高性能。</li>\n<li>流量控制：如果主机A一直向主机B发送数据，不考虑主机B的接收能力，则可能导致主机B的接收缓冲区满了而无法再接收数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量。流量控制与 TCP 协议报头中的窗口大小有关。</li>\n</ul>\n<h3 id=\"2-14-详细讲一下TCP的滑动窗口？\">2.14 详细讲一下TCP的滑动窗口？</h3>\n<p>在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。TCP 协议需要对数据进行确认后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。</p>\n<p>为了避免这种情况，TCP 引入了窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值。</p>\n<p>滑动窗口里面也分为有三种类型的数据，第一种是已经发送且收到确认但是未按序到达，即没有在窗口尾部形成一段连续的序列；第二种是已经发送但是未被确认的数据；第三种是等待发送的数据。随着已发送的数据不断被确认，窗口内等待发送的数据也会不断被发送。整个窗口就会不断往前移动，让还没轮到的数据进入窗口内。</p>\n<p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p>\n<h3 id=\"2-15-详细讲一下拥塞控制？\">2.15 详细讲一下拥塞控制？</h3>\n<p>TCP 一共使用了四种算法来实现拥塞控制：</p>\n<ul>\n<li>慢开始（slow-start）</li>\n<li>拥塞避免（congestion avoidance）</li>\n<li>快重传（fast retransmit）</li>\n<li>快恢复（fast recovery）</li>\n</ul>\n<p>发送方维持一个叫做拥塞窗口 cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。</p>\n<ul>\n<li>慢开始：不要一开始就发送大量的数据，<strong>由小到大逐渐增加拥塞窗口的大小</strong>。<br>\n例如一开始发送方先设置 cwnd = 1，发送第一个报文段，等发送方接收到对方的确认后把 cwnd 从1增大到2。此后每经过一个传输轮次，拥塞窗口 cwnd 就加倍。<br>\n为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个慢开始门限 <code>ssthresh</code> 状态变量。\n<ul>\n<li>当 <code>cwnd &lt; ssthresh</code> 时，使用慢开始算法。</li>\n<li>当 <code>cwnd &gt; ssthresh</code> 时，停止使用慢开始算法改用拥塞避免算法。</li>\n<li>当 <code>cwnd = ssthresh</code> 时，即可使用慢开始算法，也可使用拥塞避免算法。</li>\n</ul>\n</li>\n<li>拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加一而不是加倍。这样拥塞窗口按线性规律缓慢增长。</li>\n<li>快重传：我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。快重传规定：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li>\n<li>快恢复：主要是配合快重传，当发送方连续收到三个重复确认时，就执行<strong>乘法减小</strong>算法，把 <code>ssthresh</code> 门限减半（为了预防网络发生拥塞），但接下来并不执行慢开始算法，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。</li>\n</ul>\n<h2 id=\"3-HTTP-HTTPS\">3. HTTP/HTTPS</h2>\n<h3 id=\"3-1-HTTP常见的状态码有哪些？\">3.1 HTTP常见的状态码有哪些？</h3>\n<p>常见状态码：</p>\n<ul>\n<li>200：服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。</li>\n<li>301：请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置（永久移动）。</li>\n<li>302：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求（临时移动）。</li>\n<li>400：客户端请求有语法错误，不能被服务器所理解。</li>\n<li>403：服务器收到请求，但是拒绝提供服务。</li>\n<li>404：服务器找不到请求的网页。</li>\n<li>500：服务器遇到错误，无法完成请求。</li>\n</ul>\n<p>状态码开头代表类型：</p>\n<table>\n    <thead>\n        <tr>\n            <th></th>\n            <th>类别</th>\n            <th>原因短语</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>1XX</td>\n            <td>Informational（信息性状态码）</td>\n            <td>接收的请求正在处理</td>\n        </tr>\n        <tr>\n            <td>2XX</td>\n            <td>Success（成功状态码）</td>\n            <td>请求正常处理完毕</td>\n        </tr>\n        <tr>\n            <td>3XX</td>\n            <td>Redirection（重定向状态码）</td>\n            <td>需要进行附加操作以完成请求</td>\n        </tr>\n        <tr>\n            <td>4XX</td>\n            <td>Client Error（客户端错误状态码）</td>\n            <td>服务器无法处理请求</td>\n        </tr>\n        <tr>\n            <td>5XX</td>\n            <td>Server Error（服务器错误状态码）</td>\n            <td>服务器处理请求出错</td>\n        </tr>\n    </tbody>\n</table>\n<h3 id=\"3-2-状态码301和302的区别是什么？\">3.2 状态码301和302的区别是什么？</h3>\n<ul>\n<li>共同点：301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的 URL 地址，这个地址可以从响应的 Location 首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）。</li>\n<li>不同点：301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。SEO 中302好于301。</li>\n</ul>\n<p>重定向原因：</p>\n<ul>\n<li>网站调整（如改变网页目录结构）。</li>\n<li>网页被移到一个新地址。</li>\n<li>网页扩展名改变（如应用需要把 <code>.php</code> 改成 <code>.html</code> 或 <code>.shtml</code>）。</li>\n</ul>\n<h3 id=\"3-3-HTTP常用的请求方式有哪些？\">3.3 HTTP常用的请求方式有哪些？</h3>\n<table>\n    <thead>\n        <tr>\n            <th>方法</th>\n            <th>作用</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>GET</td>\n            <td>获取资源</td>\n        </tr>\n        <tr>\n            <td>POST</td>\n            <td>传输实体主体</td>\n        </tr>\n        <tr>\n            <td>PUT</td>\n            <td>上传文件</td>\n        </tr>\n        <tr>\n            <td>DELETE</td>\n            <td>删除文件</td>\n        </tr>\n        <tr>\n            <td>HEAD</td>\n            <td>和 GET 方法类似，但是只返回报文首部，不返回报文实体主体部分</td>\n        </tr>\n        <tr>\n            <td>PATCH</td>\n            <td>对资源进行部分修改</td>\n        </tr>\n        <tr>\n            <td>OPTIONS</td>\n            <td>查询指定的 URL 支持的方法</td>\n        </tr>\n        <tr>\n            <td>CONNECT</td>\n            <td>要求用隧道协议连接代理</td>\n        </tr>\n        <tr>\n            <td>TRACE</td>\n            <td>服务器会将通信路径返回给客户端</td>\n        </tr>\n    </tbody>\n</table>\n<p>为了方便记忆，可以将 PUT、DELETE、POST、GET 理解为客户端对服务端的增删改查：</p>\n<ul>\n<li>PUT：上传文件，向服务器添加数据。</li>\n<li>DELETE：删除文件。</li>\n<li>POST：传输数据，向服务器提交数据，对服务器数据进行更新。</li>\n<li>GET：获取资源，查询服务器资源。</li>\n</ul>\n<h3 id=\"3-4-GET请求和POST请求的区别？\">3.4 GET请求和POST请求的区别？</h3>\n<p>使用上的区别：</p>\n<ul>\n<li>作用：GET 用于获取资源，而 POST 用于传输实体。</li>\n<li>参数：GET 使用 URL 或 Cookie 传参，而 POST 将数据放在 Request Body 中，这个是因为 HTTP 协议用法的约定。</li>\n<li>缓存：GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置。</li>\n<li>请求长度：GET 方式提交的数据有长度限制，基本为2kb，而 POST 的数据则可以非常大，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。</li>\n<li>安全性：POST 比 GET 安全，因为数据在地址栏上不可见，而 GET 的参数直接暴露在 URL 上。这个说法没毛病，但依然不是 GET 和 POST 本身的区别。</li>\n</ul>\n<p>本质区别：GET 和 POST 最大的区别主要是 GET 请求是幂等性的，POST 请求不是。这个是它们本质区别。（幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一 URL 的多个请求应该返回同样的结果）</p>\n<h3 id=\"3-5-解释一下HTTP长连接和短连接？\">3.5 解释一下HTTP长连接和短连接？</h3>\n<p>在 <strong>HTTP/1.0</strong> 中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次 HTTP 操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源，如 JavaScript 文件、图像文件、CSS 文件等，当浏览器每遇到这样一个 Web 资源，就会建立一个 HTTP 会话。</p>\n<p>但从 <strong>HTTP/1.1</strong> 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：<code>Connection:keep-alive</code>。</p>\n<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（例如 Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p>\n<p><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接</strong>。</p>\n<h3 id=\"3-6-HTTP1-0和HTTP1-1的区别？\">3.6 HTTP1.0和HTTP1.1的区别？</h3>\n<ul>\n<li>长连接：HTTP1.1 支持长连接（Persistent Connection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 <code>Connection: keep-alive</code>，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。</li>\n<li>缓存处理：在 HTTP1.0 中主要使用 header 里的 <code>If-Modified-Since, Expires</code> 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略，可供选择的缓存头来控制缓存策略。</li>\n<li>带宽优化及网络连接的使用：HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>\n<li>错误通知的管理：在 HTTP1.1 中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突，410（Gone）表示服务器上的某个资源被永久性的删除。</li>\n<li>Host 头处理：在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。</li>\n</ul>\n<h3 id=\"3-7-HTTP1-1和HTTP2-0的区别？\">3.7 HTTP1.1和HTTP2.0的区别？</h3>\n<p>HTTP2.0 相比 HTTP1.1 支持的特性：</p>\n<ul>\n<li>新的二进制格式：HTTP1.1 的解析是基于文本的。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。</li>\n<li>多路复用：即连接共享，每一个 request 都是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。</li>\n<li>头部压缩：HTTP1.1 的头部（header）带有大量信息，而且每次都要重复发送。HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。</li>\n<li>服务端推送：服务器除了对最初请求的响应外，服务器还可以额外地向客户端推送资源，而无需客户端明确的请求。</li>\n</ul>\n<h3 id=\"3-8-HTTP和HTTPS的区别？\">3.8 HTTP和HTTPS的区别？</h3>\n<table>\n    <thead>\n        <tr>\n            <th></th>\n            <th>HTTP</th>\n            <th>HTTPS</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>端口</td>\n            <td>80</td>\n            <td>443</td>\n        </tr>\n        <tr>\n            <td>安全性</td>\n            <td>无加密，安全性较差</td>\n            <td>有加密机制，安全性较高</td>\n        </tr>\n        <tr>\n            <td>资源消耗</td>\n            <td>较少</td>\n            <td>由于加密处理，资源消耗更多</td>\n        </tr>\n        <tr>\n            <td>是否需要证书</td>\n            <td>不需要</td>\n            <td>需要</td>\n        </tr>\n        <tr>\n            <td>协议</td>\n            <td>运行在 TCP 协议之上</td>\n            <td>运行在 SSL 协议之上，SSL 运行在 TCP 协议之上</td>\n        </tr>\n    </tbody>\n</table>\n<h3 id=\"3-9-HTTPS的优缺点？\">3.9 HTTPS的优缺点？</h3>\n<p>优点：</p>\n<ul>\n<li>安全性：\n<ul>\n<li>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</li>\n<li>HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>\n<li>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>\n</ul>\n</li>\n<li>SEO 方面：谷歌曾在2014年8月份调整搜索引擎算法，并称比起同等 HTTP 网站，采用 HTTPS 加密的网站在搜索结果中的排名将会更高。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。</li>\n<li>HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。</li>\n<li>在现有的证书机制下，中间人攻击依然有可能发生。</li>\n<li>HTTPS 需要更多的服务器资源，也会导致成本的升高。</li>\n</ul>\n<h3 id=\"3-10-HTTPS的原理？\">3.10 HTTPS的原理？</h3>\n<ol>\n<li>客户端请求 HTTPS 网址，例如：<code>https://www.baidu.com</code>，然后连接到 Server 的443端口（HTTPS 默认端口，类似于 HTTP 的80端口）。</li>\n<li>采用 HTTPS 协议的服务器必须要有一套数字 CA（Certification Authority）证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。</li>\n<li>服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。</li>\n<li>客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。<br>\n如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 <code>KEY</code>，并使用公钥A将其加密。</li>\n<li>客户端把加密后的随机码 <code>KEY</code> 发送给服务器，作为后面对称加密的密钥。</li>\n<li>服务器在收到随机码 <code>KEY</code> 之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。</li>\n<li>服务器使用密钥（随机码 <code>KEY</code>）对数据进行对称加密并发送给客户端，客户端使用相同的密钥（随机码 <code>KEY</code>）解密数据。</li>\n<li>双方使用对称加密愉快地传输所有数据。</li>\n</ol>\n<h3 id=\"3-11-什么是Cookie和Session？\">3.11 什么是Cookie和Session？</h3>\n<p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>\n<p>Cookie 主要用于以下三个方面：</p>\n<ul>\n<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）。</li>\n<li>个性化设置（如用户自定义设置、主题等）。</li>\n<li>浏览器行为跟踪（如跟踪分析用户行为等）。</li>\n</ul>\n<p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>\n<h3 id=\"3-12-Cookie和Session是如何配合的呢？\">3.12 Cookie和Session是如何配合的呢？</h3>\n<p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>\n<p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在则自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>\n<p>根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p>\n<h3 id=\"3-13-Cookie和Session的区别？\">3.13 Cookie和Session的区别？</h3>\n<ul>\n<li>作用范围不同：Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li>\n<li>存取方式的不同：Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserID 等。</li>\n<li>有效期不同：Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>\n<li>隐私策略不同：Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>\n<li>存储大小不同：单个 Cookie 保存的数据不能超过4K，Session 可存储数据远高于 Cookie。</li>\n</ul>\n",
            "tags": [
                "Interview"
            ]
        }
    ]
}