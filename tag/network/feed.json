{
    "version": "https://jsonfeed.org/version/1",
    "title": "AsanoSaki • All posts by \"network\" tag",
    "description": "",
    "home_page_url": "https://asanosaki.github.io",
    "items": [
        {
            "id": "https://asanosaki.github.io/posts/54431.html",
            "url": "https://asanosaki.github.io/posts/54431.html",
            "title": "计算机网络面试知识点总结",
            "date_published": "2022-11-24T03:14:00.000Z",
            "content_html": "<blockquote>\n<p>计算机网络常见面试题总结，文章将不断更新。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h1>1. 概述</h1>\n<h2 id=\"1-1-计算机网络的各层协议及作用？\">1.1 计算机网络的各层协议及作用？</h2>\n<p>计算机网络体系可以大致分为三种：OSI 七层模型、TCP/IP 四层模型和五层模型。</p>\n<ul>\n<li>OSI 七层模型：大而全，但是比较复杂、而且是先有了理论模型，没有实际应用。</li>\n<li>TCP/IP 四层模型：是由实际应用发展总结出来的，从实质上讲，TCP/IP 只有最上面两层，最下面一层没有什么具体内容，TCP/IP 参考模型没有真正描述这一层的实现。</li>\n<li>TCP/IP 五层模型：五层模型只出现在计算机网络教学过程中，这是对七层模型和四层模型的一个折中，既简洁又能将概念阐述清楚。</li>\n</ul>\n<p>七层网络体系结构各层的主要功能：</p>\n<ul>\n<li>应用层：为应用程序提供交互服务。在互联网中的应用层协议有很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等。</li>\n<li>表示层：主要负责数据格式的转换，如加密解密、转换翻译、压缩解压缩等。</li>\n<li>会话层：负责在网络中的两节点之间建立、维持和终止通信，如服务器验证用户登录便是由会话层完成的。</li>\n<li>运输层：有时也译为传输层，向主机进程提供通用的数据传输服务。该层主要有以下两种协议：\n<ul>\n<li>TCP：提供面向连接的、可靠的数据传输服务。</li>\n<li>UDP：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。</li>\n</ul>\n</li>\n<li>网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括 IP 协议。</li>\n<li>数据链路层：数据链路层通常简称为链路层。将网络层传下来的 IP 数据包组装成帧，并在相邻节点的链路上传送帧。</li>\n<li>物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异。</li>\n</ul>\n<h1>2. TCP/IP</h1>\n<h2 id=\"2-1-TCP和UDP的区别？\">2.1 TCP和UDP的区别？</h2>\n<table>\n    <thead>\n        <tr>\n            <th></th>\n            <th>TCP</th>\n            <th>UDP</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>是否连接</td>\n            <td>面向连接</td>\n            <td>无连接</td>\n        </tr>\n        <tr>\n            <td>是否可靠</td>\n            <td>可靠传输，使用流量控制和拥塞控制</td>\n            <td>不可靠传输，不使用流量控制和拥塞控制</td>\n        </tr>\n        <tr>\n            <td>是否有序</td>\n            <td>有序，消息在传输过程中可能会乱序，TCP 会重新排序</td>\n            <td>无序</td>\n        </tr>\n        <tr>\n            <td>传输速度</td>\n            <td>慢</td>\n            <td>快</td>\n        </tr>\n        <tr>\n            <td>连接对象个数</td>\n            <td>只能一对一通信</td>\n            <td>支持一对一、一对多、多对一和多对多交互通信</td>\n        </tr>\n        <tr>\n            <td>传输方式</td>\n            <td>面向字节流</td>\n            <td>面向报文</td>\n        </tr>\n        <tr>\n            <td>首部开销</td>\n            <td>首部开销大，最小20字节，最大60字节</td>\n            <td>首部开销小，仅8字节</td>\n        </tr>\n        <tr>\n            <td>适用场景</td>\n            <td>适用于要求可靠传输的应用，例如文件传输</td>\n            <td>适用于实时应用例如 IP 电话、视频会议、直播等</td>\n        </tr>\n    </tbody>\n</table>\n<p>总结：TCP 用于在传输层有必要实现可靠传输的情况，UDP 用于对高速传输和实时性有较高要求的通信。TCP 和 UDP 应该根据应用目的按需使用。</p>\n<h2 id=\"2-2-TCP和UDP对应的应用场景是什么？\">2.2 TCP和UDP对应的应用场景是什么？</h2>\n<ul>\n<li>TCP 是面向连接的，能保证数据的可靠性交付，因此经常用于：\n<ul>\n<li>FTP 文件传输。</li>\n<li>HTTP/HTTPS。</li>\n<li>SMTP 简单邮件传输。</li>\n</ul>\n</li>\n<li>UDP 是无连接的，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：\n<ul>\n<li>包总量较少的通信，如 DNS、SNMP 等。</li>\n<li>视频、音频等多媒体通信。</li>\n<li>广播通信。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-3-TCP的三次握手机制？\">2.3 TCP的三次握手机制？</h2>\n<ul>\n<li>第一次握手：客户端请求建立连接，向服务端发送一个同步报文（<code>SYN = 1</code>），同时选择一个随机数 <code>seq = x</code> 作为初始序列号，并进入 <code>SYN_SENT</code>（同步已发送）状态，等待服务器确认。</li>\n<li>第二次握手：服务端收到连接请求报文后，如果同意建立连接，则向客户端发送同步确认报文（<code>SYN = 1, ACK = 1</code>），确认号为 <code>ack = x + 1</code>，同时选择一个随机数 <code>seq = y</code> 作为初始序列号，此时服务器进入 <code>SYN_RECV</code>（同步收到）状态。</li>\n<li>第三次握手：客户端收到服务端的确认后，向服务端发送一个确认报文（<code>ACK = 1</code>），确认号为 <code>ack = y + 1</code>，序列号为 <code>seq = x + 1</code>，客户端和服务器进入 <code>ESTABLISHED</code>（已建立连接）状态，完成三次握手。</li>\n</ul>\n<p>理想状态下，TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>\n<h2 id=\"2-4-为什么需要三次握手，而不是两次？\">2.4 为什么需要三次握手，而不是两次？</h2>\n<p>主要有三个原因：</p>\n<ol>\n<li>防止已过期的连接请求报文突然又传送到服务器，因而产生错误和资源浪费。<br>\n在双方两次握手即可建立连接的情况下，假设客户端发送报文段A请求建立连接，由于网络原因造成A暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段。<br>\n客户端在长时间得不到应答的情况下重新发送请求报文段B，这次B顺利到达服务器，服务器随即返回确认报文并进入 <code>ESTABLISHED</code> 状态，客户端在收到确认报文后也进入 <code>ESTABLISHED</code> 状态，双方建立连接并传输数据，之后正常断开连接。<br>\n此时姗姗来迟的报文段A才到达服务器，服务器随即返回确认报文并进入 <code>ESTABLISHED</code> 状态，但是已经进入 <code>CLOSED</code> 状态的客户端无法再接受确认报文段，更无法进入 <code>ESTABLISHED</code> 状态，这将导致服务器长时间单方面等待，造成资源浪费。</li>\n<li>三次握手才能让双方均确认自己和对方的发送和接收能力都正常。<br>\n第一次握手：客户端只是发送处请求报文段，什么都无法确认，而服务器可以确认自己的接收能力和对方的发送能力正常。<br>\n第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常。<br>\n第三次握手：服务器可以确认<strong>自己发送能力</strong>和接收能力正常，<strong>对方</strong>发送能力和<strong>接收能力</strong>正常。<br>\n可见三次握手才能让双方都确认自己和对方的发送和接收能力全部正常，这样就可以愉快地进行通信了。</li>\n<li>告知对方自己的初始序号值，并确认收到对方的初始序号值。<br>\nTCP 实现了可靠的数据传输，原因之一就是 TCP 报文段中维护了序号字段和确认序号字段，通过这两个字段双方都可以知道在自己发出的数据中，哪些是已经被对方确认接收的。这两个字段的值会在初始序号值的基础上递增，如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的初始序号则得不到确认。</li>\n</ol>\n<h2 id=\"2-5-为什么需要三次握手，而不是四次？\">2.5 为什么需要三次握手，而不是四次？</h2>\n<p>因为三次握手已经可以确认双方的发送和接收能力正常，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值的确认，也就无需第四次握手了。</p>\n<ul>\n<li>第一次握手：服务端确认<strong>自己收、对方发</strong>报文功能正常。</li>\n<li>第二次握手：客户端确认<strong>自己发、自己收、对方收、对方发</strong>报文功能正常，客户端认为连接己建立。</li>\n<li>第三次握手：服务端确认<strong>自己发、对方收</strong>报文功能正常，此时双方均建立连接，可以正常通信。</li>\n</ul>\n<h2 id=\"2-6-什么是SYN洪泛攻击？如何防范？\">2.6 什么是SYN洪泛攻击？如何防范？</h2>\n<p>SYN 洪泛攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的<strong>半连接</strong>请求，耗费 CPU 和内存资源。</p>\n<p>原理：</p>\n<ul>\n<li>在三次握手过程中，服务器发送 <code>[SYN/ACK]</code> 包（即第二个包）之后、收到客户端的 <code>[ACK]</code> 包（即第三个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 <code>SYN_RECV</code>（等待客户端响应）状态。如果接收到客户端的 <code>[ACK]</code>，则 TCP 连接成功，如果未接收到，则会不断重发请求直至成功。</li>\n<li>SYN 攻击的攻击者在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 <code>[SYN]</code> 包，服务器回复 <code>[SYN/ACK]</code> 包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时。</li>\n<li>这些伪造的 <code>[SYN]</code> 包将长时间占用未连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络堵塞甚至系统瘫痪。</li>\n</ul>\n<p>检测：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。</p>\n<p>防范：</p>\n<ul>\n<li>通过防火墙、路由器等过滤网关防护。</li>\n<li>通过加固 TCP/IP 协议栈防范，如增加最大半连接数，缩短超时时间。</li>\n<li>SYN Cookies 技术。SYN Cookies 是对 TCP 服务器端的三次握手做一些修改，专门用来防范 SYN 洪泛攻击的一种手段。</li>\n</ul>\n<h2 id=\"2-7-三次握手连接阶段，如果最后一次ACK包丢失，会发生什么？\">2.7 三次握手连接阶段，如果最后一次ACK包丢失，会发生什么？</h2>\n<p>服务端：</p>\n<ul>\n<li>第三次的 <code>ACK</code> 包在网络中丢失，那么服务端该 TCP 连接的状态为 <code>SYN_RECV</code>,并且会根据 TCP 的超时重传机制，会等待3秒、6秒、12秒后重新发送 <code>SYN + ACK</code> 包，以便客户端重新发送 <code>ACK</code> 包。</li>\n<li>如果重发指定次数之后，仍然未收到客户端的 ACK 应答，那么一段时间后，服务端自动关闭这个连接。</li>\n</ul>\n<p>客户端：</p>\n<ul>\n<li>客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以 <code>RST</code> 包（Reset，表示复位，用于异常的关闭连接）响应。此时，客户端便知道第三次握手失败。</li>\n</ul>\n<h2 id=\"2-8-TCP的四次挥手过程？\">2.8 TCP的四次挥手过程？</h2>\n<ul>\n<li>第一次挥手：客户端向服务端发送连接释放报文（<code>FIN = 1, ACK = 1</code>），主动关闭连接，同时等待服务端的确认，客户端进入 <code>FIN_WAIT_1</code>（终止等待1）状态。序列号 <code>seq = u</code>，为客户端上次发送的报文的最后一个字节的序号 + 1。</li>\n<li>第二次挥手：服务端收到连接释放报文后，立即发出确认报文（<code>ACK = 1</code>），序列号 <code>seq = v</code>，为服务端上次发送的报文的最后一个字节的序号 + 1，确认号 <code>ack = u + 1</code>，服务端进入 <code>CLOSE_WAIT</code>（关闭等待）状态。<br>\n此时 TCP 连接处于<strong>半关闭</strong>状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。这表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。</li>\n<li>第三次挥手：客户端收到服务端的确认后进入 <code>FIN_WAIT_2</code>（终止等待2）状态，等待服务端发出连接释放报文段。服务端向客户端发送连接释放报文（<code>FIN = 1, ACK = 1</code>），主动关闭连接，同时等待A的确认，服务端进入 <code>LAST_ACK</code>（最后确认）状态。\n<ul>\n<li>序列号 <code>seq = w</code>，即服务端上次发送的报文的最后一个字节的序号 + 1，可能在半关闭状态服务端又发送了一些数据。</li>\n<li>确认号 <code>ack = u + 1</code>，与第二次挥手相同，因为这段时间客户端没有发送数据。</li>\n</ul>\n</li>\n<li>第四次挥手：客户端收到服务端的连接释放报文后，立即发出确认报文（<code>ACK = 1</code>），序列号 <code>seq = u + 1</code>，确认号为 <code>ack = w + 1</code>。<br>\n此时，客户端就进入了 <code>TIME_WAIT</code>（时间等待）状态。注意此时客户端到 TCP 连接还没有释放，必须经过2 * MSL（最长报文段寿命）的时间后，才进入 <code>CLOSED</code> 状态。而服务端只要收到客户端发出的确认，就立即进入 <code>CLOSED</code> 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。</li>\n</ul>\n<h2 id=\"2-9-为什么连接的时候是三次握手，关闭的时候却是四次握手？\">2.9 为什么连接的时候是三次握手，关闭的时候却是四次握手？</h2>\n<p>服务器在收到客户端的 <code>FIN</code> 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 <code>ACK</code> 报文段.</p>\n<p>接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 <code>FIN</code> 报文，表示数据已经发送完毕，请求关团连接。服务器的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而导致多了一次，因此一共需要四次挥手。</p>\n<h2 id=\"2-10-为什么客户端的TIME-WAIT状态必须等待2MSL？\">2.10 为什么客户端的TIME_WAIT状态必须等待2MSL？</h2>\n<p>主要有两个原因:</p>\n<ol>\n<li>确保最后一个 <code>ACK</code> 报文段能够到达服务端，从而使服务端正常关闭连接。<br>\n第四次挥手时，客户端第四次挥手的 <code>ACK</code> 报文段不一定会到达服务端。服务端会超时重传 <code>FIN/ACK</code> 报文段，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 <code>FIN/ACK</code> 报文段的确认，就无法正常断开连接。<br>\nMSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即：客户端 <code>ACK</code> 报文段 1MSL 超时 + 服务端 <code>FIN</code> 报文段 1MSL 传输，就能够收到服务端重传的 <code>FIN/ACK</code> 报文段，然后客户端重传一次 <code>ACK</code> 报文段，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。<br>\n如果服务端重发的 <code>FIN</code> 报文段没有成功地在 2MSL 时间里传给客户端，服务端则会继续超时重试直到断开连接。</li>\n<li>防止已失效的连接请求报文段出现在之后的连接中。<br>\nTCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 <code>ACK</code> 报文段后，再经过时间 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。</li>\n</ol>\n<h2 id=\"2-11-如果已经建立了连接，但是客户端出现故障了怎么办？\">2.11 如果已经建立了连接，但是客户端出现故障了怎么办？</h2>\n<p>通过<strong>定时器 + 超时重试机制</strong>，尝试获取确认，直到最后会自动断开连接。</p>\n<p>具体而言，TCP 设有一个<strong>保活计时器</strong>。服务器每收到一次客户端的数据，都会重新设置这个计时器，时间通常是设置为2小时。若2小时还没有收到客户端的任何数据，服务器就发送一个探测报文段，之后则每隔75秒钟发送一次，若一连发送10个探测报文段后客户端依然没有响应，那么服务器就认为客户端出现故障，接着就关闭这个连接。</p>\n<h2 id=\"2-12-TIME-WAIT是服务器端还是客户端的状态\">2.12 TIME_WAIT是服务器端还是客户端的状态?</h2>\n<p><code>TIME_WAIT</code> 是<strong>主动断开连接</strong>的一方会进入的状态，一般情况下，都是客户端所处的状态，服务器端一般设置不主动关闭连接。</p>\n<p><code>TIME_WAIT</code> 需要等待 2MSL，在大量短连接的情况下，<code>TIME_WAIT</code> 会太多，这也会消耗很多系统资源。对于服务器来说，在 HTTP 协议里指定 KeepAlive（浏览器重用一个 TCP 连接来处理多个 HTTP 请求），由浏览器来主动断开连接，可以一定程度上减少服务器的这个问题。</p>\n<h2 id=\"2-13-TCP协议如何保证可靠性，即如何实现可靠传输？\">2.13 TCP协议如何保证可靠性，即如何实现可靠传输？</h2>\n<p>TCP 主要提供了检验和、序列号/确认应答、超时重传、滑动窗口、拥塞控制和流量控制等方法实现了可靠性传输。</p>\n<ul>\n<li>检验和：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃 TCP 报文段，重新发送。</li>\n<li>序列号/确认应答：序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。<br>\nTCP 传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送 ACK 报文段，这个 ACK 报文段当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</li>\n<li>滑动窗口：滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。</li>\n<li>超时重传：超时重传的时间是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。</li>\n<li>拥塞控制：在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证 TCP 可靠性的同时，提高性能。</li>\n<li>流量控制：如果主机A一直向主机B发送数据，不考虑主机B的接收能力，则可能导致主机B的接收缓冲区满了而无法再接收数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量。流量控制与 TCP 协议报头中的窗口大小有关。</li>\n</ul>\n<h2 id=\"2-14-详细讲一下TCP的滑动窗口？\">2.14 详细讲一下TCP的滑动窗口？</h2>\n<p>在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。TCP 协议需要对数据进行确认后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。</p>\n<p>为了避免这种情况，TCP 引入了窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值。</p>\n<p>滑动窗口里面也分为有三种类型的数据，第一种是已经发送且收到确认但是未按序到达，即没有在窗口尾部形成一段连续的序列；第二种是已经发送但是未被确认的数据；第三种是等待发送的数据。随着已发送的数据不断被确认，窗口内等待发送的数据也会不断被发送。整个窗口就会不断往前移动，让还没轮到的数据进入窗口内。</p>\n<p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p>\n<h2 id=\"2-15-详细讲一下拥塞控制？\">2.15 详细讲一下拥塞控制？</h2>\n<p>TCP 一共使用了四种算法来实现拥塞控制：</p>\n<ul>\n<li>慢开始（slow-start）</li>\n<li>拥塞避免（congestion avoidance）</li>\n<li>快重传（fast retransmit）</li>\n<li>快恢复（fast recovery）</li>\n</ul>\n<p>发送方维持一个叫做拥塞窗口 cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。</p>\n<ul>\n<li>慢开始：不要一开始就发送大量的数据，<strong>由小到大逐渐增加拥塞窗口的大小</strong>。<br>\n例如一开始发送方先设置 cwnd = 1，发送第一个报文段，等发送方接收到对方的确认后把 cwnd 从1增大到2。此后每经过一个传输轮次，拥塞窗口 cwnd 就加倍。<br>\n为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个慢开始门限 <code>ssthresh</code> 状态变量。\n<ul>\n<li>当 <code>cwnd &lt; ssthresh</code> 时，使用慢开始算法。</li>\n<li>当 <code>cwnd &gt; ssthresh</code> 时，停止使用慢开始算法改用拥塞避免算法。</li>\n<li>当 <code>cwnd = ssthresh</code> 时，即可使用慢开始算法，也可使用拥塞避免算法。</li>\n</ul>\n</li>\n<li>拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加一而不是加倍。这样拥塞窗口按线性规律缓慢增长。</li>\n<li>快重传：我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。快重传规定：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li>\n<li>快恢复：主要是配合快重传，当发送方连续收到三个重复确认时，就执行<strong>乘法减小</strong>算法，把 <code>ssthresh</code> 门限减半（为了预防网络发生拥塞），但接下来并不执行慢开始算法，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。</li>\n</ul>\n<h1>3. HTTP/HTTPS</h1>\n<h2 id=\"3-1-HTTP常见的状态码有哪些？\">3.1 HTTP常见的状态码有哪些？</h2>\n<p>常见状态码：</p>\n<ul>\n<li>200：服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。</li>\n<li>301：请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置（永久移动）。</li>\n<li>302：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求（临时移动）。</li>\n<li>400：客户端请求有语法错误，不能被服务器所理解。</li>\n<li>403：服务器收到请求，但是拒绝提供服务。</li>\n<li>404：服务器找不到请求的网页。</li>\n<li>500：服务器遇到错误，无法完成请求。</li>\n</ul>\n<p>状态码开头代表类型：</p>\n<table>\n    <thead>\n        <tr>\n            <th></th>\n            <th>类别</th>\n            <th>原因短语</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>1XX</td>\n            <td>Informational（信息性状态码）</td>\n            <td>接收的请求正在处理</td>\n        </tr>\n        <tr>\n            <td>2XX</td>\n            <td>Success（成功状态码）</td>\n            <td>请求正常处理完毕</td>\n        </tr>\n        <tr>\n            <td>3XX</td>\n            <td>Redirection（重定向状态码）</td>\n            <td>需要进行附加操作以完成请求</td>\n        </tr>\n        <tr>\n            <td>4XX</td>\n            <td>Client Error（客户端错误状态码）</td>\n            <td>服务器无法处理请求</td>\n        </tr>\n        <tr>\n            <td>5XX</td>\n            <td>Server Error（服务器错误状态码）</td>\n            <td>服务器处理请求出错</td>\n        </tr>\n    </tbody>\n</table>\n<h2 id=\"3-2-状态码301和302的区别是什么？\">3.2 状态码301和302的区别是什么？</h2>\n<ul>\n<li>共同点：301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的 URL 地址，这个地址可以从响应的 Location 首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）。</li>\n<li>不同点：301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。SEO 中302好于301。</li>\n</ul>\n<p>重定向原因：</p>\n<ul>\n<li>网站调整（如改变网页目录结构）。</li>\n<li>网页被移到一个新地址。</li>\n<li>网页扩展名改变（如应用需要把 <code>.php</code> 改成 <code>.html</code> 或 <code>.shtml</code>）。</li>\n</ul>\n<h2 id=\"3-3-HTTP常用的请求方式有哪些？\">3.3 HTTP常用的请求方式有哪些？</h2>\n<table>\n    <thead>\n        <tr>\n            <th>方法</th>\n            <th>作用</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>GET</td>\n            <td>获取资源</td>\n        </tr>\n        <tr>\n            <td>POST</td>\n            <td>传输实体主体</td>\n        </tr>\n        <tr>\n            <td>PUT</td>\n            <td>上传文件</td>\n        </tr>\n        <tr>\n            <td>DELETE</td>\n            <td>删除文件</td>\n        </tr>\n        <tr>\n            <td>HEAD</td>\n            <td>和 GET 方法类似，但是只返回报文首部，不返回报文实体主体部分</td>\n        </tr>\n        <tr>\n            <td>PATCH</td>\n            <td>对资源进行部分修改</td>\n        </tr>\n        <tr>\n            <td>OPTIONS</td>\n            <td>查询指定的 URL 支持的方法</td>\n        </tr>\n        <tr>\n            <td>CONNECT</td>\n            <td>要求用隧道协议连接代理</td>\n        </tr>\n        <tr>\n            <td>TRACE</td>\n            <td>服务器会将通信路径返回给客户端</td>\n        </tr>\n    </tbody>\n</table>\n<p>为了方便记忆，可以将 PUT、DELETE、POST、GET 理解为客户端对服务端的增删改查：</p>\n<ul>\n<li>PUT：上传文件，向服务器添加数据。</li>\n<li>DELETE：删除文件。</li>\n<li>POST：传输数据，向服务器提交数据，对服务器数据进行更新。</li>\n<li>GET：获取资源，查询服务器资源。</li>\n</ul>\n<h2 id=\"3-4-GET请求和POST请求的区别？\">3.4 GET请求和POST请求的区别？</h2>\n<p>使用上的区别：</p>\n<ul>\n<li>作用：GET 用于获取资源，而 POST 用于传输实体。</li>\n<li>参数：GET 使用 URL 或 Cookie 传参，而 POST 将数据放在 Request Body 中，这个是因为 HTTP 协议用法的约定。</li>\n<li>缓存：GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置。</li>\n<li>请求长度：GET 方式提交的数据有长度限制，基本为2kb，而 POST 的数据则可以非常大，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。</li>\n<li>安全性：POST 比 GET 安全，因为数据在地址栏上不可见，而 GET 的参数直接暴露在 URL 上。这个说法没毛病，但依然不是 GET 和 POST 本身的区别。</li>\n</ul>\n<p>本质区别：GET 和 POST 最大的区别主要是 GET 请求是幂等性的，POST 请求不是。这个是它们本质区别。（幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一 URL 的多个请求应该返回同样的结果）</p>\n<h2 id=\"3-5-解释一下HTTP长连接和短连接？\">3.5 解释一下HTTP长连接和短连接？</h2>\n<p>在 <strong>HTTP/1.0</strong> 中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次 HTTP 操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源，如 JavaScript 文件、图像文件、CSS 文件等，当浏览器每遇到这样一个 Web 资源，就会建立一个 HTTP 会话。</p>\n<p>但从 <strong>HTTP/1.1</strong> 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：<code>Connection:keep-alive</code>。</p>\n<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（例如 Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p>\n<p><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接</strong>。</p>\n<h2 id=\"3-6-HTTP1-0和HTTP1-1的区别？\">3.6 HTTP1.0和HTTP1.1的区别？</h2>\n<ul>\n<li>长连接：HTTP1.1 支持长连接（Persistent Connection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 <code>Connection: keep-alive</code>，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。</li>\n<li>缓存处理：在 HTTP1.0 中主要使用 header 里的 <code>If-Modified-Since, Expires</code> 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略，可供选择的缓存头来控制缓存策略。</li>\n<li>带宽优化及网络连接的使用：HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>\n<li>错误通知的管理：在 HTTP1.1 中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突，410（Gone）表示服务器上的某个资源被永久性的删除。</li>\n<li>Host 头处理：在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。</li>\n</ul>\n<h2 id=\"3-7-HTTP1-1和HTTP2-0的区别？\">3.7 HTTP1.1和HTTP2.0的区别？</h2>\n<p>HTTP2.0 相比 HTTP1.1 支持的特性：</p>\n<ul>\n<li>新的二进制格式：HTTP1.1 的解析是基于文本的。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。</li>\n<li>多路复用：即连接共享，每一个 request 都是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。</li>\n<li>头部压缩：HTTP1.1 的头部（header）带有大量信息，而且每次都要重复发送。HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。</li>\n<li>服务端推送：服务器除了对最初请求的响应外，服务器还可以额外地向客户端推送资源，而无需客户端明确的请求。</li>\n</ul>\n<h2 id=\"3-8-HTTP和HTTPS的区别？\">3.8 HTTP和HTTPS的区别？</h2>\n<table>\n    <thead>\n        <tr>\n            <th></th>\n            <th>HTTP</th>\n            <th>HTTPS</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>端口</td>\n            <td>80</td>\n            <td>443</td>\n        </tr>\n        <tr>\n            <td>安全性</td>\n            <td>无加密，安全性较差</td>\n            <td>有加密机制，安全性较高</td>\n        </tr>\n        <tr>\n            <td>资源消耗</td>\n            <td>较少</td>\n            <td>由于加密处理，资源消耗更多</td>\n        </tr>\n        <tr>\n            <td>是否需要证书</td>\n            <td>不需要</td>\n            <td>需要</td>\n        </tr>\n        <tr>\n            <td>协议</td>\n            <td>运行在 TCP 协议之上</td>\n            <td>运行在 SSL 协议之上，SSL 运行在 TCP 协议之上</td>\n        </tr>\n    </tbody>\n</table>\n<h2 id=\"3-9-HTTPS的优缺点？\">3.9 HTTPS的优缺点？</h2>\n<p>优点：</p>\n<ul>\n<li>安全性：\n<ul>\n<li>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</li>\n<li>HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>\n<li>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>\n</ul>\n</li>\n<li>SEO 方面：谷歌曾在2014年8月份调整搜索引擎算法，并称比起同等 HTTP 网站，采用 HTTPS 加密的网站在搜索结果中的排名将会更高。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。</li>\n<li>HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。</li>\n<li>在现有的证书机制下，中间人攻击依然有可能发生。</li>\n<li>HTTPS 需要更多的服务器资源，也会导致成本的升高。</li>\n</ul>\n<h2 id=\"3-10-HTTPS的原理？\">3.10 HTTPS的原理？</h2>\n<ol>\n<li>客户端请求 HTTPS 网址，例如：<code>https://www.baidu.com</code>，然后连接到 Server 的443端口（HTTPS 默认端口，类似于 HTTP 的80端口）。</li>\n<li>采用 HTTPS 协议的服务器必须要有一套数字 CA（Certification Authority）证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。</li>\n<li>服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。</li>\n<li>客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。<br>\n如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 <code>KEY</code>，并使用公钥A将其加密。</li>\n<li>客户端把加密后的随机码 <code>KEY</code> 发送给服务器，作为后面对称加密的密钥。</li>\n<li>服务器在收到随机码 <code>KEY</code> 之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。</li>\n<li>服务器使用密钥（随机码 <code>KEY</code>）对数据进行对称加密并发送给客户端，客户端使用相同的密钥（随机码 <code>KEY</code>）解密数据。</li>\n<li>双方使用对称加密愉快地传输所有数据。</li>\n</ol>\n<h2 id=\"3-11-什么是Cookie和Session？\">3.11 什么是Cookie和Session？</h2>\n<p>HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>\n<p>Cookie 主要用于以下三个方面：</p>\n<ul>\n<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）。</li>\n<li>个性化设置（如用户自定义设置、主题等）。</li>\n<li>浏览器行为跟踪（如跟踪分析用户行为等）。</li>\n</ul>\n<p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>\n<h2 id=\"3-12-Cookie和Session是如何配合的呢？\">3.12 Cookie和Session是如何配合的呢？</h2>\n<p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>\n<p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在则自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>\n<p>根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p>\n<h2 id=\"3-13-Cookie和Session的区别？\">3.13 Cookie和Session的区别？</h2>\n<ul>\n<li>作用范围不同：Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li>\n<li>存取方式的不同：Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说UserID等。</li>\n<li>有效期不同：Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>\n<li>隐私策略不同：Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>\n<li>存储大小不同：单个 Cookie 保存的数据不能超过4K，Session 可存储数据远高于 Cookie。</li>\n</ul>\n",
            "tags": [
                "Network"
            ]
        }
    ]
}