<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://asanosaki.github.io</id>
    <title>AsanoSaki • Posts by &#34;interview&#34; tag</title>
    <link href="https://asanosaki.github.io" />
    <updated>2023-11-24T09:09:00.000Z</updated>
    <category term="Others" />
    <category term="AI" />
    <category term="Python" />
    <category term="Hexo" />
    <category term="Java" />
    <category term="Interview" />
    <category term="Linux" />
    <category term="Web" />
    <category term="C++" />
    <category term="Essay" />
    <entry>
        <id>https://asanosaki.github.io/posts/2329.html</id>
        <title>Spring面试题总结</title>
        <link rel="alternate" href="https://asanosaki.github.io/posts/2329.html"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;Spring 面试题总结，涉及 Spring、Spring MVC、Spring Boot、Spring Cloud、MyBatis 等内容，文章将不断更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;h2 id=&#34;1-Spring&#34;&gt;1. Spring&lt;/h2&gt;
&lt;h3 id=&#34;1-1-Spring-框架是什么？有什么优势？核心特性是什么？&#34;&gt;1.1 Spring 框架是什么？有什么优势？核心特性是什么？&lt;/h3&gt;
&lt;p&gt;Spring 框架是一个轻量级的 Java 开发框架，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的 JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发 Java 应用程序提供全面的基础架构支持。Spring 的最根本的使命是解决企业级应用开发的复杂性，即简化 Java 开发。&lt;/p&gt;
&lt;p&gt;Spring 框架的优势主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方便解耦，简化开发：Spring 就是一个大工厂，可以将所有对象的创建以及依赖关系的维护交给 Spring 管理。&lt;/li&gt;
&lt;li&gt;AOP 编程的支持：Spring 提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。&lt;/li&gt;
&lt;li&gt;声明式事务的支持：只需要通过配置就可以完成对事务的管理，而无需手动编程。&lt;/li&gt;
&lt;li&gt;方便程序的测试：Spring 对 Junit4 支持，可以通过注解方便地测试 Spring 程序。&lt;/li&gt;
&lt;li&gt;方便集成各种优秀框架：Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis 等）的直接支持。&lt;/li&gt;
&lt;li&gt;降低 JavaEE API 的使用难度：Spring 对 JavaEE 开发中非常难用的一些 API（如 JDBC、JavaMail、远程调用等）都提供了封装，使这些 API 应用难度大大降低。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spring 框架的核心特性为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IoC 容器：Spring 通过控制反转实现了对象的创建和对象间的依赖关系管理，开发者只需要定义好 Bean 及其依赖关系，Spring 容器负责创建和组装这些对象。&lt;/li&gt;
&lt;li&gt;AOP：面向切面编程，允许开发者定义横切关注点，例如事务管理、安全控制等独立于业务逻辑的代码。通过 AOP，可以将这些关注点模块化，提高代码的可维护性和可重用性。&lt;/li&gt;
&lt;li&gt;事务管理：Spring 提供了一致的事务管理接口，支持声明式和编程式事务，开发者可以轻松地进行事务管理，而无需关心具体的事务 API。&lt;/li&gt;
&lt;li&gt;MVC 框架：Spring MVC 是一个基于 Servlet API 构建的 Web 框架，采用了模型-视图-控制器（MVC）架构。它支持灵活的 URL 到页面控制器的映射，以及多种视图技术。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-2-什么是-Spring-IoC-容器？&#34;&gt;1.2 什么是 Spring IoC 容器？&lt;/h3&gt;
&lt;p&gt;Spring IoC（Spring Inversion of Control）容器，是 Spring 框架的核心部分。IoC 即&lt;strong&gt;控制反转&lt;/strong&gt;，是一种设计思想，在 Java 开发中，IoC 意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。&lt;/p&gt;
&lt;p&gt;Spring IoC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。具体来说，Spring IoC 容器负责创建对象、管理对象（通过依赖注入）、装配对象、配置对象，并且管理这些对象的整个生命周期。&lt;/p&gt;
&lt;p&gt;使用 IoC 的目的，主要是为了降低类之间的耦合。通过控制反转，对象的创建和对象之间的依赖关系处理，交给 Spring 容器来管理，不用程序员自己创建和维护。这样，应用程序无需直接在代码中创建相关的对象，应用程序由 IoC 容器进行组装。这种方式不仅降低了类之间的耦合，也使得代码更加简洁，更易于测试和维护。&lt;/p&gt;
&lt;h3 id=&#34;1-3-什么是依赖注入？&#34;&gt;1.3 什么是依赖注入？&lt;/h3&gt;
&lt;p&gt;依赖注入（Dependency Injection，DI）是一种设计模式，也是 Spring 框架的核心概念之一。它的主要作用是去除 Java 类之间的依赖关系，实现松耦合，以便于开发测试。&lt;/p&gt;
&lt;p&gt;在传统的程序设计过程中，当某个角色（可能是一个 Java 实例，调用者）需要另一个角色（另一个 Java 实例，被调用者）的协助时，通常由调用者来创建被调用者的实例。这种方式会导致调用者与被调用者之间产生紧密的耦合关系，使得代码难以修改和测试。&lt;/p&gt;
&lt;p&gt;依赖注入的思想是，不在类内部直接创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给需要的类来使用。例如，&lt;code&gt;A&lt;/code&gt; 类要依赖 &lt;code&gt;B&lt;/code&gt; 类，&lt;code&gt;A&lt;/code&gt; 类不再直接创建 &lt;code&gt;B&lt;/code&gt; 类，而是把这种依赖关系配置在外部 XML（或 Java Config）文件中，然后由 Spring 容器根据配置信息创建、管理 &lt;code&gt;bean&lt;/code&gt; 类。&lt;/p&gt;
&lt;p&gt;这样，调用者不需要关心被调用者的创建和销毁，只需要关心如何使用被调用者，从而实现了调用者和被调用者之间的解耦。这种方式不仅降低了类之间的耦合，也使得代码更加简洁，更易于测试和维护。&lt;/p&gt;
&lt;p&gt;举一个例子，加入我们有一个接口和两个实现类：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MessageService&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    String &lt;span class=&#34;title function_&#34;&gt;getMessage&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;TextMessageService&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MessageService&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; String &lt;span class=&#34;title function_&#34;&gt;getMessage&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;quot;Text Message&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;EmailMessageService&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MessageService&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; String &lt;span class=&#34;title function_&#34;&gt;getMessage&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;quot;Email Message&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后，我们有一个使用 &lt;code&gt;MessageService&lt;/code&gt; 的 &lt;code&gt;MessagePrinter&lt;/code&gt; 类：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MessagePrinter&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; MessageService service;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 通过构造器注入依赖&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;MessagePrinter&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(MessageService service)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;built_in&#34;&gt;this&lt;/span&gt;.service = service;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;printMessage&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;built_in&#34;&gt;this&lt;/span&gt;.service.getMessage());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 Spring 的配置文件中，我们可以定义 &lt;code&gt;MessageService&lt;/code&gt; 和 &lt;code&gt;MessagePrinter&lt;/code&gt; 的 &lt;code&gt;bean&lt;/code&gt;，并通过构造器注入依赖：&lt;/p&gt;
&lt;figure class=&#34;highlight xml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;beans&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;bean&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;id&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;messageService&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;class&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;com.example.TextMessageService&amp;quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;bean&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;id&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;messagePrinter&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;class&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;com.example.MessagePrinter&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;constructor-arg&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;ref&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;messageService&amp;quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;beans&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;MessagePrinter&lt;/code&gt; 依赖于 &lt;code&gt;MessageService&lt;/code&gt;。通过 Spring IoC 容器和依赖注入，我们可以在外部配置文件中定义这种依赖关系，而不需要在 &lt;code&gt;MessagePrinter&lt;/code&gt; 类中硬编码依赖的实现类。这样，我们可以轻松地更改 &lt;code&gt;MessageService&lt;/code&gt; 的实现，而无需修改 &lt;code&gt;MessagePrinter&lt;/code&gt; 类的代码，这就是依赖注入的优势。&lt;/p&gt;
&lt;p&gt;如果我们运行 &lt;code&gt;MessagePrinter&lt;/code&gt; 的 &lt;code&gt;printMessage()&lt;/code&gt; 方法，它将打印出 &lt;code&gt;Text Message&lt;/code&gt;。这是因为我们在 Spring 的配置文件中将 &lt;code&gt;TextMessageService&lt;/code&gt; 定义为 &lt;code&gt;MessageService&lt;/code&gt; 的实现类，然后通过构造器注入的方式将其注入到了 &lt;code&gt;MessagePrinter&lt;/code&gt; 中。所以，当我们调用 &lt;code&gt;printMessage()&lt;/code&gt; 方法时，它会调用 &lt;code&gt;TextMessageService&lt;/code&gt; 的 &lt;code&gt;getMessage()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;总的来说，依赖注入是一种消除类之间依赖关系的设计模式，它使得对象之间的依赖关系更加清晰，代码更加灵活，更易于测试和维护。&lt;/p&gt;
&lt;h3 id=&#34;1-4-依赖注入有几种方式？&#34;&gt;1.4 依赖注入有几种方式？&lt;/h3&gt;
&lt;p&gt;在 Spring 中，有四种常见的依赖注入方式：&lt;/p&gt;
&lt;p&gt;（1）属性注入（Field Injection）：直接在需要注入的字段上使用 &lt;code&gt;@Autowired&lt;/code&gt; 或 &lt;code&gt;@Resource&lt;/code&gt; 等注解：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;UserService&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; UserMapper userMapper;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（2）Setter 注入（Setter Injection）：在 &lt;code&gt;setter&lt;/code&gt; 方法上使用 &lt;code&gt;@Autowired&lt;/code&gt; 或 &lt;code&gt;@Resource&lt;/code&gt; 等注解。在 SpringBoot 中，由于 WebSocket 的特殊性，它是由容器管理的，而不是由 Spring 管理的 Bean，每次 WebSocket 连接都会创建一个新的 WebSocket 实例（非单例模式），因此不能直接使用属性注入的方式来注入 WebSocket。假如我们要在 WebSocket 中使用 Mapper，那么我们就可以用 Setter 注入的方式：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Component&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@ServerEndpoint(value = &amp;quot;/websocket&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;WebSocketServer&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; UserMapper userMapper;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;setUserMapper&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(UserMapper userMapper)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        WebSocketServer.userMapper = userMapper;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（3）构造器注入（Constructor Injection）：在构造器上使用 &lt;code&gt;@Autowired&lt;/code&gt; 或 &lt;code&gt;@Resource&lt;/code&gt; 等注解：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;UserService&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; UserMapper userMapper;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;UserService&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(UserMapper userMapper)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;built_in&#34;&gt;this&lt;/span&gt;.userMapper = userMapper;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（4）静态工厂的方法注入：通过静态工厂方法创建 Bean，并在 Spring 配置文件中声明：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;BeanFactory&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; UserService &lt;span class=&#34;title function_&#34;&gt;createUserService&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;UserService&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 Spring 配置文件中声明：&lt;/p&gt;
&lt;figure class=&#34;highlight xml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;bean&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;id&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;userService&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;class&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;com.example.BeanFactory&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;factory-method&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;createUserService&amp;quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-5-如何理解-IoC-和-DI？&#34;&gt;1.5 如何理解 IoC 和 DI？&lt;/h3&gt;
&lt;p&gt;IoC（Inversion of Control，控制反转）和 DI（Dependency Injection，依赖注入）是 Spring 框架的核心概念，它们是面向对象编程的重要设计原则。IoC 和 DI 是同一个概念的不同角度描述，IoC 是一种设计思想，DI 是这种思想的一种实现方式。&lt;/p&gt;
&lt;p&gt;IoC 是一种设计思想，不是一种技术。在 Java 开发中，IoC 意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。这意味着，所有的类都会在 Spring 容器中登记，告诉 Spring 你是什么，你需要什么，然后 Spring 会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 Spring 来控制，也就是说控制对象生存周期的不再是引用它的对象，而是 Spring。&lt;/p&gt;
&lt;p&gt;DI 是 IoC 的一种实现方式。DI 是一种将调用者与被调用者分离的思想，组件之间的依赖关系由容器在运行时决定，形象的说，是由容器动态地将某个依赖关系注入到组件之中，这样你就可以使用 &lt;code&gt;@Autowired&lt;/code&gt;、&lt;code&gt;@Resource&lt;/code&gt; 等注解来实现自动注入。&lt;/p&gt;
&lt;h3 id=&#34;1-6-什么是-AOP？&#34;&gt;1.6 什么是 AOP？&lt;/h3&gt;
&lt;p&gt;AOP（Aspect Oriented Programming），即&lt;strong&gt;面向切面编程&lt;/strong&gt;，是一种通过预编译方式和运行期动态代理实现程序功能的统一维护的技术。它是 OOP（面向对象编程）的延续，也是 Spring 框架中的一个重要内容，是函数式编程的一种衍生范型。&lt;/p&gt;
&lt;p&gt;AOP 的主要目标是将业务处理逻辑与系统服务分离开来，然后通过声明性的方式将系统服务应用到业务处理逻辑中。简单来说，AOP 就是把我们程序重复的代码抽取出来，在需要执行的时候使用动态代理技术在不修改源码的基础上，对我们的已有方法进行增强。&lt;/p&gt;
&lt;p&gt;AOP 的主要术语包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;切面（Aspect）：切面是一个横切关注点的模块化，一个切面能够包含同一个类型的不同增强方法，比如说事务处理和日志处理可以理解为两个切面。&lt;/li&gt;
&lt;li&gt;连接点（JoinPoint）：程序执行过程中明确的点，如方法的调用或特定的异常被抛出。&lt;/li&gt;
&lt;li&gt;切入点（PointCut）：切入点是对连接点进行拦截的条件定义。&lt;/li&gt;
&lt;li&gt;通知（Advice）：通知是指拦截到连接点之后要执行的代码，包括了 &lt;code&gt;around&lt;/code&gt;、&lt;code&gt;before&lt;/code&gt; 和 &lt;code&gt;after&lt;/code&gt; 等不同类型的通知。&lt;/li&gt;
&lt;li&gt;目标对象（Target）：目标对象指将要被增强的对象，即包含主业务逻辑的类对象。&lt;/li&gt;
&lt;li&gt;织入（Weaving）：织入是将切面和业务逻辑对象连接起来，并创建通知代理的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-7-AOP-的实现方式有哪些？&#34;&gt;1.7 AOP 的实现方式有哪些？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;通过 Spring API 实现：这种方式的核心是通过编写增强类来继承 Spring API 提供的接口。例如，你可以编写业务接口和实现类，然后编写增强类，并实现 Spring API 相关接口的方法。然后在 &lt;code&gt;resource&lt;/code&gt; 目录下新建 &lt;code&gt;applicationContext&lt;/code&gt; 文件，实现 Java 类的创建和 AOP 的织入，最后编写测试类。&lt;/li&gt;
&lt;li&gt;通过自定义类来实现：这种方式比较推荐。你可以自定义切入类，然后在 Spring 中配置，最后编写测试类。&lt;/li&gt;
&lt;li&gt;使用注解实现：你可以自定义增强类（注解实现），然后在 Spring 配置文件中，注册 Bean，并增加支持注解的配置，最后编写测试类。&lt;/li&gt;
&lt;li&gt;使用 JDK 提供的代理方式：这种方式不依赖于 Spring。你可以使用 JDK 提供的代理方式来实现 AOP，包括静态和动态两种方式。&lt;/li&gt;
&lt;li&gt;使用 Spring 纯配置实现：你可以通过 Spring 的配置文件来实现 AOP。&lt;/li&gt;
&lt;li&gt;使用 Spring 注解：你可以通过 Spring 的注解来实现 AOP。&lt;/li&gt;
&lt;li&gt;动态代理和字节码增强：Spring AOP 的实现主要基于动态代理和字节码增强两种技术。动态代理是一种在运行时生成代理对象的技术，在代理对象中可以添加额外的逻辑，比如切面逻辑。Spring AOP 通过 JDK 动态代理和 CGLIB 动态代理两种方式实现代理对象的生成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-8-Spring-框架中用到了哪些设计模式？&#34;&gt;1.8 Spring 框架中用到了哪些设计模式？&lt;/h3&gt;
&lt;p&gt;（1）单例模式（Singleton）：Spring 中的 Bean 默认都是单例的，这就是单例模式的应用。例如：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;AppConfig&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; MyService &lt;span class=&#34;title function_&#34;&gt;myService&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyServiceImpl&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;myService&lt;/code&gt; Bean 在整个应用中只有一个实例。在单例模式中，Spring容器会确保每个由 &lt;code&gt;@Bean&lt;/code&gt; 注解定义的 Bean 在整个应用中只有一个实例。&lt;/p&gt;
&lt;p&gt;（2）工厂模式（Factory）：Spring 使用工厂模式通过 &lt;code&gt;BeanFactory&lt;/code&gt;、&lt;code&gt;ApplicationContext&lt;/code&gt; 来创建 Bean。同单例模式的示例代码所示，在这个例子中，&lt;code&gt;AppConfig&lt;/code&gt; 类就像一个工厂，&lt;code&gt;myService()&lt;/code&gt; 方法就是工厂方法，用来创建 &lt;code&gt;MyService&lt;/code&gt; 的实例。Spring 的 &lt;code&gt;@Bean&lt;/code&gt; 注解同时实现了这两种模式。&lt;/p&gt;
&lt;p&gt;（3）模板方法模式（Template Method）：Spring 的 &lt;code&gt;JdbcTemplate&lt;/code&gt; 和 &lt;code&gt;HibernateTemplate&lt;/code&gt; 等都是模板方法模式的应用。例如：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;JdbcTemplate&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;jdbcTemplate&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;JdbcTemplate&lt;/span&gt;(dataSource);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;jdbcTemplate.execute(&lt;span class=&#34;string&#34;&gt;&amp;quot;CREATE TABLE CUSTOMERS (ID INTEGER, NAME VARCHAR(100))&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（4）代理模式（Proxy）：Spring AOP 就是通过代理模式实现的。例如：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Aspect&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;LoggingAspect&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Before(&amp;quot;execution(* com.example.myapp.MyService.*(..))&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;logBefore&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(JoinPoint joinPoint)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Before method: &amp;quot;&lt;/span&gt; + joinPoint.getSignature());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;LoggingAspect&lt;/code&gt; 创建了一个代理，它在 &lt;code&gt;MyService&lt;/code&gt; 的所有方法执行前打印日志。&lt;/p&gt;
&lt;p&gt;（5）观察者模式（Observer）：Spring 事件处理就是观察者模式的一个例子。当一个事件被发布时，所有注册的监听器都会收到通知。例如：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyEventListener&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ApplicationListener&lt;/span&gt;&amp;lt;MyEvent&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;onApplicationEvent&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(MyEvent event)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Received: &amp;quot;&lt;/span&gt; + event.getData());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（6）包装器设计模式：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。&lt;/p&gt;
&lt;p&gt;（7）适配器模式：Spring AOP 的增强或通知（Advice）使用到了适配器模式、spring MVC 中也是用到了适配器模式适配 Controller。&lt;/p&gt;
&lt;h3 id=&#34;1-9-Spring-提供了哪些配置方式？&#34;&gt;1.9 Spring 提供了哪些配置方式？&lt;/h3&gt;
&lt;p&gt;Spring 提供了以下三种主要的配置方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 XML 的配置：在 Spring1.x 时代，都是基于 XML 来进行配置，用 XML 文件来管理 Bean 之间的关系。例如，你可以在 XML 文件中定义一个 Bean，然后在需要的地方引用这个 Bean。&lt;/li&gt;
&lt;li&gt;基于注解的配置：Spring2.5 以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代 XML 方式的 Bean 描述，可以将 Bean 描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。例如，你可以使用 &lt;code&gt;@Component&lt;/code&gt; 或其子类（&lt;code&gt;@Repository&lt;/code&gt;、&lt;code&gt;@Service&lt;/code&gt;、&lt;code&gt;@Controller&lt;/code&gt;）来定义 Bean。&lt;/li&gt;
&lt;li&gt;基于 Java API 的配置：Spring3.0 以后，提供了 Java 配置的能力，Spring4.x和SpringBoot都推荐使用Java配置2。例如，你可以使用@Configuration和@Bean注解来定义和配置bean12。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意 Spring 框架默认并不启用注解配置方式，你需要在配置文件中添加相应的配置才能启用注解配置方式：&lt;/p&gt;
&lt;figure class=&#34;highlight xml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;beans&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;&amp;lt;!-- 启用注解配置 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;context:annotation-config&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;&amp;lt;!-- 其他bean的定义 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;beans&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;context:annotation-config/&amp;gt;&lt;/code&gt; 是 Spring 框架中的一个 XML 配置元素，用于启用注解驱动的 Spring 容器。它会自动扫描 Spring 容器中的所有组件，包括 &lt;code&gt;@Service&lt;/code&gt;、&lt;code&gt;@Repository&lt;/code&gt;、&lt;code&gt;@Controller&lt;/code&gt;、&lt;code&gt;@Component&lt;/code&gt; 等注解标注的类，并将它们注册到 Spring 容器中。&lt;/p&gt;
&lt;p&gt;也可以使用 &lt;code&gt;&amp;lt;context:component-scan/&amp;gt;&lt;/code&gt;，如果使用了 &lt;code&gt;&amp;lt;context:component-scan/&amp;gt;&lt;/code&gt;，那么 &lt;code&gt;&amp;lt;context:annotation-config/&amp;gt;&lt;/code&gt; 就不再需要，因为 &lt;code&gt;&amp;lt;context:component-scan/&amp;gt;&lt;/code&gt; 除了具有 &lt;code&gt;&amp;lt;context:annotation-config/&amp;gt;&lt;/code&gt; 的功能之外，还可以在指定的 Package 下扫描以及注册 Java Bean。&lt;/p&gt;
&lt;h3 id=&#34;1-10-Spring-中的-Bean-是什么？&#34;&gt;1.10 Spring 中的 Bean 是什么？&lt;/h3&gt;
&lt;p&gt;在 Spring 中，构成应用程序主干并由 Spring IoC 容器管理的对象称为 Bean。Bean 是一个由 Spring IoC 容器实例化、组装和管理的对象，即 Spring 容器中存储的主要就是 Bean 对象。简而言之，Spring Bean 是 Spring 框架在运行时管理的对象，是任何 Spring 应用程序的基本构建块，我们编写的大多数应用程序逻辑代码都将放在 Spring Bean 中。Spring Bean 的管理包括：创建一个对象，提供依赖项（例如其他 Bean，配置属性），拦截对象方法调用以提供额外的框架功能，销毁一个对象。&lt;/p&gt;
&lt;h3 id=&#34;1-11-Bean-的作用域有哪些？&#34;&gt;1.11 Bean 的作用域有哪些？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;singleton&lt;/code&gt;：单例模式，在整个 Spring IoC 容器中，使用 &lt;code&gt;singleton&lt;/code&gt; 定义的 Bean 将只有一个实例。这是 Spring 的默认作用域。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prototype&lt;/code&gt;：原型模式，每次通过容器的 &lt;code&gt;getBean()&lt;/code&gt; 方法获取 &lt;code&gt;prototype&lt;/code&gt; 定义的 Bean 时，都将产生一个新的 Bean 实例。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;request&lt;/code&gt;：对于每次 HTTP 请求，使用 &lt;code&gt;request&lt;/code&gt; 定义的 Bean 都将产生一个新实例。只有在 Web 应用中使用 Spring 时，该作用域才有效。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;session&lt;/code&gt;：对于每次 HTTP Session，使用 &lt;code&gt;session&lt;/code&gt; 定义的 Bean 都将产生一个新实例。同样只有在 Web 应用中使用 Spring 时，该作用域才有效。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;application&lt;/code&gt;：限定一个 Bean 的作用域为 &lt;code&gt;ServletContext&lt;/code&gt; 的生命周期。该作用域仅适用于 Web 的 Spring WebApplicationContext 环境。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;globalSession&lt;/code&gt;：全局 Session 作用域，仅在基于 &lt;code&gt;portlet&lt;/code&gt; 的 Web 应用中才有意义，Spring5 已经没有了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Spring 配置文件中，可以通过标签的 &lt;code&gt;scope&lt;/code&gt; 属性来指定 Bean 的作用域。例如：&lt;/p&gt;
&lt;figure class=&#34;highlight xml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;bean&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;id&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;myBean&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;class&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;com.example.MyBeanClass&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;scope&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;singleton&amp;quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 Spring Boot 或基于 Java 的配置中，可以通过 &lt;code&gt;@Scope&lt;/code&gt; 注解来指定 Bean 的作用域。例如：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Scope(&amp;quot;prototype&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; MyBeanClass &lt;span class=&#34;title function_&#34;&gt;myBean&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyBeanClass&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-12-Bean-的生命周期有几个阶段？&#34;&gt;1.12 Bean 的生命周期有几个阶段？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;实例化（Instantiation）：Spring 根据配置文件或注解等方式创建 Bean 的实例。&lt;/li&gt;
&lt;li&gt;属性赋值（Populate）：Spring 将实例化后的 Bean 的属性值设置到对应的属性中。&lt;/li&gt;
&lt;li&gt;初始化（Initialization）：如果 Bean 实现了 &lt;code&gt;InitializingBean&lt;/code&gt; 接口或在配置文件中通过 &lt;code&gt;init-method&lt;/code&gt; 指定了初始化方法，则在 Bean 初始化完成后调用该方法。&lt;/li&gt;
&lt;li&gt;销毁（Destruction）：如果 Bean 实现了 &lt;code&gt;DisposableBean&lt;/code&gt; 接口或在配置文件中通过 &lt;code&gt;destroy-method&lt;/code&gt; 指定了销毁方法，则在容器关闭时会调用该方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-13-详细讲一下-Bean-的生命周期是什么？&#34;&gt;1.13 详细讲一下 Bean 的生命周期是什么？&lt;/h3&gt;
&lt;p&gt;Spring Bean 的生命周期是指一个 Bean 从被创建、初始化、使用到最终被销毁的整个过程。Spring 容器（&lt;code&gt;ApplicationContext&lt;/code&gt; 或 &lt;code&gt;BeanFactory&lt;/code&gt;）负责管理这个生命周期。&lt;/p&gt;
&lt;p&gt;Spring Bean 生命周期的详细阶段如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Bean 定义加载与解析：Spring 容器启动时（如 &lt;code&gt;ApplicationContext.refresh()&lt;/code&gt;），读取配置文件，将配置信息解析为内部的 &lt;code&gt;BeanDefinition&lt;/code&gt; 对象，存储在 &lt;code&gt;BeanFactory&lt;/code&gt; 的注册表中，&lt;code&gt;BeanDefinition&lt;/code&gt; 包含了创建 Bean 所需的所有元数据（类名、作用域、初始化/销毁方法名、属性值、构造函数参数等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实例化（Instantiation）：容器根据 &lt;code&gt;BeanDefinition&lt;/code&gt; 的信息，创建 Bean 的实例。通常通过反射调用构造函数（&lt;code&gt;Class.newInstance()&lt;/code&gt; 或 &lt;code&gt;Constructor.newInstance()&lt;/code&gt;）来完成。对于工厂方法创建的 Bean，则调用指定的静态工厂方法或实例工厂方法。此时 Bean 只是一个“空壳”，属性未被设置，依赖未被注入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;属性赋值/依赖注入（Population of Properties）：容器根据 &lt;code&gt;BeanDefinition&lt;/code&gt; 中的配置，为 Bean 实例设置属性值，包括注入其他 Bean 的引用（&lt;code&gt;@Autowired&lt;/code&gt;、&lt;code&gt;@Resource&lt;/code&gt;、&lt;code&gt;@Inject&lt;/code&gt;），注入基本类型或 String 等值，注入集合（&lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;、&lt;code&gt;Map&lt;/code&gt;、&lt;code&gt;Properties&lt;/code&gt;），解析和注入 &lt;code&gt;@Autowired&lt;/code&gt; 标注的字段、Setter 方法或构造函数参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bean 后置处理器（&lt;code&gt;BeanPostProcessor&lt;/code&gt;）- 初始化前（&lt;code&gt;postProcessBeforeInitialization&lt;/code&gt;）：如果容器中注册了实现了 &lt;code&gt;BeanPostProcessor&lt;/code&gt; 接口的 Bean，容器会在每个 Bean 初始化之前调用其 &lt;code&gt;postProcessBeforeInitialization(Object bean, String beanName)&lt;/code&gt; 方法，作用是在 Bean 初始化之前对 Bean 实例进行修改或包装（例如生成代理对象，如 AOP 代理通常在此阶段生成）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化（Initialization）：经过前置处理后，Bean 进入初始化阶段，容器会调用 Bean 上定义的初始化回调方法，作用是执行 Bean 创建后、使用前的自定义初始化逻辑，例如：建立数据库连接池、加载配置文件、验证依赖注入是否完整、启动后台线程、执行复杂的数据结构初始化。这些方法按固定顺序执行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@PostConstruct&lt;/code&gt; 注解方法：由 JSR-250 规范定义。这是最常用、最推荐的方式。方法上标注 &lt;code&gt;@PostConstruct&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;InitializingBean.afterPropertiesSet()&lt;/code&gt;：Spring 特定接口。Bean 实现 &lt;code&gt;InitializingBean&lt;/code&gt; 接口并覆写 &lt;code&gt;afterPropertiesSet()&lt;/code&gt; 方法。不推荐使用，因为它将代码与 Spring 接口耦合。&lt;/li&gt;
&lt;li&gt;自定义 &lt;code&gt;init-method&lt;/code&gt;：在配置中指定的方法（XML 的 &lt;code&gt;init-method&lt;/code&gt; 属性，Java Config 的 &lt;code&gt;@Bean(initMethod = &amp;quot;myInit&amp;quot;)&lt;/code&gt;）。方法签名通常是 &lt;code&gt;void xxx()&lt;/code&gt; 无参方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bean 后置处理器（&lt;code&gt;BeanPostProcessor&lt;/code&gt;）- 初始化后（&lt;code&gt;postProcessAfterInitialization&lt;/code&gt;）：在 Bean 执行完自身的初始化方法后，容器会调用所有 &lt;code&gt;BeanPostProcessor&lt;/code&gt; 的 &lt;code&gt;postProcessAfterInitialization(Object bean, String beanName)&lt;/code&gt; 方法，作用是在 Bean 初始化之后对 Bean 实例进行最终的修改或增强，很多 Spring 的高级功能（如 AOP 的最终代理包装）在此阶段完成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bean 就绪（Ready for Use）：此时，Bean 已经完成了创建、依赖注入、初始化和所有后处理，完全初始化完毕，驻留在 Spring 容器（通常是单例池 &lt;code&gt;singletonObjects&lt;/code&gt;）中，应用程序可以通过 &lt;code&gt;getBean()&lt;/code&gt; 方法或依赖注入的方式获取并使用这个 Bean。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;销毁（Destruction）：当容器关闭时（例如调用 &lt;code&gt;ApplicationContext.close()&lt;/code&gt; 或在 Web 应用中容器关闭），对于作用域为 &lt;code&gt;singleton&lt;/code&gt; 且实现了销毁回调的 Bean，容器会触发销毁过程，作用是执行 Bean 销毁前的自定义清理逻辑，例如：关闭数据库连接池，释放连接、停止后台线程、保存状态到文件、释放文件句柄以及网络连接等资源。销毁回调的执行顺序与初始化相反：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@PreDestroy&lt;/code&gt; 注解方法：JSR-250 规范定义。最常用、最推荐。方法上标注 &lt;code&gt;@PreDestroy&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DisposableBean.destroy()&lt;/code&gt;：Spring 特定接口。Bean 实现 &lt;code&gt;DisposableBean&lt;/code&gt; 并覆写 &lt;code&gt;destroy()&lt;/code&gt; 方法。不推荐使用（耦合）。&lt;/li&gt;
&lt;li&gt;自定义 &lt;code&gt;destroy-method&lt;/code&gt;：配置中指定的方法（XML 的 &lt;code&gt;destroy-method&lt;/code&gt; 属性，Java Config 的 &lt;code&gt;@Bean(destroyMethod = &amp;quot;myDestroy&amp;quot;)&lt;/code&gt;）。方法签名通常是 &lt;code&gt;void xxx()&lt;/code&gt; 无参方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-14-Bean-加载-销毁前后，如果想实现某些逻辑，可以怎么做？&#34;&gt;1.14 Bean 加载/销毁前后，如果想实现某些逻辑，可以怎么做？&lt;/h3&gt;
&lt;p&gt;在 Spring 框架中，如果希望在 Bean 加载（即实例化、属性赋值、初始化等过程完成后）或销毁前后执行某些逻辑，可以使用 Spring 的生命周期回调接口或注解。这些接口和注解允许你定义在 Bean 生命周期的关键点执行的代码。&lt;/p&gt;
&lt;p&gt;（1）使用 &lt;code&gt;init-method&lt;/code&gt; 和 &lt;code&gt;destroy-method&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;在 XML 配置中，你可以通过 &lt;code&gt;init-method&lt;/code&gt; 和 &lt;code&gt;destroy-method&lt;/code&gt; 属性来指定 Bean 初始化后和销毁前需要调用的方法：&lt;/p&gt;
&lt;figure class=&#34;highlight xml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;bean&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;id&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;myBean&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;class&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;com.example.MyBeanClass&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;init-method&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;init&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;destroy-method&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;destroy&amp;quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后，在你的 Bean 类中实现这些方法：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyBeanClass&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 初始化逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;destroy&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 销毀逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（2）实现 &lt;code&gt;InitializingBean&lt;/code&gt; 和 &lt;code&gt;DisposableBean&lt;/code&gt; 接口：&lt;/p&gt;
&lt;p&gt;Bean 类可以实现 &lt;code&gt;org.springframework.beans.factory.InitializingBean&lt;/code&gt; 和 &lt;code&gt;org.springframework.beans.factory.DisposableBean&lt;/code&gt; 接口，并分别实现 &lt;code&gt;afterPropertiesSet()&lt;/code&gt; 和 &lt;code&gt;destroy()&lt;/code&gt; 方法：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.springframework.beans.factory.DisposableBean;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; org.springframework.beans.factory.InitializingBean;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyBeanClass&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;InitializingBean&lt;/span&gt;, DisposableBean &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;afterPropertiesSet&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;throws&lt;/span&gt; Exception &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 初始化逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;destroy&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;throws&lt;/span&gt; Exception &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 销毀逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（3）使用 &lt;code&gt;@PostConstruct&lt;/code&gt; 和 &lt;code&gt;@PreDestroy&lt;/code&gt; 注解：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; javax.annotation.PostConstruct;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; javax.annotation.PreDestroy;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyBeanClass&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@PostConstruct&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 初始化逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@PreDestroy&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;destroy&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 销毀逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（4）使用 &lt;code&gt;@Bean&lt;/code&gt; 注解的 &lt;code&gt;initMethod&lt;/code&gt; 和 &lt;code&gt;destroyMethod&lt;/code&gt; 属性：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;AppConfig&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Bean(initMethod = &amp;quot;init&amp;quot;, destroyMethod = &amp;quot;destroy&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; MyBeanClass &lt;span class=&#34;title function_&#34;&gt;myBean&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyBeanClass&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-15-BeanFactory-和-ApplicationContext-有什么区别？&#34;&gt;1.15 BeanFactory 和 ApplicationContext 有什么区别？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;BeanFactory&lt;/code&gt; 和 &lt;code&gt;ApplicationContext&lt;/code&gt; 都是 Spring 框架中用于创建和管理 Bean 的容器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BeanFactory&lt;/code&gt; 是 Spring 框架的最基本的容器，它是 Spring 的核心部分。&lt;code&gt;BeanFactory&lt;/code&gt; 通过一个配置文件来管理和创建 Bean。&lt;code&gt;BeanFactory&lt;/code&gt; 中的 Bean 是懒加载的，也就是说只有在调用 &lt;code&gt;getBean()&lt;/code&gt; 方法去请求某个 Bean 时才会创建实例，这样可以提高程序的性能和启动速度，帮助我们节省资源。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ApplicationContext&lt;/code&gt; 是 &lt;code&gt;BeanFactory&lt;/code&gt; 的子接口，它是一个更加强大的容器。&lt;code&gt;ApplicationContext&lt;/code&gt; 可以像 &lt;code&gt;BeanFactory&lt;/code&gt; 一样创建和管理 Bean，但是它还可以提供其他的功能，比如支持国际化、事件传播、资源加载等。&lt;code&gt;ApplicationContext&lt;/code&gt; 是在程序启动时就将所有的 Bean 全部实例化，因此在程序运行时可以直接获取已经创建好的 Bean，从而提高了程序的响应速度。&lt;/p&gt;
&lt;h3 id=&#34;1-16-什么是-Spring-事务管理模型？&#34;&gt;1.16 什么是 Spring 事务管理模型？&lt;/h3&gt;
&lt;p&gt;Spring 事务是 Spring 框架提供的一个核心功能，旨在简化在 Java 应用中管理&lt;strong&gt;数据库事务&lt;/strong&gt;（以及扩展到其他支持事务的资源）的复杂性。它提供了一套声明式和编程式的事务管理模型，将事务管理逻辑从业务代码中分离出来，使开发者能更专注于核心业务逻辑。&lt;/p&gt;
&lt;p&gt;事务（Transaction）是指一组数据库操作（如多个 SQL 语句）被视为一个单一的工作单元。这些操作要么全部成功提交（Commit），要么全部失败回滚（Rollback），这是保证数据一致性和完整性的关键机制。其具有 ACID 特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A（原子性，Atomicity）：事务是&lt;strong&gt;不可分割&lt;/strong&gt;的最小单元，要么全部执行，要么全部不执行。&lt;/li&gt;
&lt;li&gt;C（一致性，Consistency）：事务将数据库从一个&lt;strong&gt;一致&lt;/strong&gt;状态转换到另一个&lt;strong&gt;一致&lt;/strong&gt;状态。&lt;/li&gt;
&lt;li&gt;I（隔离性，Isolation）：并发执行的事务之间应该&lt;strong&gt;相互隔离&lt;/strong&gt;，防止互相干扰。&lt;/li&gt;
&lt;li&gt;D（持久性，Durability）：一旦事务提交，它对数据库的改变就是&lt;strong&gt;永久性&lt;/strong&gt;的，即使系统故障也不会丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spring 提供两种主要的事务管理方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编程式事务管理（Programmatic Transaction Management）：开发者直接在代码中通过 Spring 提供的 API 显式控制事务的边界（开始、提交、回滚）。优点为精细控制，事务边界清晰可见，缺点为事务管理代码侵入业务代码，代码重复度高，维护性稍差，适用于需要非常精细控制事务边界，或者声明式事务无法满足特定需求的情况。实现方式如下：
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;TransactionTemplate&lt;/code&gt;：这是最常用的编程方式。它封装了事务管理的样板代码（try-catch-finally），开发者只需在 &lt;code&gt;execute()&lt;/code&gt; 方法内部实现需要事务的业务逻辑（通过 &lt;code&gt;TransactionCallback&lt;/code&gt; 或 Lambda 表达式）。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;PlatformTransactionManager&lt;/code&gt;：直接调用 &lt;code&gt;getTransaction()&lt;/code&gt;、&lt;code&gt;commit()&lt;/code&gt;、&lt;code&gt;rollback()&lt;/code&gt; 方法，更底层，更灵活，但也更繁琐。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;声明式事务管理（Declarative Transaction Management）：这是 Spring 推荐且最常用的方式，开发者通过配置（注解或 XML）来声明哪些方法（或类）需要事务支持以及事务的属性（传播行为、隔离级别等）。事务管理的具体操作（开启、提交、回滚）由 Spring 框架在运行时（通常基于 AOP 代理）自动完成。其具有非侵入性、事务管理与业务逻辑分离、配置灵活、易于维护、减少样板代码等优点，适用于绝大多数需要事务管理的情况，实现方式如下：
&lt;ul&gt;
&lt;li&gt;基于 &lt;code&gt;@Transactional&lt;/code&gt; 注解：将注解标注在方法或类上，标注在类上表示该类的所有 &lt;code&gt;public&lt;/code&gt; 方法都应用该事务属性，方法上的注解会覆盖类上的注解，可以在注解中指定 &lt;code&gt;propagation&lt;/code&gt;、&lt;code&gt;isolation&lt;/code&gt;、&lt;code&gt;timeout&lt;/code&gt;、&lt;code&gt;readOnly&lt;/code&gt;、&lt;code&gt;rollbackFor&lt;/code&gt;、&lt;code&gt;noRollbackFor&lt;/code&gt; 等属性。需要注意的是 &lt;code&gt;@Transactional&lt;/code&gt; 生效依赖于 AOP 代理。这意味着调用必须是通过代理对象进行的（从 Spring 容器中获取的 Bean 已经是代理对象）。&lt;/li&gt;
&lt;li&gt;基于 XML 配置（&lt;code&gt;&amp;lt;tx:advice&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;aop:config&amp;gt;&lt;/code&gt;）：在 XML 文件中定义事务通知（&lt;code&gt;&amp;lt;tx:advice&amp;gt;&lt;/code&gt;）并配置其属性（传播行为等），使用 AOP 切面配置（&lt;code&gt;&amp;lt;aop:config&amp;gt;&lt;/code&gt;）将事务通知织入到指定的方法（通常通过切入点表达式 &lt;code&gt;pointcut&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-17-Spring-的事务什么情况下会失效？&#34;&gt;1.17 Spring 的事务什么情况下会失效？&lt;/h3&gt;
&lt;p&gt;Spring Boot 通过 Spring 框架的事务管理模块来支持事务操作。事务管理在 Spring Boot 中通常是通过 &lt;code&gt;@Transactional&lt;/code&gt; 注解来实现的。事务可能会失效的一些常见情况包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;未捕获异常：如果一个事务方法中发生了未捕获的异常，并且异常未被处理或传播到事务边界之外，那么事务会失效，所有的数据库操作会回滚。&lt;/li&gt;
&lt;li&gt;非受检异常：Spring 默认只在抛出 &lt;code&gt;RuntimeException&lt;/code&gt; 及其子类或 &lt;code&gt;Error&lt;/code&gt; 时回滚事务。如果方法抛出的是检查型异常（Checked Exception，如 &lt;code&gt;IOException&lt;/code&gt;、&lt;code&gt;SQLException&lt;/code&gt;）或其自定义非运行时异常，事务默认会提交！&lt;/li&gt;
&lt;li&gt;事务传播属性设置不当：如果在多个事务之间存在事务嵌套，且事务传播属性配置不正确，可能导致事务失效。特别是在方法内部调用有 &lt;code&gt;@Transactional&lt;/code&gt; 注解的方法时要特别注意。&lt;/li&gt;
&lt;li&gt;多数据源的事务管理：如果在使用多数据源时，事务管理没有正确配置或者存在多个 &lt;code&gt;@Transactional&lt;/code&gt; 注解时，可能会导致事务失效。&lt;/li&gt;
&lt;li&gt;跨方法调用事务问题：如果一个事务方法内部调用另一个方法，而这个被调用的方法没有 &lt;code&gt;@Transactional&lt;/code&gt; 注解，这种情况下外层事务可能会失效。&lt;/li&gt;
&lt;li&gt;事务在非公开方法中失效：Spring 的事务管理（基于 AOP 代理或 AspectJ）默认只对 &lt;code&gt;public&lt;/code&gt; 方法生效，如果 &lt;code&gt;@Transactional&lt;/code&gt; 注解标注在私有方法上或者非 &lt;code&gt;public&lt;/code&gt; 方法上，事务也会失效。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-18-Spring-的事务，使用-this-调用是否生效？&#34;&gt;1.18 Spring 的事务，使用 this 调用是否生效？&lt;/h3&gt;
&lt;p&gt;在 Spring 中使用 &lt;code&gt;this&lt;/code&gt; 关键字调用同一个类中的 &lt;code&gt;@Transactional&lt;/code&gt; 方法，事务是&lt;strong&gt;不会生效&lt;/strong&gt;的，这是 Spring 事务失效最常见的原因之一，被称为&lt;strong&gt;自调用&lt;/strong&gt;问题。&lt;/p&gt;
&lt;p&gt;Spring 的声明式事务管理 &lt;code&gt;@Transactional&lt;/code&gt; 是通过 AOP（面向切面编程）实现的。当你在一个 Bean 上标注 &lt;code&gt;@Transactional&lt;/code&gt; 时，Spring 容器会为该 Bean 创建一个&lt;strong&gt;代理对象&lt;/strong&gt;（JDK 动态代理或 CGLIB 代理）。当外部代码（其他 Bean 的代码）调用这个 Bean 的事务方法时，实际上是调用了代理对象的方法。代理对象在调用目标方法（你写的原始方法）之前和之后，会插入事务管理的逻辑（开启事务、提交/回滚事务）。&lt;/p&gt;
&lt;p&gt;当你在同一个 Bean 的一个非事务方法 &lt;code&gt;A()&lt;/code&gt; 中，使用 &lt;code&gt;this.事务方法B()&lt;/code&gt; 来调用本 Bean 的事务方法 &lt;code&gt;B()&lt;/code&gt; 时，&lt;code&gt;A()&lt;/code&gt; 在被调用时，确实是代理对象在拦截执行（如果 &lt;code&gt;A()&lt;/code&gt; 本身有事务，事务会生效）。但在 &lt;code&gt;A()&lt;/code&gt; 方法体内部，&lt;code&gt;this&lt;/code&gt; 关键字指向的是目标对象本身（即你写的原始 Bean 实例），而不是 Spring 创建的代理对象。所以 &lt;code&gt;this.B()&lt;/code&gt; 这个调用是直接发生在目标对象内部，&lt;strong&gt;完全绕过了代理对象&lt;/strong&gt;。代理对象的事务拦截逻辑（&lt;code&gt;TransactionInterceptor&lt;/code&gt;）根本没有机会介入到 &lt;code&gt;B()&lt;/code&gt; 的调用过程中。&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;OrderService&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; OrderRepository orderRepository;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 非事务方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;placeOrder&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(Order order)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// ... 一些业务逻辑 ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 自调用事务方法 - 事务会失效！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;built_in&#34;&gt;this&lt;/span&gt;.deductInventory(order.getProductId(), order.getQuantity());  &lt;span class=&#34;comment&#34;&gt;// 使用 this 调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// ... 其他逻辑 ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 事务方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Transactional&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;deductInventory&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(Long productId, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; quantity)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 更新库存 - 期望在事务中执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        productInventoryRepository.reduceStock(productId, quantity);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 如果这里发生异常，期望事务回滚，库存恢复&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如何解决自调用导致的事务失效呢？首选且推荐的最佳实践是将事务方法抽取到另一个独立的 Spring Bean 中，然后通过依赖注入进行调用。将需要事务管理的方法 &lt;code&gt;B()&lt;/code&gt; 移动到另一个 Service 类中（例如 &lt;code&gt;InventoryService&lt;/code&gt;），在原来的 Service（&lt;code&gt;OrderService&lt;/code&gt;）中注入这个新的 &lt;code&gt;InventoryService&lt;/code&gt;，然后在 &lt;code&gt;A()&lt;/code&gt; 方法中调用 &lt;code&gt;inventoryService.deductInventory(...)&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;InventoryService&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Transactional&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;deductInventory&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(Long productId, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; quantity)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// ... 事务性库存扣减 ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;OrderService&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; InventoryService inventoryService;  &lt;span class=&#34;comment&#34;&gt;// 注入新 Bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;placeOrder&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(Order order)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        inventoryService.deductInventory(order.getProductId(), order.getQuantity());  &lt;span class=&#34;comment&#34;&gt;// 调用其他Bean的方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为 &lt;code&gt;inventoryService&lt;/code&gt; 是另一个 Spring Bean，对它方法的调用必然通过其代理对象，事务拦截器就能正常工作。&lt;/p&gt;
&lt;h2 id=&#34;2-Spring-MVC&#34;&gt;2. Spring MVC&lt;/h2&gt;
&lt;h3 id=&#34;2-1-什么是-Spring-MVC？工作原理是什么？&#34;&gt;2.1 什么是 Spring MVC？工作原理是什么？&lt;/h3&gt;
&lt;p&gt;Spring MVC 是 Spring 框架的一部分，它是一个基于 Java 的全功能 MVC Web 应用程序框架。MVC（Model-View-Controller）代表模型-视图-控制器，这是一种&lt;strong&gt;设计模式&lt;/strong&gt;，用于将应用程序的数据访问、用户界面和业务逻辑分离开来。MVC 具体介绍如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;视图（View）：为用户提供使用界面，与用户直接进行交互。&lt;/li&gt;
&lt;li&gt;模型（Model）：代表一个存取数据的对象或 Java POJO（Plain Old Java Object，简单 Java 对象）。它也可以带有逻辑，主要用于承载数据，并对用户提交请求进行计算的模块。模型分为两类，一类称为数据承载 Bean，一类称为业务处理 Bean。所谓数据承载 Bean 是指实体类（如 &lt;code&gt;User&lt;/code&gt; 类），专门为用户承载业务数据的；而业务处理 Bean 则是指 Service 或 Dao 对象，专门用于处理用户提交请求的。&lt;/li&gt;
&lt;li&gt;控制器（controller）：用于将用户请求转发给相应的 Model 进行处理，并根据 Model 的计算结果向用户提供相应响应，它使视图与模型分离。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Spring MVC 的工作原理如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户发送请求：用户通过浏览器发送一个 HTTP 请求，直接请求到 &lt;code&gt;DispatcherServlet&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;（前端控制器）：请求被 Spring MVC 的 &lt;code&gt;DispatcherServlet&lt;/code&gt; 捕获。&lt;code&gt;DispatcherServlet&lt;/code&gt; 的作用类似于一个中央处理器，它会负责调用其他组件来处理请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HandlerMapping&lt;/code&gt;（控制器映射器）：&lt;code&gt;DispatcherServlet&lt;/code&gt; 会调用 &lt;code&gt;HandlerMapping&lt;/code&gt; 解析请求对应的 &lt;code&gt;Handler&lt;/code&gt;，即找出处理这个请求的 &lt;code&gt;Controller&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Controller&lt;/code&gt;（控制器）：找到合适的 &lt;code&gt;Controller&lt;/code&gt; 后，&lt;code&gt;DispatcherServlet&lt;/code&gt; 会将请求交给它。&lt;code&gt;Controller&lt;/code&gt; 是真正处理请求的地方，它会处理用户的请求，并返回一个 &lt;code&gt;ModelAndView&lt;/code&gt; 对象。&lt;code&gt;ModelAndView&lt;/code&gt; 包含了模型（Model）数据和视图（View）名称。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ViewResolver&lt;/code&gt;（视图解析器）：&lt;code&gt;DispatcherServlet&lt;/code&gt; 会把 &lt;code&gt;ModelAndView&lt;/code&gt; 对象传给 &lt;code&gt;ViewResolver&lt;/code&gt;。&lt;code&gt;ViewResolver&lt;/code&gt; 会根据视图名称解析出真正的视图。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;View&lt;/code&gt;（视图）：最后，&lt;code&gt;DispatcherServlet&lt;/code&gt; 会渲染视图，并把模型数据填充进去。这个视图就是最终呈现给用户的页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-2-介绍一下-Spring-MVC-的核心组件&#34;&gt;2.2 介绍一下 Spring MVC 的核心组件&lt;/h3&gt;
&lt;p&gt;Spring MVC 的核心组件主要包括以下几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;（前端控制器）：这是 Spring MVC 框架的核心，负责将请求路由到其他组件。它处理所有的 HTTP 请求和响应。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HandlerMapping&lt;/code&gt;（控制器映射器）：它的任务是根据请求的 URL 找到正确的 &lt;code&gt;Controller&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Controller&lt;/code&gt;（控制器）：这是应用程序的实际控制器，负责处理用户请求并返回一个模型和视图。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HandlerAdapter&lt;/code&gt;（控制器适配器）：它负责调用 &lt;code&gt;Controller&lt;/code&gt; 中的方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ViewResolver&lt;/code&gt;（视图解析器）：它负责解析视图名并返回一个具体的视图对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;View&lt;/code&gt;（视图）：这是最终呈现给用户的页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，Spring MVC 还有一些其他的组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HandlerExceptionResolver&lt;/code&gt;（处理器异常解析器）：它负责处理在 &lt;code&gt;Controller&lt;/code&gt; 执行过程中抛出的异常。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LocaleResolver&lt;/code&gt;（区域解析器）：它用于确定用户的区域，这对于国际化和本地化非常重要。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MultipartResolver&lt;/code&gt;（多部分解析器）：它用于处理 &lt;code&gt;multipart&lt;/code&gt; 请求，例如文件上传。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThemeResolver&lt;/code&gt;（主题解析器）：它用于确定应用程序的主题，这对于个性化布局非常有用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RequestToViewNameTranslator&lt;/code&gt;（请求到视图名转换器）：它用于在 &lt;code&gt;Controller&lt;/code&gt; 没有明确返回视图名时，提供一个默认的视图名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FlashMapManager&lt;/code&gt;（Flash 映射管理器）：它用于存储和检索 FlashMap 模型，FlashMap 模型用于在重定向场景中存储属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-3-HandlerMapping-和-HandlerAdapter-有了解吗？&#34;&gt;2.3 HandlerMapping 和 HandlerAdapter 有了解吗？&lt;/h3&gt;
&lt;p&gt;（1）HandlerMapping&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用：HandlerMapping 负责将请求映射到控制器（Controller）。&lt;/li&gt;
&lt;li&gt;功能：根据请求的 URL、请求参数等信息，找到处理请求的控制器。&lt;/li&gt;
&lt;li&gt;类型：Spring 提供了多种 HandlerMapping 实现，如 BeanNameUrlHandlerMapping、&lt;br&gt;
RequestMappingHandlerMapping 等。&lt;/li&gt;
&lt;li&gt;工作流程：根据请求信息确定要请求的控制器。HandlerMapping 可以根据 URL、请求参数等规则确定对应的控制器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）HandlerAdapter&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用：HandlerAdapter 负责调用控制器来处理请求。&lt;/li&gt;
&lt;li&gt;功能：控制器可能有不同的接口类型（Controller 接口、HttpRequestHandler 接口等），HandlerAdapter 根据接口类型来选择合适的方法调用控制器。&lt;/li&gt;
&lt;li&gt;类型：Spring 提供了多个 HandlerAdapter 实现，用于适配不同类型的控制器。&lt;/li&gt;
&lt;li&gt;工作流程：根据控制器的接口类型，选择相应的 HandlerAdapter 来调用控制器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（3）工作流程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当客户端发送请求时，HandlerMapping 根据请求信息找到对应的控制器。&lt;/li&gt;
&lt;li&gt;HandlerAdapter 根据控制器接口的类型选择合适的方法来调用控制器。&lt;/li&gt;
&lt;li&gt;控制器执行相应的业务逻辑，生成 ModelAndView。&lt;/li&gt;
&lt;li&gt;HandlerAdapter 将控制器的执行结果包装成 ModelAndView。&lt;/li&gt;
&lt;li&gt;视图解析器根据 ModelAndView 找到对应的视图（View）进行渲染。&lt;/li&gt;
&lt;li&gt;将渲染后的视图返回给客户端。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;HandlerMapping 和 HandlerAdapter 协同工作，通过将请求映射到控制器，并调用控制器来处理请求，实现了请求处理的流程。它们的灵活性使得在 Spring MVC 中可以支持多种处理器和处理方式，提高了框架的扩展性和适应性。&lt;/p&gt;
&lt;h2 id=&#34;3-Spring-注解&#34;&gt;3. Spring 注解&lt;/h2&gt;
&lt;h3 id=&#34;3-1-Spring-中常用的注解有哪些？&#34;&gt;3.1 Spring 中常用的注解有哪些？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Component&lt;/code&gt;：标注一个普通的 Spring Bean 类，当一个类被 &lt;code&gt;@Component&lt;/code&gt; 注解标记时，Spring 会将其实例化为一个 Bean，并将其添加到 Spring 容器中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Configuration&lt;/code&gt;：用于标记一个类作为 Spring 的配置类。配置类可以包含 &lt;code&gt;@Bean&lt;/code&gt; 注解的方法，用于定义和配置 Bean，作为全局配置：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyConfiguration&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; MyBean &lt;span class=&#34;title function_&#34;&gt;myBean&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyBean&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Controller&lt;/code&gt;：标注一个控制器组件类，它是 &lt;code&gt;@Component&lt;/code&gt; 注解的特例，用于标记控制层的 Bean。这是 MVC 结构的另一个部分，加在控制层：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Controller&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyController&lt;/span&gt; &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Bean&lt;/code&gt;：用于标记一个方法作为 Spring 的 Bean 工厂方法。当一个方法被 &lt;code&gt;@Bean&lt;/code&gt; 注解标记时，Spring 会将该方法的返回值作为一个 Bean，并将其添加到 Spring 容器中，如果自定义配置，经常用到这个注解。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Service&lt;/code&gt;：标注一个业务逻辑层组件类，它也是 &lt;code&gt;@Component&lt;/code&gt; 注解的特例，用于标记服务层的 Bean，一般标记在业务 Service 的实现类：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyServiceImpl&lt;/span&gt; &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Repository&lt;/code&gt;：标注一个数据访问层组件类，它也是 &lt;code&gt;@Component&lt;/code&gt; 注解的特例，用于标记数据访问层的 Bean。这个注解很容易被忽略，导致数据库无法访问。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Autowired&lt;/code&gt;：由 Spring 提供的注解，用于自动装配 Bean，当 Spring 容器中存在与要注入的属性类型匹配的 Bean 时，它会自动将 Bean 注入到属性中。就跟我们 &lt;code&gt;new&lt;/code&gt; 对象一样：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Component&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyService&lt;/span&gt; &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Component&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyController&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Autowired&lt;/span&gt;  &lt;span class=&#34;comment&#34;&gt;// Spring会自动将MyService类型的Bean注入到myService属性中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; MyService myService;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@RequestMapping&lt;/code&gt;：用于映射 Web 请求，包括访问路径和参数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ResponseBody&lt;/code&gt;：支持将返回值放在 &lt;code&gt;response&lt;/code&gt; 内，而不是一个页面，通常用户返回 JSON 数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@RestController&lt;/code&gt;：该注解为一个组合注解，相当于 &lt;code&gt;@Controller&lt;/code&gt; 和 &lt;code&gt;@ResponseBody&lt;/code&gt; 的组合，注解在类上，意味着，该 &lt;code&gt;Controller&lt;/code&gt; 的所有方法都默认加上了 &lt;code&gt;@ResponseBody&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ExceptionHandler&lt;/code&gt;：用于全局处理控制器里的异常。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PathVariable&lt;/code&gt;：用于接收路径参数，比如 &lt;code&gt;@RequestMapping(&amp;quot;/hello/&amp;#123;name&amp;#125;&amp;quot;)&lt;/code&gt; 申明的路径，将注解放在参数中前，即可获取该路径的 &lt;code&gt;name&lt;/code&gt; 值，通常作为 RESTful 的接口实现方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@EnableAsync&lt;/code&gt;：在配置类中，通过此注解开启对异步任务的支持。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Async&lt;/code&gt;：在实际执行的 Bean 方法使用该注解来申明其是一个异步任务。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@EnableScheduling&lt;/code&gt;：在配置类上使用，开启计划任务的支持。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Scheduled&lt;/code&gt;：来申明这是一个任务，包括 &lt;code&gt;cron&lt;/code&gt;、&lt;code&gt;fixDelay&lt;/code&gt;、&lt;code&gt;fixRate&lt;/code&gt; 等类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-2-Controller-和-RestController-有什么区别？&#34;&gt;3.2 @Controller 和 @RestController 有什么区别？&lt;/h3&gt;
&lt;p&gt;（1）&lt;code&gt;@Controller&lt;/code&gt;：&lt;code&gt;@Controller&lt;/code&gt; 注解表示该类是一个 Web 控制器，通常与 &lt;code&gt;@RequestMapping&lt;/code&gt; 注解一起使用，用于处理 HTTP 请求。在 &lt;code&gt;@Controller&lt;/code&gt; 中，我们可以返回一个视图（View），这在 Spring Web MVC 中非常常见。例如：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Controller&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@RequestMapping(&amp;quot;/books&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;BookController&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@GetMapping(&amp;quot;/&amp;#123;id&amp;#125;&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;meta&#34;&gt;@ResponseBody&lt;/span&gt; Book &lt;span class=&#34;title function_&#34;&gt;getBook&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;meta&#34;&gt;@PathVariable&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; id)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; findBookById(id);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; Book &lt;span class=&#34;title function_&#34;&gt;findBookById&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; id)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;BookController&lt;/code&gt; 类被标记为一个控制器，&lt;code&gt;/books&lt;/code&gt; 是它的请求映射路径。&lt;code&gt;getBook()&lt;/code&gt; 方法用于处理对 &lt;code&gt;/books/&amp;#123;id&amp;#125;&lt;/code&gt; 路径的 GET 请求，其中 &lt;code&gt;&amp;#123;id&amp;#125;&lt;/code&gt; 是路径变量。&lt;/p&gt;
&lt;p&gt;（2）&lt;code&gt;@RestController&lt;/code&gt;：&lt;code&gt;@RestController&lt;/code&gt; 是 &lt;code&gt;@Controller&lt;/code&gt; 的特化，它包含了 &lt;code&gt;@Controller&lt;/code&gt; 和 &lt;code&gt;@ResponseBody&lt;/code&gt; 两个注解。这意味着，当一个类被 &lt;code&gt;@RestController&lt;/code&gt; 注解标记后，该类的所有方法都会默认添加 &lt;code&gt;@ResponseBody&lt;/code&gt; 注解。因此通常用于创建 RESTful Web 服务。例如：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@RestController&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@RequestMapping(&amp;quot;/books&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;BookRestController&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@GetMapping(&amp;quot;/&amp;#123;id&amp;#125;&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; Book &lt;span class=&#34;title function_&#34;&gt;getBook&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;meta&#34;&gt;@PathVariable&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; id)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; findBookById(id);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; Book &lt;span class=&#34;title function_&#34;&gt;findBookById&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; id)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;BookRestController&lt;/code&gt; 类被 &lt;code&gt;@RestController&lt;/code&gt; 注解标记，因此不需要再每个请求处理方法上都添加 &lt;code&gt;@ResponseBody&lt;/code&gt; 注解。&lt;/p&gt;
&lt;p&gt;总的来说二者的主要区别在于，&lt;code&gt;@Controller&lt;/code&gt; 通常用于处理返回视图的请求，而 &lt;code&gt;@RestController&lt;/code&gt; 通常用于处理返回 JSON 或 XML 响应的请求。&lt;/p&gt;
&lt;h3 id=&#34;3-3-GetMapping、-PostMapping-和-RequestMapping-有什么区别？&#34;&gt;3.3 @GetMapping、@PostMapping 和 @RequestMapping 有什么区别？&lt;/h3&gt;
&lt;p&gt;（1）&lt;code&gt;@RequestMapping&lt;/code&gt;：这是一个通用的注解，可以处理所有类型的 HTTP 请求。你可以通过 &lt;code&gt;method&lt;/code&gt; 属性来指定处理的 HTTP 方法类型（如 GET、POST 等）。例如：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@RequestMapping(value = &amp;quot;/users&amp;quot;, method = RequestMethod.GET)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; Users &lt;span class=&#34;title function_&#34;&gt;getUsers&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@RequestMapping(value = &amp;quot;/users&amp;quot;, method = RequestMethod.POST)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; User &lt;span class=&#34;title function_&#34;&gt;createUser&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(User user)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（2）&lt;code&gt;@GetMapping&lt;/code&gt;：这是 &lt;code&gt;@RequestMapping&lt;/code&gt; 的一个特化版本，用于处理 GET 请求，等价于 &lt;code&gt;@RequestMapping(method = RequestMethod.GET)&lt;/code&gt;。例如：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@GetMapping(&amp;quot;/users&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; Users &lt;span class=&#34;title function_&#34;&gt;getUsers&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（3）&lt;code&gt;@PostMapping&lt;/code&gt;：同样是 &lt;code&gt;@RequestMapping&lt;/code&gt; 的一个特化版本，用于处理 POST 请求，等价于 &lt;code&gt;@RequestMapping(method = RequestMethod.POST)&lt;/code&gt;。例如：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@PostMapping(&amp;quot;/users&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; User &lt;span class=&#34;title function_&#34;&gt;createUser&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(User user)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-4-RequestParam-和-PathVariable-有什么区别？&#34;&gt;3.4 @RequestParam 和 @PathVariable 有什么区别？&lt;/h3&gt;
&lt;p&gt;（1）&lt;code&gt;@RequestParam&lt;/code&gt;：用于从请求参数中提取值。例如，对于 URL：&lt;code&gt;http://localhost:8080/books?id=1&lt;/code&gt;，你可以使用 &lt;code&gt;@RequestParam&lt;/code&gt; 来获取 &lt;code&gt;id&lt;/code&gt; 参数的值：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@GetMapping(&amp;quot;/books&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; String &lt;span class=&#34;title function_&#34;&gt;getBook&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;meta&#34;&gt;@RequestParam(&amp;quot;id&amp;quot;)&lt;/span&gt; String id)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（2）&lt;code&gt;@PathVariable&lt;/code&gt;：用于从 URI 路径中提取值。例如，对于 URL：&lt;code&gt;http://localhost:8080/books/1&lt;/code&gt;，你可以使用 &lt;code&gt;@PathVariable&lt;/code&gt; 来获取 &lt;code&gt;id&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@GetMapping(&amp;quot;/books/&amp;#123;id&amp;#125;&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; String &lt;span class=&#34;title function_&#34;&gt;getBook&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;meta&#34;&gt;@PathVariable(&amp;quot;id&amp;quot;)&lt;/span&gt; String id)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-5-详细讲一下-Autowired-有什么用？&#34;&gt;3.5 详细讲一下 @Autowired 有什么用？&lt;/h3&gt;
&lt;p&gt;在 Spring 框架中，&lt;code&gt;@Autowired&lt;/code&gt; 注解用于实现自动依赖注入。这意味着你不需要在代码中明确指定依赖关系，Spring 会自动为你完成这个工作，从而简化了代码并提高了可维护性。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@Autowired&lt;/code&gt; 注解可以应用于字段、构造器和方法：&lt;/p&gt;
&lt;p&gt;（1）字段上的 &lt;code&gt;@Autowired&lt;/code&gt;：当 &lt;code&gt;@Autowired&lt;/code&gt; 注解应用于字段时，Spring 会在创建 Bean 时自动注入相应的依赖。在下面这个例子中，&lt;code&gt;myService&lt;/code&gt; 字段会被自动注入一个 &lt;code&gt;MyService&lt;/code&gt; 类型的 Bean：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; MyService myService;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（2）构造器上的 &lt;code&gt;@Autowired&lt;/code&gt;：当 &lt;code&gt;@Autowired&lt;/code&gt; 注解应用于构造器时，Spring 会在创建 Bean 时自动注入构造器的参数。在下面这个例子中，&lt;code&gt;MyClass&lt;/code&gt; 的构造器会被自动注入一个 &lt;code&gt;MyService&lt;/code&gt; 类型的 Bean：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyClass&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; MyService myService;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;MyClass&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(MyService myService)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;built_in&#34;&gt;this&lt;/span&gt;.myService = myService;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（3）方法上的 &lt;code&gt;@Autowired&lt;/code&gt;：当 &lt;code&gt;@Autowired&lt;/code&gt; 注解应用于方法时，Spring 会在创建 Bean 时自动注入方法的参数。这通常用于 Setter 方法，但也可以用于其他任何方法。例如：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;setMyService&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(MyService myService)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;this&lt;/span&gt;.myService = myService;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-Spring-Boot&#34;&gt;4. Spring Boot&lt;/h2&gt;
&lt;h3 id=&#34;4-1-为什么要用-Spring-Boot？&#34;&gt;4.1 为什么要用 Spring Boot？&lt;/h3&gt;
&lt;p&gt;Spring Boot 是 Spring 框架的一个扩展，它的目标是简化 Spring 应用程序的配置和部署，Spring Boot 具有以下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速开发：Spring Boot 通过提供一系列的开箱即用的组件和自动配置，简化了项目的配置和开发过程，开发人员可以更专注于业务逻辑的实现，而不需要花费过多时间在繁琐的配置上。例如，使用 Spring MVC 需要大量的 XML Bean 定义和自定义 &lt;code&gt;servlet&lt;/code&gt; 类，但使用 Spring Boot 只需要添加一个 &lt;code&gt;starter&lt;/code&gt; 依赖即可，无需任何代码生成或 XML 配置。&lt;/li&gt;
&lt;li&gt;快速启动：Spring Boot 提供了快速的应用程序启动方式，可通过内嵌的 Tomcat、Jetty 或 Undertow 等容器快速启动应用程序，无需额外的部署步骤，方便快捷。&lt;/li&gt;
&lt;li&gt;自动化配置：Spring Boot 通过自动配置功能，根据项目中的依赖关系和约定俗成的规则来配置应用程序，减少了配置的复杂性，使开发者更容易实现应用的最佳实践。&lt;/li&gt;
&lt;li&gt;有用的 Starters：Spring Boot Starters 是包含库和一些自动配置的 Maven 描述符。这些 Starters 可以为 Spring Boot 应用程序提供功能。例如，你想设置数据库连接，或者你想与消息队列进行通信或发送电子邮件，Spring Boot 都可以覆盖。&lt;/li&gt;
&lt;li&gt;嵌入式 Web 服务器：Spring Boot 提供了对嵌入式 Tomcat、Jetty 和 Undertow 服务器的开箱即用支持。这样，开发人员不必担心在传统的应用服务器中部署 Web 应用程序。&lt;/li&gt;
&lt;li&gt;丰富的 IDE 支持：所有主要的 IDE 都为 Spring Boot 提供了代码辅助支持。&lt;/li&gt;
&lt;li&gt;生产就绪的功能：Spring Boot 提供了开箱即用的监控、度量和日志记录功能。这些功能使开发人员可以避免额外的配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-2-Spring-Boot-比-Spring-好在哪里？&#34;&gt;4.2 Spring Boot 比 Spring 好在哪里？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Spring Boot 提供了自动化配置，大大简化了项目的配置过程。通过约定优于配置的原则，很多常用的配置可以自动完成，开发者可以专注于业务逻辑的实现。&lt;/li&gt;
&lt;li&gt;Spring Boot 提供了快速的项目启动器，通过引入不同的 Starter，可以快速集成常用的框架和库（如数据库、消息队列、Web 开发等），极大地提高了开发效率。&lt;/li&gt;
&lt;li&gt;Spring Boot 默认集成了多种内嵌服务器（如 Tomcat、Jetty、Undertow），无需额外配置，即可将应用打包成可执行的 JAR 文件，方便部署和运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-3-Spring-Boot-用到哪些设计模式？&#34;&gt;4.3 Spring Boot 用到哪些设计模式？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;代理模式：Spring 的 AOP 通过动态代理实现方法级别的切面增强，有静态和动态两种代理方式，采用动态代理方式。&lt;/li&gt;
&lt;li&gt;策略模式：Spring AOP 支持 JDK 和 CGLIB 两种动态代理实现方式，通过策略接口和不同策略类，运行时动态选择，其创建一般通过工厂方法实现。&lt;/li&gt;
&lt;li&gt;装饰器模式：Spring 用 TransactionAwareCacheDecorator 解决缓存与数据库事务问题增加对事务的支持。&lt;/li&gt;
&lt;li&gt;单例模式：Spring Bean 默认是单例模式，通过单例注册表（如 HashMap）实现。&lt;/li&gt;
&lt;li&gt;简单工厂模式：Spring 中的 BeanFactory 是简单工厂模式的体现，通过工厂类方法获取 Bean 实例。&lt;/li&gt;
&lt;li&gt;工厂方法模式：Spring 中的 FactoryBean 体现工厂方法模式，为不同产品提供不同工厂。&lt;/li&gt;
&lt;li&gt;观察者模式：Spring 观察者模式包含 Event 事件、Listener 监听者、Publisher 发送者，通过定义事件、监听器和发送者实现，观察者注册在 ApplicationContext 中，消息发送由 ApplicationEventMulticaster 完成。&lt;/li&gt;
&lt;li&gt;模板模式：Spring Bean 的创建过程涉及模板模式，体现扩展性，类似 Callback 回调实现方式。&lt;/li&gt;
&lt;li&gt;适配器模式：Spring MVC 中针对不同方式定义的 Controller，利用适配器模式统一函数定义，定义了统一接口 HandlerAdapter 及对应适配器类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-4-怎么理解-Spring-Boot-中的约定优于配置？&#34;&gt;4.4 怎么理解 Spring Boot 中的约定优于配置？&lt;/h3&gt;
&lt;p&gt;约定优于配置是 Spring Boot 的核心设计理念，它通过&lt;strong&gt;预设合理的默认行为和项目规范&lt;/strong&gt;，大幅减少开发者需要手动配置的步骤，从而提升开发效率和项目标准化程度。&lt;/p&gt;
&lt;p&gt;理解 Spring Boot 中的“约定优于配置”原则，可以从以下几个方面来解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动化配置：Spring Boot 提供了大量的自动化配置，通过分析项目的依赖和环境，自动配置应用程序的行为。开发者无需显式地配置每个细节，大部分常用的配置都已经预设好了。例如，引入 &lt;code&gt;spring-boot-starter-web&lt;/code&gt; 后，Spring Boot 会自动配置内嵌 Tomcat 和 Spring MVC，无需手动编写 XML。&lt;/li&gt;
&lt;li&gt;默认配置：Spring Boot 为诸多方面提供大量默认配置，如连接数据库、设置 Web 服务器、处理日志等。开发人员无需手动配置这些常见内容，框架已做好决策。例如，默认的日志配置可让应用程序快速输出日志信息，无需开发者额外繁琐配置日志级别、输出格式与位置等。&lt;/li&gt;
&lt;li&gt;约定的项目结构：Spring Boot 提倡特定项目结构，通常主应用程序类（含 Main 方法）置于根包，控制器类、服务类、数据访问类等分别放在相应子包，如 &lt;code&gt;com.example.demo.controller&lt;/code&gt; 放控制器类，&lt;code&gt;com.example.demo.service&lt;/code&gt; 放服务类等。此约定使团队成员更易理解项目结构与组织，新成员加入项目时能快速定位各功能代码位置，提升协作效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-5-Spring-Boot-的项目结构是怎么样的？&#34;&gt;4.5 Spring Boot 的项目结构是怎么样的？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;开放接口层：定义系统&lt;strong&gt;对外暴露&lt;/strong&gt;的协议（HTTP/RPC）和 API 规范，Controller 是其具体实现载体。&lt;/li&gt;
&lt;li&gt;终端显示层（半对应 Controller）：处理前端交互（渲染 HTML/JSON），在前后端分离架构中弱化此层。当前主要是 velocity 渲染、JS 渲染、JSP 渲染、移动端展示等。&lt;/li&gt;
&lt;li&gt;Web 层（直接对应 Controller）：处理 HTTP 请求路由、参数校验、返回响应，主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。&lt;/li&gt;
&lt;li&gt;Service 层（直接对应 Service）：业务逻辑层，实现核心业务逻辑，一般还会分为 Service 接口层和 Service 实现层，用面向接口的编程思想，为后续功能的解耦和扩展留下余地。&lt;/li&gt;
&lt;li&gt;Manager 层：通用业务处理层，它有如下特征：
&lt;ul&gt;
&lt;li&gt;对第三方平台封装的层，预处理返回结果及转化异常信息，适配上层接口。&lt;/li&gt;
&lt;li&gt;对 Service 层通用能力的下沉，如缓存方案、中间件通用处理。&lt;/li&gt;
&lt;li&gt;与 DAO 层交互，对多个 DAO 的组合复用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DAO 层（直接对应 Mapper）：数据访问（持久）层，与底层 MySQL、Oracle、Hbase、OceanBase 等进行数据交互。&lt;/li&gt;
&lt;li&gt;Pojo 层（直接对应 Model）：数据载体层，Entity 对应纯数据库映射对象（与 DB 强耦合），DTO/VO 用于传输，DTO 对应业务数据传输对象（包含业务字段），VO 对应前端展示对象（包含 UI 特定字段）。&lt;/li&gt;
&lt;li&gt;第三方服务：包括其它部门 RPC 服务接口，基础平台，其它公司的 HTTP 接口，如淘宝开放平台、支付宝付款服务、高德地图服务等，通常作为 Service 的依赖组件。&lt;/li&gt;
&lt;li&gt;外部接口：外部（应用）数据存储服务提供的接口，多见于数据迁移场景中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-6-Spring-Boot-自动装配原理是什么？&#34;&gt;4.6 Spring Boot 自动装配原理是什么？&lt;/h3&gt;
&lt;p&gt;Spring Boot 的自动装配原理是基于 Spring Framework 的条件化配置和 &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; 注解实现的。这种机制允许开发者在项目中引入相关的依赖，Spring Boot 将根据这些依赖自动配置应用程序的上下文和功能。&lt;/p&gt;
&lt;p&gt;Spring Boot 定义了一套接口规范，这套规范规定：Spring Boot 在启动时会扫描类路径下以及外部引用 Jar 包中的所有 &lt;code&gt;META-INF/spring.factories&lt;/code&gt; 文件（Spring Boot 2.x）或 &lt;code&gt;META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports&lt;/code&gt; 文件（Spring Boot 3.x+），将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 Jar 来说，只需要按照 Spring Boot 定义的标准，就能将自己的功能装置进 Spring Boot。&lt;/p&gt;
&lt;p&gt;通俗来讲，自动装配就是通过注解或一些简单的配置就可以在 Spring Boot 的帮助下开启和配置各种功能，比如数据库访问、Web 开发。&lt;/p&gt;
&lt;p&gt;点进 &lt;code&gt;@SpringBootApplication&lt;/code&gt; 注解的内部可以看到：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Target(&amp;#123;ElementType.TYPE&amp;#125;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Retention(RetentionPolicy.RUNTIME)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Documented&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Inherited&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@SpringBootConfiguration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@EnableAutoConfiguration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@ComponentScan(&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;    excludeFilters = &amp;#123;@Filter(&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;    type = FilterType.CUSTOM,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;    classes = &amp;#123;TypeExcludeFilter.class&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;), @Filter(&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;    type = FilterType.CUSTOM,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;    classes = &amp;#123;AutoConfigurationExcludeFilter.class&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;)&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;meta&#34;&gt;@interface&lt;/span&gt; SpringBootApplication &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这些注解的作用如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Target(&amp;#123;ElementType.TYPE&amp;#125;)&lt;/code&gt;：该注解指定了这个注解可以用来标记在类上。在这个特定的例子中，这表示该注解用于标记配置类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Retention(RetentionPolicy.RUNTIME)&lt;/code&gt;：这个注解指定了注解的生命周期，即在运行时保留。这是因为 Spring Boot 在运行时扫描类路径上的注解来实现自动配置，所以这里使用了 &lt;code&gt;RUNTIME&lt;/code&gt; 保留策略。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Documented&lt;/code&gt;：该注解表示这个注解应该被包含在 Java 文档中。它是用于生成文档的标记，使开发者能够看到这个注解的相关信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Inherited&lt;/code&gt;：这个注解指示一个被标注的类型是被继承的。在这个例子中，它表明这个注解可以被继承，如果一个类继承了带有这个注解的类，它也会继承这个注解。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@SpringBootConfiguration&lt;/code&gt;：这个注解表明这是一个 Spring Boot 配置类。如果点进这个注解内部会发现与标准的 &lt;code&gt;@Configuration&lt;/code&gt; 没啥区别，只是为了表明这是一个专门用于 Spring Boot 的配置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;：这个注解是 Spring Boot &lt;strong&gt;自动装配的核心&lt;/strong&gt;。它告诉 Spring Boot 启用自动配置机制，根据项目的依赖和配置自动配置应用程序的上下文。通过这个注解，Spring Boot 将尝试根据类路径上的依赖自动配置应用程序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ComponentScan&lt;/code&gt;：这个注解用于配置组件扫描的规则。在这里，它告诉 Spring Boot 在指定的包及其子包中查找组件，这些组件包括被注解的类、&lt;code&gt;@Component&lt;/code&gt; 注解的类等。其中的 &lt;code&gt;excludeFilters&lt;/code&gt; 参数用于指定排除哪些组件，这里使用了两个自定义的过滤器，分别是 &lt;code&gt;TypeExcludeFilter&lt;/code&gt; 和 &lt;code&gt;AutoConfigurationExcludeFilter&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-7-Spring-Boot-中如何实现对不同环境的属性配置文件的支持？&#34;&gt;4.7 Spring Boot 中如何实现对不同环境的属性配置文件的支持？&lt;/h3&gt;
&lt;p&gt;在 Spring Boot 中，你可以使用 Spring 的 Profile 功能来支持不同环境的属性配置文件。你可以为每个环境创建一个单独的配置文件，然后在运行应用程序时指定要使用的配置文件。&lt;/p&gt;
&lt;p&gt;例如，假设你有开发环境（dev）、质量保证环境（qa）和生产环境（prod）。你可以在与 &lt;code&gt;application.properties&lt;/code&gt; 文件相同的位置创建三个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;application-dev.properties&lt;/code&gt;：用于开发环境。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;application-qa.properties&lt;/code&gt;：用于质量保证环境。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;application-prod.properties&lt;/code&gt;：用于生产环境。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后，你只需要在 &lt;code&gt;application.properties&lt;/code&gt; 文件中设置 &lt;code&gt;spring.profiles.active&lt;/code&gt; 属性，来指定当前的环境。例如，如果你想使用质量保证环境，你可以设置 &lt;code&gt;spring.profiles.active=qa&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;此外，你还可以通过 JVM 参数来指定活动的配置文件。例如，你可以在启动应用程序时设置 &lt;code&gt;-Dspring.profiles.active=dev&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;4-8-如何理解-Spring-Boot-中的-Starters？&#34;&gt;4.8 如何理解 Spring Boot 中的 Starters？&lt;/h3&gt;
&lt;p&gt;在 Spring Boot 中，Starters 可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包。你可以一站式集成 Spring 及其他技术，快速地添加和管理项目的依赖，而不需要到处找示例代码和依赖包。&lt;/p&gt;
&lt;p&gt;例如，如果你想使用 Spring JPA 访问数据库，只要加入 &lt;code&gt;spring-boot-starter-data-jpa&lt;/code&gt; 启动器依赖就能使用了。同样，如果你想创建一个 RESTful 的 Web 应用，你可以添加 &lt;code&gt;spring-boot-starter-web&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;4-9-Spring-Boot-Starters-的工作原理是什么？&#34;&gt;4.9 Spring Boot Starters 的工作原理是什么？&lt;/h3&gt;
&lt;p&gt;Spring Boot Starters 的工作原理主要包括以下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引入模块所需的相关 Jar 包：Spring Boot Starter 会将具备某种功能的 Jar 包打包到一起，可以简化依赖导入的过程。例如，我们导入 &lt;code&gt;spring-boot-starter-web&lt;/code&gt; 这个 Starter，则和 Web 开发相关的 Jar 包都一起导入到项目中了。&lt;/li&gt;
&lt;li&gt;自动配置各个模块所需的属性：Spring Boot 在启动时会去依赖的 Starter 包中寻找 &lt;code&gt;resources/META-INF/spring.factories&lt;/code&gt; 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包。接着根据 &lt;code&gt;spring.factories&lt;/code&gt; 配置加载 &lt;code&gt;AutoConfigure&lt;/code&gt; 类。根据 &lt;code&gt;@Conditional&lt;/code&gt; 注解的条件，进行自动配置并将 Bean 注入 Spring Context。&lt;/li&gt;
&lt;li&gt;Bean 的发现和加载：Spring Boot 默认扫描启动类所在的包下的主类与子类的所有组件，但并没有包括依赖包中的类，那么依赖包中的 Bean 是如何被发现和加载的？Spring Boot 在启动类上我们一般会加入 &lt;code&gt;@SpringBootApplication&lt;/code&gt; 注解，此注解的源码中的 &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; 注解引入了 &lt;code&gt;@Import&lt;/code&gt; 这个注解，该注解导入自动配置功能类 &lt;code&gt;AutoConfigurationImportSelector&lt;/code&gt;，主要方法 &lt;code&gt;getCandidateConfigurations()&lt;/code&gt; 使用了 &lt;code&gt;SpringFactoriesLoader.loadFactoryNames()&lt;/code&gt; 方法加载 &lt;code&gt;META-INF/spring.factories&lt;/code&gt; 的文件（&lt;code&gt;spring.factories&lt;/code&gt; 声明具体自动配置）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-10-介绍几个-Starter？&#34;&gt;4.10 介绍几个 Starter？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;spring-boot-starter-web&lt;/code&gt;：这是最常用的起步依赖之一，它包含了 Spring MVC 和 Tomcat 嵌入式服务器，用于快速构建 Web 应用程序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spring-boot-starter-security&lt;/code&gt;：提供了 Spring Security 的基本配置，帮助开发者快速实现应用的安全&lt;br&gt;
性，包括认证和授权功能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mybatis-spring-boot-starter&lt;/code&gt;：这个 Starter 是由 MyBatis 团队提供的，用于简化在 Spring Boot 应用中集成 MyBatis 的过程。它自动配置了 MyBatis 的相关组件，包括 SqlSessionFactory、MapperScannerConfigurer 等，使得开发者能够快速地开始使用 MyBatis 进行数据库操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spring-boot-starter-data-jpa&lt;/code&gt; 或 &lt;code&gt;spring-boot-starter-jdbc&lt;/code&gt;：如果使用的是 Java Persistence API（JPA）进行数据库操作，那么应该使用 &lt;code&gt;spring-boot-starter-data-jpa&lt;/code&gt;。这个 Starter 包含了 Hibernate 等 JPA 实现以及数据库连接池等必要的库，可以让你轻松地与 MySQL 数据库进行交互。你需要在 &lt;code&gt;application.properties&lt;/code&gt; 或 &lt;code&gt;application.yml&lt;/code&gt; 中配置 MySQL 的连接信息。如果倾向于直接使用 JDBC 而不通过 JPA，那么可以使用 &lt;code&gt;spring-boot-starter-jdbc&lt;/code&gt;，它提供了基本的 JDBC 支持。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spring-boot-starter-data-redis&lt;/code&gt;：用于集成 Redis 缓存和数据存储服务。这个 Starter 包含了与 Redis 交互所需的客户端（默认是 Jedis 客户端，也可以配置为 Lettuce 客户端），以及 Spring Data Redis 的支持，使得在 Spring Boot 应用中使用 Redis 变得非常便捷。同样地，需要在配置文件中设置 Redis 服务器的连接详情。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spring-boot-starter-test&lt;/code&gt;：包含了单元测试和集成测试所需的库，如 JUnit、Spring Test、AssertJ 等，便于进行测试驱动开发（TDD）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-11-Spring-Boot-的核心注解是什么？主要由哪几个注解组成？&#34;&gt;4.11 Spring Boot 的核心注解是什么？主要由哪几个注解组成？&lt;/h3&gt;
&lt;p&gt;Spring Boot 的核心注解是 &lt;code&gt;@SpringBootApplication&lt;/code&gt;。这个注解实际上是以下三个注解的组合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@SpringBootConfiguration&lt;/code&gt;：组合了 &lt;code&gt;@Configuration&lt;/code&gt; 注解，实现配置文件的功能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;：打开自动配置的功能，也可以关闭某个自动配置的选项。如关闭数据源的自动配置功能：&lt;code&gt;@SpringBootApplication(exclude = &amp;#123; DataSourceAutoConfiguration.class &amp;#125;)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ComponentScan&lt;/code&gt;：Spring 组件扫描功能，让 Spring Boot 扫描到 &lt;code&gt;Configuration&lt;/code&gt; 类并把它加入到程序上下文。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-12-Spring-Boot-中如何使用-Bean？&#34;&gt;4.12 Spring Boot 中如何使用 Bean？&lt;/h3&gt;
&lt;p&gt;在 Spring Boot 中，你可以通过使用 &lt;code&gt;@Bean&lt;/code&gt; 注解来声明一个 Bean。&lt;code&gt;@Bean&lt;/code&gt; 注解告诉 Spring 一个方法会返回一个对象，这个对象应该被注册为 Spring 应用上下文中的 Bean。默认情况下，Bean 的名称是由方法名决定的，但你也可以在 &lt;code&gt;@Bean&lt;/code&gt; 注解中通过 &lt;code&gt;name&lt;/code&gt; 属性来设置 Bean 的名称。&lt;/p&gt;
&lt;p&gt;例如，以下是一个简单的 &lt;code&gt;@Bean&lt;/code&gt; 注解的使用示例：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;AppConfig&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; MyBean &lt;span class=&#34;title function_&#34;&gt;myBean&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyBean&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，&lt;code&gt;myBean()&lt;/code&gt; 方法被注解为 &lt;code&gt;@Bean&lt;/code&gt;，所以它会返回一个新的 &lt;code&gt;MyBean&lt;/code&gt; 实例，这个实例将被注册为 Spring 应用上下文中的 Bean。&lt;/p&gt;
&lt;p&gt;总的来说，你不需要在 Spring Boot 中手动配置 Bean，你只需要使用 &lt;code&gt;@Bean&lt;/code&gt; 注解，Spring Boot 就会自动为你创建和管理 Bean。&lt;/p&gt;
&lt;h3 id=&#34;4-13-RESTful-是什么？&#34;&gt;4.13 RESTful 是什么？&lt;/h3&gt;
&lt;p&gt;RESTful 是一种软件架构风格，它主要用于客户端和服务器交互类的软件。在 RESTful 风格中，用户发起请求的发送方式有 GET、POST、DELETE、PUT 等方式对请求的处理方法进行区分。这样可以在前后端分离式的开发中使得前端开发人员不会对请求的资源地址产生混淆和大量的检查方法名的麻烦，形成一个统一的接口，使得 Web 服务变得更加简洁、有层次，易于实现缓存等机制。&lt;/p&gt;
&lt;p&gt;在 Spring Boot 中，开发 RESTful 接口非常简单，通过不同的注解来支持前端的请求，除了经常使用的 &lt;code&gt;@RestController&lt;/code&gt; 注解外，Spring Boot 还提供了一些组合注解。这些注解来帮助简化常用的 HTTP 方法的映射，并更好地表达被注解方法的语义。&lt;/p&gt;
&lt;p&gt;例如，Spring Boot 提供了与 REST 操作方式（GET、POST、PUT、DELETE）对应的注解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@GetMapping&lt;/code&gt;：处理 GET 请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PostMapping&lt;/code&gt;：处理 POST 请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PutMapping&lt;/code&gt;：用于更新资源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@DeleteMapping&lt;/code&gt;：处理删除请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@PatchMapping&lt;/code&gt;：用于更新部分资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些注解就是我们使用的 &lt;code&gt;@RequestMapping&lt;/code&gt; 的简写版本：&lt;code&gt;@GetMapping&lt;/code&gt; 其实就等于 &lt;code&gt;@RequestMapping(value = &amp;quot;/xxx&amp;quot;, method = RequestMethod.GET)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;5-Spring-Cloud&#34;&gt;5. Spring Cloud&lt;/h2&gt;
&lt;h3 id=&#34;5-1-什么是-Spring-Cloud？和-Spring-Boot-的区别是什么？&#34;&gt;5.1 什么是 Spring Cloud？和 Spring Boot 的区别是什么？&lt;/h3&gt;
&lt;p&gt;Spring Boot 是用于构建单个 Spring 应用的框架，而 Spring Cloud 则是用于构建分布式系统中的微服务架构的工具。&lt;/p&gt;
&lt;p&gt;Spring Cloud 是一系列框架的有序集合，它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发。Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理、服务注册与发现、断路器、负载均衡、智能路由、微代理、控制总线）。分布式系统的协调导致了样板模式，使用 Spring Cloud 开发人员可以快速地支持实现这些模式的服务和应用程序。&lt;/p&gt;
&lt;p&gt;Spring Cloud 并不重复造轮子，而是将市面上开发得比较好的模块集成进去，进行封装，从而减少了各模块的开发成本。&lt;/p&gt;
&lt;p&gt;总的来说，Spring Cloud 是微服务系统架构的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶。&lt;/p&gt;
&lt;h3 id=&#34;5-2-介绍一下用过哪些微服务组件？&#34;&gt;5.2 介绍一下用过哪些微服务组件？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;注册中心：注册中心是微服务架构最核心的组件。它起到的作用是对新节点的注册与状态维护，解决了&lt;strong&gt;如何发现新节点以及检查各节点运行状态&lt;/strong&gt;的问题。微服务节点在启动时会将自己的服务名称、IP、端口等信息在注册中心登记，注册中心会定时检查该节点的运行状态。注册中心通常会采用&lt;strong&gt;心跳机制&lt;/strong&gt;最大程度保证已登记过的服务节点都是可用的。&lt;/li&gt;
&lt;li&gt;负载均衡：负载均衡解决了&lt;strong&gt;如何发现服务及负载均衡如何实现&lt;/strong&gt;的问题。通常微服务在互相调用时，并不是直接通过 IP、端口进行访问调用。而是先通过服务名在注册中心查询该服务拥有哪些节点，注册中心将该服务可用节点列表返回给服务调用者，这个过程叫&lt;strong&gt;服务发现&lt;/strong&gt;，因服务高可用的要求，服务调用者会接收到多个节点，必须要从中进行选择。因此服务调用者一端必须内置负载均衡器，通过负载均衡策略&lt;strong&gt;选择合适的节点发起实质性的通信请求&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;服务通信：服务通信组件解决了&lt;strong&gt;服务间如何进行消息通信&lt;/strong&gt;的问题。服务间通信采用轻量级协议，通常是 HTTP RESTful 风格。但因为 RESTful 风格过于灵活，必须加以约束，通常应用时对其封装。例如在 Spring Cloud 中就提供了 Feign（&lt;code&gt;[fen]&lt;/code&gt;）和 RestTemplate 两种技术屏蔽底层的实现细节，所有开发者都是基于封装后统一的 SDK 进行开发，有利于团队间的相互合作。&lt;/li&gt;
&lt;li&gt;配置中心：配置中心主要解决了&lt;strong&gt;如何集中管理各节点配置文件&lt;/strong&gt;的问题。在微服务架构下，所有的微服务节点都包含自己的各种配置文件，如 JDBC 配置、自定义配置、环境配置、运行参数配置等。要知道有的微服务可能可能有几十个节点，如果将这些配置文件分散存储在节点上，发生配置更改就需要逐个节点调整，将给运维人员带来巨大的压力。配置中心便由此而生，通过部署配置中心服务器，将各节点配置文件从服务中剥离，集中转存到配置中心。一般配置中心都有 UI 界面，方便实现大规模集群配置调整。&lt;/li&gt;
&lt;li&gt;集中式日志管理：集中式日志主要是解决了&lt;strong&gt;如何收集各节点日志并统一管理&lt;/strong&gt;的问题。微服务架构默认将应用日志分别保存在部署节点上，当需要对日志数据和操作数据进行数据分析和数据统计时，必须收集所有节点的日志数据。那么怎么高效收集所有节点的日志数据呢？业内常见的方案有 ELK、EFK。通过搭建独立的日志收集系统，定时抓取各节点增量日志形成有效的统计报表，为统计和分析提供数据支撑。&lt;/li&gt;
&lt;li&gt;分布式链路追踪：分布式链路追踪解决了&lt;strong&gt;如何直观的了解各节点间的调用链路&lt;/strong&gt;的问题。系统中一个复杂的业务流程，可能会出现连续调用多个微服务，我们需要了解完整的业务逻辑涉及的每个微服务的运行状态，通过可视化链路图展现，可以帮助开发人员快速分析系统瓶颈及出错的服务。&lt;/li&gt;
&lt;li&gt;服务保护：服务保护主要是解决了&lt;strong&gt;如何对系统进行链路保护，避免服务雪崩&lt;/strong&gt;的问题。在业务运行时，微服务间互相调用支撑，如果某个微服务出现高延迟导致线程池满载，或是业务处理失败。这里就需要引入服务保护组件来实现高延迟服务的快速降级，避免系统崩溃。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-3-详细介绍一下分布式项目与微服务架构&#34;&gt;5.3 详细介绍一下分布式项目与微服务架构&lt;/h3&gt;
&lt;p&gt;分布式项目是指将一个大型的项目切割成多个小项目，每个小项目都是一套&lt;strong&gt;独立的&lt;/strong&gt;系统。这些小项目被打成 Jar 包，然后通过互相引用（以 Jar 包的形式）来组装成原来的完整项目。每个子业务都是一套独立的系统，子业务之间相互协作，最终完成整体的大业务。这种方式可以提高系统的&lt;strong&gt;可扩展性&lt;/strong&gt;和&lt;strong&gt;高可用性&lt;/strong&gt;，解决&lt;strong&gt;高并发&lt;/strong&gt;的问题，并且可以利用分布式存储将数据分片到多个节点上，不仅可以提高性能，同时也可以使用多个节点对同一份数据进行备份。&lt;/p&gt;
&lt;p&gt;微服务架构是一种软件开发框架，它将一个大型的应用程序划分为许多小的、独立的服务。每个服务都有自己的技术栈，包括数据库和数据管理模型。这些服务通常通过 REST API、事件流和消息代理进行通信，并按照业务能力进行组织。&lt;/p&gt;
&lt;p&gt;微服务架构的主要优点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码更容易更新：可以直接添加新特性或功能，而不必更新整个应用。&lt;/li&gt;
&lt;li&gt;团队可以对不同的组件使用不同的技术栈和不同的编程语言。&lt;/li&gt;
&lt;li&gt;组件可以相互独立地扩展，从而减少与必须扩展整个应用相关的浪费和成本。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然而，微服务架构也带来了一些挑战，例如管理复杂性的增加、日志记录数据的增加、新版本可能导致的向后兼容性问题、应用涉及更多网络连接可能导致的延迟和连接问题等。尽管如此，微服务架构仍然被广泛采用，因为它可以提高开发效率，使组织能够更快地响应业务需求。&lt;/p&gt;
&lt;p&gt;微服务架构和分布式系统是两个不同的概念，它们的主要区别在于设计目标和实现方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分布式系统：分布式系统的核心就是&lt;strong&gt;拆分&lt;/strong&gt;，只要是将一个项目拆分成了多个模块，并将这些模块分开部署，那就算是分布式。分布式解决的是系统性能问题，即解决系统部署上单点的问题，尽量让组成系统的子系统分散在不同的机器上进而提高系统的吞吐能力。分布式是&lt;strong&gt;部署层面&lt;/strong&gt;的东西，即强调物理层面的组成，系统的各子系统部署在不同计算机上。&lt;/li&gt;
&lt;li&gt;微服务架构：微服务架构通过&lt;strong&gt;更细粒度的服务切分&lt;/strong&gt;，使得整个系统的迭代速度和并行程度更高，但是运维的复杂度和性能会随着服务的粒度更细而增加。微服务重在&lt;strong&gt;解耦合&lt;/strong&gt;，使每个模块都独立。微服务是&lt;strong&gt;设计层面&lt;/strong&gt;的东西，一般考虑如何将系统从&lt;strong&gt;逻辑上&lt;/strong&gt;进行拆分，也就是垂直拆分。微服务可以是分布式的，即可以将不同服务部署在不同计算机上，当然如果量小也可以部署在单机上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总的来说，分布式系统和微服务架构都是为了提高系统的可扩展性和可维护性，但它们的关注点和实现方式有所不同。&lt;/p&gt;
&lt;h3 id=&#34;5-4-使用-Spring-Cloud-有什么优势？&#34;&gt;5.4 使用 Spring Cloud 有什么优势？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;约定优于配置：Spring Cloud 提供了一套默认的配置，使得开发人员可以更专注于业务逻辑的开发。&lt;/li&gt;
&lt;li&gt;适用于各种环境：无论是开发环境、部署 PC Server，还是各种云环境（例如阿里云、AWS 等），Spring Cloud 都可以适用。&lt;/li&gt;
&lt;li&gt;隐藏了组件的复杂性：Spring Cloud 提供了声明式、无 XML 的配置方式，隐藏了组件的复杂性。&lt;/li&gt;
&lt;li&gt;开箱即用、快速启动：Spring Cloud 提供了一套完整的微服务解决方案，使得开发人员可以快速启动项目。&lt;/li&gt;
&lt;li&gt;轻量级的组件：Spring Cloud 整合的组件大多比较轻量。&lt;/li&gt;
&lt;li&gt;组件丰富、选型中立、功能齐全：Spring Cloud 为微服务架构提供了非常完整的支持，有丰富的组件选择，开发人员可以根据需求选择合适的组件。&lt;/li&gt;
&lt;li&gt;灵活：Spring Cloud 的组成部分是解耦合的，开发人员可以按需灵活挑选技术选型。&lt;/li&gt;
&lt;li&gt;服务拆分粒度更细：有利于资源重复利用，提高开发效率。&lt;/li&gt;
&lt;li&gt;采用去中心化思想：服务之间采用轻量级通讯，适合互联网时代，产品迭代周期更短。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-5-服务注册和发现是什么意思？Spring-Cloud-如何实现？&#34;&gt;5.5 服务注册和发现是什么意思？Spring Cloud 如何实现？&lt;/h3&gt;
&lt;p&gt;服务注册是指将服务的元数据（例如服务名、IP 地址、端口号等）注册到注册中心中，以便其他服务可以发现它。例如，一个微服务启动后，会将自己的信息（通常是这个服务的 IP 和端口）注册到一个公共的组件上去（比如 ZooKeeper、Consul）。&lt;/p&gt;
&lt;p&gt;服务发现是指客户端从注册中心中查找和选择可用的服务实例，并通过负载均衡策略来分配请求。也就是说，新注册的这个服务模块能够及时的被其他调用者发现。不管是服务新增和服务删减都能实现自动发现。&lt;/p&gt;
&lt;p&gt;Spring Cloud 实现服务注册和发现的方式主要有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Eureka（&lt;code&gt;[jʊ&#39;ri:kə]&lt;/code&gt;）：Eureka 是 Netflix 开源的一款提供服务注册和发现的产品。Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务治理。在微服务应用启动后，Eureka Client 会向 Eureka Server 发送心跳。如果 Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，则会将该节点移除。&lt;/li&gt;
&lt;li&gt;Consul：Consul 是一种服务网格解决方案，提供了包括服务发现、配置和分段功能。这些功能中的每一个都可以根据需要独立使用，也可以一起使用以构建全堆栈服务网格。Consul 是适用于底层服务发现和配置的工具。&lt;/li&gt;
&lt;li&gt;ZooKeeper：ZooKeeper 是一个开源的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，是 Hadoop 和 Hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-6-负载均衡有什么作用？&#34;&gt;5.6 负载均衡有什么作用？&lt;/h3&gt;
&lt;p&gt;负载均衡是一种重要的网络技术，它可以有效地提高网络服务的性能、可用性和安全性。负载均衡的主要作用包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决并发压力：通过将客户端的请求分发到多个服务器，负载均衡可以有效地解决并发压力，提高应用处理性能，增加吞吐量，加强网络处理能力。&lt;/li&gt;
&lt;li&gt;提供故障转移：负载均衡可以检测后端服务的运行状况，自动检测异常实例，并快速实施故障转移；当实例恢复正常时，它将自动恢复负载。这样，即使某个服务器出现故障，负载均衡也可以保证服务的高可用性。&lt;/li&gt;
&lt;li&gt;提供网站伸缩性（扩展性）：当业务压力增加时，可以通过将主机添加到后端服务器池来提高性能。当压力降低时，可以减少宿主。这样，负载均衡可以根据业务需求动态地添加或减少服务器数量，提供网站的伸缩性。&lt;/li&gt;
&lt;li&gt;安全防护：负载均衡设备上可以做一些过滤，黑白名单等处理，提供安全防护。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-7-负载均衡有哪些算法？&#34;&gt;5.7 负载均衡有哪些算法？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简单轮询：将请求按顺序分发给后端服务器上，不关心服务器当前的状态，比如后端服务器的性能、当前的负载。&lt;/li&gt;
&lt;li&gt;加权轮询：根据服务器自身的性能给服务器设置不同的权重，将请求按顺序和权重分发给后端服务器，可以让性能高的机器处理更多的请求。&lt;/li&gt;
&lt;li&gt;简单随机：将请求随机分发给后端服务器上，请求越多，各个服务器接收到的请求越平均。&lt;/li&gt;
&lt;li&gt;加权随机：根据服务器自身的性能给服务器设置不同的权重，将请求按各个服务器的权重随机分发给后端服务器。&lt;/li&gt;
&lt;li&gt;一致性哈希：根据请求的客户端 IP、或请求参数通过哈希算法得到一个数值，利用该数值取模映射出对应的后端服务器，这样能&lt;strong&gt;保证同一个客户端或相同参数的请求每次都使用同一台服务器&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;最小活跃数：统计每台服务器上当前正在处理的请求数，也就是请求活跃数，将请求分发给活跃数最少的后台服务器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-8-介绍一下服务熔断？&#34;&gt;5.8 介绍一下服务熔断？&lt;/h3&gt;
&lt;p&gt;服务熔断是应对微服务雪崩效应的一种&lt;strong&gt;链路保护机制&lt;/strong&gt;，类似股市、保险丝。&lt;/p&gt;
&lt;p&gt;比如说，微服务之间的数据交互是通过远程调用来完成的。服务 A 调用服务 B，服务 B 调用服务 C，某一时间链路上对服务 C 的调用响应时间过长或者服务 C 不可用，随着时间的增长，对服务 C 的调用也越来越多，然后服务 C 崩溃了，但是链路调用还在，对服务 B 的调用也在持续增多，然后服务 B 崩溃，随之 A 也崩溃，导致雪崩效应。&lt;/p&gt;
&lt;p&gt;服务熔断是应对雪崩效应的一种微服务链路保护机制。例如在高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。同样，在微服务架构中，熔断机制也是起着类似的作用。当调用链路的某个微服务&lt;strong&gt;不可用&lt;/strong&gt;或者&lt;strong&gt;响应时间太长&lt;/strong&gt;时，会进行服务熔断，&lt;strong&gt;不再有该节点微服务的调用&lt;/strong&gt;，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。&lt;/p&gt;
&lt;p&gt;所以，服务熔断的作用类似于我们家用的保险丝，当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。&lt;/p&gt;
&lt;p&gt;在 Spring Cloud 框架里，熔断机制通过 Hystrix（&lt;code&gt;[hɪst&#39;rɪks]&lt;/code&gt;）实现。Hystrix 会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。&lt;/p&gt;
&lt;h3 id=&#34;5-9-介绍一下服务降级？&#34;&gt;5.9 介绍一下服务降级？&lt;/h3&gt;
&lt;p&gt;服务降级一般是指在服务器压力剧增的时候，根据实际业务使用情况以及流量，对一些服务和页面&lt;strong&gt;有策略地不处理或者用一种简单的方式进行处理&lt;/strong&gt;，从而&lt;strong&gt;释放服务器资源的资源以保证核心业务的正常高效运行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;服务器的资源是有限的，而请求是无限的。在用户使用即并发高峰期，会影响整体服务的性能，严重的话会导致宕机，以至于某些重要服务不可用。故高峰期为了保证核心功能服务的可用性，就需要对某些服务降级处理，可以理解为舍小保大。&lt;/p&gt;
&lt;p&gt;服务降级是从&lt;strong&gt;整个系统的负荷情况&lt;/strong&gt;出发和考虑的，对某些负荷会比较高的情况，为了预防某些功能（业务场景）出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的退路（fallback）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性。&lt;/p&gt;
&lt;h3 id=&#34;5-10-Spring-Cloud-和-Dubbo-有什么区别？&#34;&gt;5.10 Spring Cloud 和 Dubbo 有什么区别？&lt;/h3&gt;
&lt;p&gt;Spring Cloud 和 Dubbo 都是现在主流的微服务框架，但它们之间存在一些主要的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始定位不同：Spring Cloud 定位为微服务架构下的一站式解决方案，而 Dubbo 是 SOA（Service-Oriented Architecture，面向服务的架构）时代的产物，它的关注点主要在于服务的调用和治理。&lt;/li&gt;
&lt;li&gt;生态环境不同：Spring Cloud 依托于 Spring 平台，具备更加完善的生态体系；而 Dubbo 一开始只是做 RPC（Remote Procedure Call，远程过程调用）通信协议的远程调用，生态相对匮乏，现在才逐渐丰富起来。&lt;/li&gt;
&lt;li&gt;调用方式不同：Spring Cloud 是采用 HTTP 协议做远程调用，接口一般是 REST 风格，比较灵活；Dubbo 是采用 Dubbo 协议，接口一般是 Java 的 Service 接口，格式固定。&lt;/li&gt;
&lt;li&gt;服务网关：Dubbo 没有服务网关，而 Spring Cloud 使用的是 Spring Cloud Netflix Zuul。&lt;/li&gt;
&lt;li&gt;分布式配置：Dubbo 没有分布式配置，而 Spring Cloud 使用的是 Spring Cloud Config。&lt;/li&gt;
&lt;li&gt;服务跟踪：Dubbo 没有服务跟踪，而 Spring Cloud 使用的是 Spring Cloud Sleuth。&lt;/li&gt;
&lt;li&gt;消息总线：Dubbo 没有消息总线，而 Spring Cloud 使用的是 Spring Cloud Bus。&lt;/li&gt;
&lt;li&gt;数据流：Dubbo 没有数据流，而 Spring Cloud 使用的是 Spring Cloud Stream。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-11-Sping-Cloud-微服务之间如何通讯？&#34;&gt;5.11 Sping Cloud 微服务之间如何通讯？&lt;/h3&gt;
&lt;p&gt;在 Spring Cloud 中，微服务之间的通信主要有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步通信：Dubbo 通过 RPC 远程过程调用，而 Spring Cloud 通过 REST 接口 JSON 调用等（HTTP 通信）。&lt;/li&gt;
&lt;li&gt;异步通信：消息队列，如：RabbitMq、ActiveMq、Kafka 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-MyBatis&#34;&gt;6. MyBatis&lt;/h2&gt;
&lt;h3 id=&#34;6-1-与传统的-JDBC-相比，MyBatis-的优点是什么？&#34;&gt;6.1 与传统的 JDBC 相比，MyBatis 的优点是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 SQL 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用。&lt;/li&gt;
&lt;li&gt;与 JDBC 相比，减少了 50% 以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接。&lt;/li&gt;
&lt;li&gt;很好的与各种数据库兼容，因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持。&lt;/li&gt;
&lt;li&gt;能够与 Spring 很好的集成，开发效率高。&lt;/li&gt;
&lt;li&gt;提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系组件维护。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6-2-MyBatis-在哪方面做的比较好？&#34;&gt;6.2 MyBatis 在哪方面做的比较好？&lt;/h3&gt;
&lt;p&gt;MyBatis 在 &lt;strong&gt;SQL 灵活性&lt;/strong&gt;、&lt;strong&gt;动态 SQL 支持&lt;/strong&gt;、&lt;strong&gt;结果集映射&lt;/strong&gt;和&lt;strong&gt;与 Spring 整合&lt;/strong&gt;方面表现卓越，尤其适合重视 SQL 可控性的项目。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SQL 与代码解耦，灵活可控：MyBatis 允许开发者直接编写和优化 SQL，相比全自动 ORM（如 Hibernate），MyBatis 让开发者明确知道每条 SQL 的执行逻辑，便于性能调优。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight xml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;&amp;lt;!-- 示例：XML 中定义 SQL --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;id&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;findUserWithRole&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;resultMap&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;userRoleMap&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    SELECT u.*, r.role_name&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    FROM user u&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    LEFT JOIN user_role ur ON u.id = ur.user_id&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    LEFT JOIN role r ON ur.role_id = r.id&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    WHERE u.id = #&amp;#123;userId&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;select&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;动态 SQL 的强大支持：比如可以动态拼接 SQL，通过 &lt;code&gt;&amp;lt;if&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;choose&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;foreach&amp;gt;&lt;/code&gt; 等标签动态生成 SQL，避免 Java 代码中繁琐的字符串拼接。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight xml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;id&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;searchUsers&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;resultType&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;User&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    SELECT * FROM user&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;where&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;test&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;name != null&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;AND name LIKE #&amp;#123;name&amp;#125;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;if&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;test&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;status != null&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;AND status = #&amp;#123;status&amp;#125;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;if&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;where&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;select&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的例子中使用 MyBatis 的 &lt;code&gt;&amp;lt;where&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;if&amp;gt;&lt;/code&gt; 标签实现动态 SQL，&lt;code&gt;&amp;lt;where&amp;gt;&lt;/code&gt; 会自动去除多余的 &lt;code&gt;AND/OR&lt;/code&gt;，且当内部条件为空时，不生成 &lt;code&gt;WHERE&lt;/code&gt; 关键字，&lt;code&gt;&amp;lt;if&amp;gt;&lt;/code&gt; 标签根据参数动态添加条件，例如 &lt;code&gt;test=&amp;quot;name != null&amp;quot;&lt;/code&gt; 表示当 &lt;code&gt;name&lt;/code&gt; 参数非空时生效。根据传入参数不同可以生成不同的 SQL：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;传入参数&lt;/th&gt;
&lt;th&gt;生成的 SQL&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;name=&amp;quot;张%&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SELECT * FROM user WHERE name LIKE &#39;张%&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;模糊查询姓张的用户&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;status=1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SELECT * FROM user WHERE status = 1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;查询状态为1的用户&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;name=&amp;quot;李%&amp;quot; status=0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SELECT * FROM user WHERE name LIKE &#39;李%&#39; AND status = 0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;组合查询&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;无参数&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SELECT * FROM user&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;查询所有用户&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;自动映射与自定义映射结合：自动将查询结果字段名与对象属性名匹配（如驼峰转换）。例如在下面这个例子中，&lt;code&gt;resultMap&lt;/code&gt; 实现了&lt;strong&gt;用户-角色&lt;/strong&gt;的&lt;strong&gt;一对多&lt;/strong&gt;关系映射，&lt;code&gt;&amp;lt;resultMap&amp;gt;&lt;/code&gt; 定义结果集映射规则，映射到 &lt;code&gt;User&lt;/code&gt; 类；&lt;code&gt;&amp;lt;id&amp;gt;&lt;/code&gt; 为主键映射（标识对象唯一性），将数据库的 &lt;code&gt;user_id&lt;/code&gt; 字段映射到 &lt;code&gt;User&lt;/code&gt; 对象的 &lt;code&gt;id&lt;/code&gt; 属性；&lt;code&gt;&amp;lt;result&amp;gt;&lt;/code&gt; 为普通字段映射，将数据库的 &lt;code&gt;user_name&lt;/code&gt; 字段映射到 &lt;code&gt;User&lt;/code&gt; 对象的 &lt;code&gt;name&lt;/code&gt; 属性；&lt;code&gt;&amp;lt;collection&amp;gt;&lt;/code&gt; 为一对多集合映射（用户对应多个角色），映射到 &lt;code&gt;User&lt;/code&gt; 对象的 &lt;code&gt;roles&lt;/code&gt; 属性，其中嵌套了对象的字段映射，将数据库的 &lt;code&gt;role_name&lt;/code&gt; 字段映射到 &lt;code&gt;Role&lt;/code&gt; 对象的 &lt;code&gt;roleName&lt;/code&gt; 属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight xml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;resultMap&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;id&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;userRoleMap&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;type&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;User&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;id&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;property&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;id&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;column&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;user_id&amp;quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;property&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;name&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;column&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;user_name&amp;quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;collection&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;property&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;roles&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;ofType&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;Role&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;property&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;roleName&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;column&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;role_name&amp;quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;collection&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;resultMap&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;插件扩展机制：可编写插件拦截 SQL 执行过程，实现分页、性能监控、SQL 改写等通用逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Intercepts(&amp;#123;@Signature(type=Executor.class, method=&amp;quot;query&amp;quot;, args=&amp;#123;...&amp;#125;)&amp;#125;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;PaginationPlugin&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Interceptor&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 实现分页逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;与 Spring 生态无缝集成：通过 &lt;code&gt;@MapperScan&lt;/code&gt; 快速扫描 &lt;code&gt;Mapper&lt;/code&gt; 接口，结合 Spring 事务管理，配置简洁高效。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;@MapperScan(&amp;quot;com.example.mapper&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyBatisConfig&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 数据源和 SqlSessionFactory 配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;6-3-JDBC-连接数据库的步骤是什么？&#34;&gt;6.3 JDBC 连接数据库的步骤是什么？&lt;/h3&gt;
&lt;p&gt;使用 Java JDBC 连接数据库的一般步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加载数据库驱动程序：在使用 JDBC 连接数据库之前，需要加载相应的数据库驱动程序。可以通过 &lt;code&gt;Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;)&lt;/code&gt; 来加载 MySQL 数据库的驱动程序。不同数据库的驱动类名会有所不同。&lt;/li&gt;
&lt;li&gt;建立数据库连接：使用 &lt;code&gt;DriverManager&lt;/code&gt; 类的 &lt;code&gt;getConnection(url, username, password)&lt;/code&gt; 方法来连接数据库，其中 &lt;code&gt;url&lt;/code&gt; 是数据库的连接字符串（包括数据库类型、主机、端口等），&lt;code&gt;username&lt;/code&gt; 是数据库用户名，&lt;code&gt;password&lt;/code&gt; 是密码。&lt;/li&gt;
&lt;li&gt;创建 &lt;code&gt;Statement&lt;/code&gt; 对象：通过 &lt;code&gt;Connection&lt;/code&gt; 对象的 &lt;code&gt;createStatement()&lt;/code&gt; 方法创建一个 &lt;code&gt;Statement&lt;/code&gt; 对象，用于执行 SQL 查询或更新操作。&lt;/li&gt;
&lt;li&gt;执行 SQL 查询或更新操作：使用 &lt;code&gt;Statement&lt;/code&gt; 对象的 &lt;code&gt;executeQuery(sql)&lt;/code&gt; 方法来执行 &lt;code&gt;SELECT&lt;/code&gt; 查询操作，或者使用 &lt;code&gt;executeUpdate(sql)&lt;/code&gt; 方法来执行 &lt;code&gt;INSERT&lt;/code&gt;、&lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 操作。&lt;/li&gt;
&lt;li&gt;处理查询结果：如果是 &lt;code&gt;SELECT&lt;/code&gt; 查询操作，通过 &lt;code&gt;ResultSet&lt;/code&gt; 对象来处理查询结果。可以使用 &lt;code&gt;ResultSet&lt;/code&gt; 的 &lt;code&gt;next()&lt;/code&gt; 方法遍历查询结果集，然后通过 &lt;code&gt;getXXX()&lt;/code&gt; 方法获取各个字段的值。&lt;/li&gt;
&lt;li&gt;关闭连接：在完成数据库操作后，需要逐级关闭数据库连接相关对象，即先关闭 &lt;code&gt;ResultSet&lt;/code&gt;，再关闭 &lt;code&gt;Statement&lt;/code&gt;，最后关闭 &lt;code&gt;Connection&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下是一个简单的示例代码，请注意在实际应用中，需要进行异常处理以确保资源的正确释放，以及使用 &lt;code&gt;try-with-resources&lt;/code&gt; 来简化代码和确保资源的及时关闭：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; java.sql.*;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Main&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(String[] args)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;comment&#34;&gt;// 加载数据库驱动程序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            Class.forName(&lt;span class=&#34;string&#34;&gt;&amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;comment&#34;&gt;// 建立数据库连接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;type&#34;&gt;Connection&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;connection&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; DriverManager.getConnection(&lt;span class=&#34;string&#34;&gt;&amp;quot;jdbc:mysql://localhost:3306/mydatabase&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;username&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;password&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;comment&#34;&gt;// 创建 Statement 对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;type&#34;&gt;Statement&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;statement&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; connection.createStatement();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;comment&#34;&gt;// 执行 SQL 查询&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;type&#34;&gt;ResultSet&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;resultSet&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; statement.executeQuery(&lt;span class=&#34;string&#34;&gt;&amp;quot;SELECT * FROM mytable&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;comment&#34;&gt;// 处理查询结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (resultSet.next()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;comment&#34;&gt;// 处理每一行数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;comment&#34;&gt;// 关闭资源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            resultSet.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            statement.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            connection.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125; &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (ClassNotFoundException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125; &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (SQLException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;6-4-如果项目中要用到原生的-MyBatis-去查询，该怎样写？&#34;&gt;6.4 如果项目中要用到原生的 MyBatis 去查询，该怎样写？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;配置 MyBatis：在配置文件中配置数据源、MyBatis 的 Mapper 文件位置等信息。&lt;/li&gt;
&lt;li&gt;创建实体类：创建与数据库表对应的实体类，字段名和类型需与数据库表保持一致：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;package&lt;/span&gt; com.example.model.User;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;User&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; Long id;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; String username;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; String email;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// Getters and setters&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;编写 SQL 映射文件：在 &lt;code&gt;resources&lt;/code&gt; 目录下创建 XML 文件，定义 SQL 语句和映射关系：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight xml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;&amp;lt;!-- userMapper.xml --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;mapper&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;namespace&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;com.example.dao.UserMapper&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;id&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;selectUserById&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;resultType&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;com.example.model.User&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        SELECT * FROM users WHERE id = #&amp;#123;id&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;select&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;mapper&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;编写 DAO 接口：创建 DAO 接口，定义查询方法：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;package&lt;/span&gt; com.example.dao.UserMapper;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;UserMapper&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    User &lt;span class=&#34;title function_&#34;&gt;selectUserById&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(Long id)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;编写具体的 SQL 查询语句：在 XML 文件中编写对应的 SQL 语句。&lt;/li&gt;
&lt;li&gt;调用查询方法：在服务层或控制层中调用 DAO 接口中的方法进行查询：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 在 Service 层中调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;User&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;user&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; userMapper.selectUserById(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;6-5-MyBatis-里的-和-区别是什么？&#34;&gt;6.5 MyBatis 里的 # 和 $ 区别是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MyBatis 在处理 &lt;code&gt;#&amp;#123;&amp;#125;&lt;/code&gt; 时，会创建预编译的 SQL 语句，将 SQL 中的 &lt;code&gt;#&amp;#123;&amp;#125;&lt;/code&gt; 替换为 &lt;code&gt;?&lt;/code&gt; 号（参数占位符），在执行 SQL 时会为预编译 SQL 中的占位符（&lt;code&gt;?&lt;/code&gt;）赋值，调用 &lt;code&gt;PreparedStatement&lt;/code&gt; 的 &lt;code&gt;set&lt;/code&gt; 方法来赋值，预编译的 SQL 语句执行效率高，并且可以防止 SQL 注入（SQL 注入是攻击者通过在输入参数中插入恶意 SQL 代码，篡改原始 SQL 语句逻辑的攻击方式），提供更高的安全性，适合传递参数值。&lt;/li&gt;
&lt;li&gt;MyBatis 在处理 &lt;code&gt;$&amp;#123;&amp;#125;&lt;/code&gt; 时，只是创建普通的 SQL 语句，然后在执行 SQL 语句时 MyBatis 将参数直接拼入到 SQL 里（简单的字符串替换），不能防止 SQL 注入，因为参数直接拼接到 SQL 语句中，如果参数未经过验证、过滤，可能会导致安全问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;#&amp;#123;&amp;#125;&lt;/code&gt; 使用 JDBC 预编译机制，将参数值&lt;strong&gt;独立&lt;/strong&gt;传输给数据库，数据库&lt;strong&gt;先编译 SQL 结构&lt;/strong&gt;，再将参数值作为&lt;strong&gt;纯数据&lt;/strong&gt;处理：恶意代码会被视为&lt;strong&gt;数据值&lt;/strong&gt;而&lt;strong&gt;非可执行代码&lt;/strong&gt;：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// MyBatis 底层实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;PreparedStatement&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;ps&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; connection.prepareStatement(&lt;span class=&#34;string&#34;&gt;&amp;quot;SELECT * FROM user WHERE id = ?&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ps.setInt(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, id);  &lt;span class=&#34;comment&#34;&gt;// 安全参数绑定&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;例如我们有以下两种写法：&lt;/p&gt;
&lt;figure class=&#34;highlight xml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;&amp;lt;!-- 安全写法 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;id&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;safeSearch&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    SELECT * FROM user WHERE name = #&amp;#123;name&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;select&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;&amp;lt;!-- 危险写法 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;id&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;dangerSearch&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    SELECT * FROM user WHERE name = &amp;#x27;$&amp;#123;name&amp;#125;&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;select&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不同输入的执行结果如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;传入参数&lt;/th&gt;
&lt;th&gt;&lt;code&gt;safeSearch&lt;/code&gt; 生成的 SQL&lt;/th&gt;
&lt;th&gt;&lt;code&gt;dangerSearch&lt;/code&gt; 生成的 SQL&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Alice&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SELECT * FROM user WHERE name = &#39;Alice&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SELECT * FROM user WHERE name = &#39;Alice&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;正常查询 Alice&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39; OR 1=1 --&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SELECT * FROM user WHERE name = &amp;quot;\&#39; OR 1=1 --&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SELECT * FROM user WHERE name = &#39;&#39; OR 1=1 --&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;前者查询 &lt;code&gt;\&#39; OR 1=1 --&lt;/code&gt; 用户的信息，后者非法查询所有用户的信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;具体看一下这两条 SQL 语句的执行逻辑：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- 直接将 &amp;quot;\&amp;#x27; OR 1=1 --&amp;quot; 最为用户名进行查询&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;user&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; name &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &amp;quot;\&amp;#x27; OR 1=1 --&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- &amp;quot;--&amp;quot; 将后续的内容全部注释掉，然后通过永真条件 1=1 成功查询 user 表的所有用户&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;user&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; name &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;&amp;#x27;&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;OR&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;comment&#34;&gt;--&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;6-6-MyBatisPlus-和-MyBatis-的区别？&#34;&gt;6.6 MyBatisPlus 和 MyBatis 的区别？&lt;/h3&gt;
&lt;p&gt;MyBatisPlus 是一个基于 MyBatis 的增强工具库，旨在简化开发并提高效率。以下是 MyBatisPlus 和 MyBatis 之间的一些主要区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CRUD 操作：MyBatisPlus 通过继承 BaseMapper 接口，提供了一系列内置的快捷方法，使得 CRUD 操作更加简单，无需编写重复的 SQL 语句。&lt;/li&gt;
&lt;li&gt;代码生成器：MyBatisPlus 提供了代码生成器功能，可以根据数据库表结构自动生成实体类、Mapper 接口以及 XML 映射文件，减少了手动编写的工作量。&lt;/li&gt;
&lt;li&gt;通用方法封装：MyBatisPlus 封装了许多常用的方法，如条件构造器、排序、分页查询等，简化了开发过程，提高了开发效率。&lt;/li&gt;
&lt;li&gt;分页插件：MyBatisPlus 内置了分页插件，支持各种数据库的分页查询，开发者可以轻松实现分页功能，而在传统的 MyBatis 中，需要开发者自己手动实现分页逻辑。&lt;/li&gt;
&lt;li&gt;多租户支持：MyBatisPlus 提供了多租户的支持，可以轻松实现多租户数据隔离的功能。&lt;/li&gt;
&lt;li&gt;注解支持：MyBatisPlus 引入了更多的注解支持，使得开发者可以通过注解来配置实体与数据库表之间的映射关系，减少了 XML 配置文件的编写。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6-7-MyBatis-运用了哪些常见的设计模式？&#34;&gt;6.7 MyBatis 运用了哪些常见的设计模式？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;代理模式：MyBatis 实现的核心，比如 &lt;code&gt;MapperProxy&lt;/code&gt;、&lt;code&gt;ConnectionLogger&lt;/code&gt;，用的 JDK 的动态代理；还有 &lt;code&gt;executor.loader&lt;/code&gt; 包使用了 CGLIB 或者 Javassist 达到延迟加载的效果。&lt;/li&gt;
&lt;li&gt;单例模式：例如 &lt;code&gt;ErrorContext&lt;/code&gt; 和 &lt;code&gt;LogFactory&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;工厂模式：例如 &lt;code&gt;SqlSessionFactory&lt;/code&gt;、&lt;code&gt;ObjectFactory&lt;/code&gt;、&lt;code&gt;MapperProxyFactory&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;建造者模式（Builder）：例如 &lt;code&gt;SqlSessionFactoryBuilder&lt;/code&gt;、&lt;code&gt;XMLConfigBuilder&lt;/code&gt;、&lt;code&gt;XMLMapperBuilder&lt;/code&gt;、&lt;code&gt;XMLStatementBuilder&lt;/code&gt;、&lt;code&gt;CacheBuilder&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;组合模式：例如 &lt;code&gt;SqlNode&lt;/code&gt; 和各个子类 &lt;code&gt;ChooseSqlNode&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;模板方法模式：例如 &lt;code&gt;BaseExecutor&lt;/code&gt; 和 &lt;code&gt;SimpleExecutor&lt;/code&gt;，还有 &lt;code&gt;BaseTypeHandler&lt;/code&gt; 和所有的子类例如 &lt;code&gt;IntegerTypeHandler&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;适配器模式：例如 &lt;code&gt;Log&lt;/code&gt; 的 MybBatis 接口和它对 JDBC、Log4j 等各种日志框架的适配实现。&lt;/li&gt;
&lt;li&gt;装饰者模式：例如 &lt;code&gt;Cache&lt;/code&gt; 包中的 &lt;code&gt;cache.decorators&lt;/code&gt; 子包中等各个装饰者的实现。&lt;/li&gt;
&lt;li&gt;迭代器模式：例如迭代器模式 &lt;code&gt;PropertyTokenizer&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="Interview" />
        <updated>2023-11-24T09:09:00.000Z</updated>
    </entry>
    <entry>
        <id>https://asanosaki.github.io/posts/53737.html</id>
        <title>Java进阶面试题总结</title>
        <link rel="alternate" href="https://asanosaki.github.io/posts/53737.html"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;Java 进阶面试题总结，涉及集合、并发、JVM 等内容，文章将不断更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;h2 id=&#34;1-Java-集合&#34;&gt;1. Java 集合&lt;/h2&gt;
&lt;h3 id=&#34;1-1-Java-中常见的集合有哪些？&#34;&gt;1.1 Java 中常见的集合有哪些？&lt;/h3&gt;
&lt;p&gt;Java 中的集合主要可以分为四个部分：&lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;、&lt;code&gt;Map&lt;/code&gt; 和工具类（如 &lt;code&gt;Iterator&lt;/code&gt; 迭代器、&lt;code&gt;Enumeration&lt;/code&gt; 枚举类、&lt;code&gt;Arrays&lt;/code&gt; 和 &lt;code&gt;Collections&lt;/code&gt;）。这些集合类主要由两个接口派生而来，即 &lt;code&gt;Collection&lt;/code&gt;（包含 &lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;、&lt;code&gt;Queue&lt;/code&gt;）和 &lt;code&gt;Map&lt;/code&gt;，它们是集合框架的根接口。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;List&lt;/code&gt;：一种&lt;strong&gt;有序&lt;/strong&gt;列表的集合，例如，按索引排列的元素的 &lt;code&gt;List&lt;/code&gt;。常见的实现类有 &lt;code&gt;ArrayList&lt;/code&gt;、&lt;code&gt;LinkedList&lt;/code&gt; 和 &lt;code&gt;Vector&lt;/code&gt;。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ArrayList&lt;/code&gt; 是容量可变的&lt;strong&gt;非线程安全&lt;/strong&gt;列表，其底层使用&lt;strong&gt;数组&lt;/strong&gt;实现。当几何扩容时，会创建更大的数组，并把原数组的内容复制到新数组中。&lt;code&gt;ArrayList&lt;/code&gt; 支持对元素的快速随机访问，但插入与删除速度很慢。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedList&lt;/code&gt; 本质是一个双向链表，与 &lt;code&gt;ArrayList&lt;/code&gt; 相比，其插入和删除速度更快，但随机访问速度更慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Set&lt;/code&gt;：一种保证&lt;strong&gt;没有重复元素&lt;/strong&gt;的集合。常见的实现类有 &lt;code&gt;HashSet&lt;/code&gt;、&lt;code&gt;LinkedHashSet&lt;/code&gt; 和 &lt;code&gt;TreeSet&lt;/code&gt;。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HashSet&lt;/code&gt; 通过 &lt;code&gt;HashMap&lt;/code&gt; 实现，&lt;code&gt;HashMap&lt;/code&gt; 的 Key 即为 &lt;code&gt;HashSet&lt;/code&gt; 存储的元素，所有 Key 都是用相同的 Value，一个名为 &lt;code&gt;PRESENT&lt;/code&gt; 的 &lt;code&gt;Object&lt;/code&gt; 类型常量。使用 Key 保证元素唯一性，但不保证有序性。由于 &lt;code&gt;HashSet&lt;/code&gt; 是 &lt;code&gt;HashMap&lt;/code&gt; 实现的，因此&lt;strong&gt;线程不安全&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedHashSet&lt;/code&gt; 继承自 &lt;code&gt;HashSet&lt;/code&gt;，通过 &lt;code&gt;LinkedHashMap&lt;/code&gt; 实现，使用双向链表维护元素&lt;strong&gt;插入顺序&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TreeSet&lt;/code&gt; 通过 &lt;code&gt;TreeMap&lt;/code&gt; 实现的，添加元素到集合时按照比较规则将其插入合适的位置，保证插入后的集合仍然&lt;strong&gt;有序&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Map&lt;/code&gt;：一种通过键值（Key-Value）查找的映射表集合，Key 无序且唯一；Value 不要求有序，允许重复，&lt;code&gt;Map&lt;/code&gt; 没有继承于 &lt;code&gt;Collection&lt;/code&gt; 接口。常见的实现类有 &lt;code&gt;HashMap&lt;/code&gt;、&lt;code&gt;TreeMap&lt;/code&gt;、&lt;code&gt;Hashtable&lt;/code&gt;、&lt;code&gt;LinkedHashMap&lt;/code&gt; 和 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HashMap&lt;/code&gt;：JDK1.8 之前 &lt;code&gt;HashMap&lt;/code&gt; 由数组+链表组成的，数组是 &lt;code&gt;HashMap&lt;/code&gt; 的主体，链表则是主要为了解决哈希冲突而存在的（拉链法解决冲突），JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;：&lt;code&gt;LinkedHashMap&lt;/code&gt; 继承自 &lt;code&gt;HashMap&lt;/code&gt;，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，&lt;code&gt;LinkedHashMap&lt;/code&gt; 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序，同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt;：数组+链表组成的，数组是 &lt;code&gt;Hashtable&lt;/code&gt; 的主体，链表则是主要为了解决哈希冲突而存在的，&lt;code&gt;Hashtable&lt;/code&gt; 是&lt;strong&gt;线程安全&lt;/strong&gt;的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TreeMap&lt;/code&gt;：红黑树（自平衡的排序二叉树）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;：&lt;code&gt;Node&lt;/code&gt; 数组+链表+红黑树实现，是&lt;strong&gt;线程安全&lt;/strong&gt;的（JDK1.8 以前 Segment 锁，1.8 以后 Volatile + CAS 或者 Synchronized）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-2-线程安全的集合有哪些？&#34;&gt;1.2 线程安全的集合有哪些？&lt;/h3&gt;
&lt;p&gt;Java 中的线程安全集合主要包括以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;java.util&lt;/code&gt; 包中的线程安全的类主要有 3 个，其他都是非线程安全的：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Vector&lt;/code&gt;：这是一个线程安全的动态数组，其内部方法基本都经过 &lt;code&gt;synchronized&lt;/code&gt; 关键字修饰，它提供了与 &lt;code&gt;ArrayList&lt;/code&gt; 类似的功能，但每个方法都是同步的，这意味着在多线程环境下，它的性能会比 &lt;code&gt;ArrayList&lt;/code&gt; 差，毕竟同步是有额外开销的。。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stack&lt;/code&gt;：这是一个线程安全的栈实现，它继承自 &lt;code&gt;Vector&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt;：这是一个线程安全的哈希表实现，类似于 &lt;code&gt;HashMap&lt;/code&gt;，但是 &lt;code&gt;Hashtable&lt;/code&gt; 的方法都是同步的，&lt;code&gt;HashTable&lt;/code&gt; 的加锁方法是给每个方法加上 &lt;code&gt;synchronized&lt;/code&gt; 关键字，这样锁住的是整个 Table 对象，不支持 &lt;code&gt;null&lt;/code&gt; 键和值，由于同步导致的性能开销，所以已经很少被推荐使用，如果要使用线程安全的哈希表，可以用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.util.concurrent&lt;/code&gt; 包提供的都是线程安全的集合：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt;：这是一个线程安全的队列实现，适用于高并发场景，使用了非阻塞算法，它通过无锁的方式（CAS），实现了高并发状态下的高性能，性能要好于 &lt;code&gt;BlockingQueue&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BlockingQueue&lt;/code&gt; 接口的实现类，如 &lt;code&gt;ArrayBlockingQueue&lt;/code&gt;，&lt;code&gt;LinkedBlockingQueue&lt;/code&gt; 等。&lt;code&gt;BlockingQueue&lt;/code&gt; 的主要功能并不是在于提升高并发时的队列性能，而在于&lt;strong&gt;简化多线程间的数据共享&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; 和 &lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;：这是两个线程安全的集合，它们会在修改操作时复制一份数据，避免了修改时的并发问题。其中所有写操作（&lt;code&gt;add&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt; 等）都通过对底层数组进行全新复制来实现，允许存储 &lt;code&gt;null&lt;/code&gt; 元素，当对象进行写操作时，使用了 Lock 锁做同步处理，内部拷贝了原数组，并在新数组上进行添加操作，最后将新数组替换掉旧数组；若进行读操作，则直接返回结果，操作过程中不需要进行同步。&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt; 和 &lt;code&gt;HashSet&lt;/code&gt; 虽然都继承于共同的父类 &lt;code&gt;AbstractSet&lt;/code&gt;，但是 &lt;code&gt;HashSet&lt;/code&gt; 是通过散列表实现的，而 &lt;code&gt;CopyOnWriteArraySet&lt;/code&gt; 则是通过动态数组 &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; 实现的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;：这是一个线程安全的 &lt;code&gt;HashMap&lt;/code&gt;，它通过将数据&lt;strong&gt;分段&lt;/strong&gt;，从而达到并发控制，性能要优于 &lt;code&gt;Hashtable&lt;/code&gt;，它与 &lt;code&gt;HashTable&lt;/code&gt; 的主要区别是二者加锁粒度的不同。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcurrentSkipListMap&lt;/code&gt;：线程安全且排序的哈希表，实现了一个基于 SkipList（跳表）算法的可排序的并发集合，SkipList 是一种可以在对数预期时间内完成搜索、插入、删除等操作的数据结构，通过维护多个指向其他元素的跳跃链接来实现高效查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;值得注意的是，为了保证集合是线程安全的，相应的效率也比较低；线程不安全的集合效率相对会高一些。如果你的代码只在一个线程中运行，或者多个线程只是读取集合而不修改集合，那么你可以选择线程不安全的集合，因为它们的性能通常会更好。&lt;/p&gt;
&lt;h3 id=&#34;1-3-Collections-和-Collection-的区别是什么？&#34;&gt;1.3 Collections 和 Collection 的区别是什么？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Collection&lt;/code&gt; 是 Java 集合框架中的一个&lt;strong&gt;接口&lt;/strong&gt;，它是所有集合类的基础接口。它定义了一组通用的操作和方法，如添加、删除、遍历等，用于操作和管理一组对象。&lt;code&gt;Collection&lt;/code&gt; 接口有许多实现类，如 &lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt; 和 &lt;code&gt;Queue&lt;/code&gt; 等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Collections&lt;/code&gt; 是 Java 提供的一个&lt;strong&gt;工具类&lt;/strong&gt;，位于 &lt;code&gt;java.util&lt;/code&gt; 包中。它提供了一系列&lt;strong&gt;静态方法&lt;/strong&gt;，用于对集合进行操作和算法。&lt;code&gt;Collections&lt;/code&gt; 类中的方法包括排序、查找、替换、反转、随机化等等，这些方法可以对实现了 &lt;code&gt;Collection&lt;/code&gt; 接口的集合进行操作，如 &lt;code&gt;List&lt;/code&gt; 和 &lt;code&gt;Set&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;1-4-集合遍历的方法有哪些？&#34;&gt;1.4 集合遍历的方法有哪些？&lt;/h3&gt;
&lt;p&gt;（1）普通 &lt;code&gt;for&lt;/code&gt; 循环：可以使用带有索引的普通 &lt;code&gt;for&lt;/code&gt; 循环来遍历 &lt;code&gt;List&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;List&amp;lt;Integer&amp;gt; list = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;(List.of(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    System.out.println(list.get(i));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（2）增强 &lt;code&gt;for&lt;/code&gt; 循环（&lt;code&gt;for-each&lt;/code&gt; 循环）：用于循环访问数组或集合中的元素：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;List&amp;lt;Integer&amp;gt; list = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;(List.of(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (Integer x : list) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    System.out.println(x);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（3）&lt;code&gt;Iterator&lt;/code&gt; 迭代器：可以使用迭代器来遍历集合，特别适用于需要删除元素的情况：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;List&amp;lt;Integer&amp;gt; list = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;(List.of(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Iterator&amp;lt;Integer&amp;gt; iterator = list.iterator();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt;(iterator.hasNext()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; iterator.next();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    System.out.println(x);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（4）&lt;code&gt;ListIterator&lt;/code&gt; 列表迭代器：&lt;code&gt;ListIterator&lt;/code&gt; 是迭代器的子类，可以双向访问列表并在迭代过程中修改元素：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;List&amp;lt;Integer&amp;gt; list = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;(List.of(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ListIterator&amp;lt;Integer&amp;gt; listIterator = list.listIterator();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt;(listIterator.hasNext()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; listIterator.next();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    System.out.println(x);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（5）使用 &lt;code&gt;forEach&lt;/code&gt; 方法：Java 8 引入了 &lt;code&gt;forEach&lt;/code&gt; 方法，可以对集合进行快速遍历：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;List&amp;lt;Integer&amp;gt; list = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;(List.of(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;list.forEach(x -&amp;gt; System.out.print(x + &lt;span class=&#34;string&#34;&gt;&amp;quot; &amp;quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;list.forEach(System.out::println);  &lt;span class=&#34;comment&#34;&gt;// 如果不需要自定义方法的参数可以将 Lambda 改写为方法引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（6）Stream API：Java 8 的 Stream API 提供了丰富的功能，可以对集合进行函数式操作，如过滤、映射等：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;List&amp;lt;Integer&amp;gt; list = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;(List.of(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;list.stream().filter(x -&amp;gt; x &amp;gt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;).forEach(x -&amp;gt; System.out.print(x + &lt;span class=&#34;string&#34;&gt;&amp;quot; &amp;quot;&lt;/span&gt;));  &lt;span class=&#34;comment&#34;&gt;// 输出：2 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-5-ArrayList-和-LinkedList-的异同点是什么？&#34;&gt;1.5 ArrayList 和 LinkedList 的异同点是什么？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; 和 &lt;code&gt;LinkedList&lt;/code&gt; 都是 Java 中常用的 &lt;code&gt;List&lt;/code&gt; 实现类，它们有一些共同点，也有一些不同点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共同点：&lt;code&gt;ArrayList&lt;/code&gt; 和 &lt;code&gt;LinkedList&lt;/code&gt; 都是单列集合中 &lt;code&gt;List&lt;/code&gt; 接口的实现类，它们都是存取允许重复，且有序的元素。&lt;/li&gt;
&lt;li&gt;不同点：
&lt;ul&gt;
&lt;li&gt;底层数据结构：&lt;code&gt;ArrayList&lt;/code&gt; 是基于动态数组实现的，底层使用数组来存储元素。而 &lt;code&gt;LinkedList&lt;/code&gt; 是基于链表实现的，底层使用双向链表来存储元素。&lt;/li&gt;
&lt;li&gt;随机访问：对于随机访问 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 方法，&lt;code&gt;ArrayList&lt;/code&gt; 的速度通常优于 &lt;code&gt;LinkedList&lt;/code&gt;，因为 &lt;code&gt;ArrayList&lt;/code&gt; 可以根据下标以 &lt;code&gt;O(1)&lt;/code&gt; 的时间复杂度对元素进行随机访问，而 &lt;code&gt;LinkedList&lt;/code&gt; 的每一个元素都依靠地址指针和它后一个元素连接在一起，查找某个元素的时间复杂度是 &lt;code&gt;O(n)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;插入和删除操作：对于插入和删除操作，&lt;code&gt;LinkedList&lt;/code&gt; 的速度通常优于 &lt;code&gt;ArrayList&lt;/code&gt;，因为当元素被添加到 &lt;code&gt;LinkedList&lt;/code&gt; 任意位置的时候，不需要像 &lt;code&gt;ArrayList&lt;/code&gt; 那样重新计算大小或者是更新索引。&lt;code&gt;ArrayList&lt;/code&gt; 在尾部的插入和删除操作效率较高，但在中间或开头的插入和删除操作效率较低，需要移动元素。&lt;/li&gt;
&lt;li&gt;内存占用：&lt;code&gt;LinkedList&lt;/code&gt; 比 &lt;code&gt;ArrayList&lt;/code&gt; 更占内存，因为 &lt;code&gt;LinkedList&lt;/code&gt; 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。而 &lt;code&gt;ArrayList&lt;/code&gt; 使用数组来存储元素，因此插入和删除元素时需要移动其他元素占用内存，所以在频繁进行插入和删除操作时，&lt;code&gt;ArrayList&lt;/code&gt; 的性能会比较低，且可能会造成内存浪费。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-6-ArrayList-的扩容机制是什么？&#34;&gt;1.6 ArrayList 的扩容机制是什么？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; 的扩容机制是其核心特性之一。在 &lt;code&gt;ArrayList&lt;/code&gt; 中添加元素时，如果当前的数组已经满了，那么 &lt;code&gt;ArrayList&lt;/code&gt; 会创建一个新的、更大的数组，并将原有数组的元素复制到新的数组中，这个过程就叫做扩容。&lt;/p&gt;
&lt;p&gt;具体来说，&lt;code&gt;ArrayList&lt;/code&gt; 的扩容机制如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当向 &lt;code&gt;ArrayList&lt;/code&gt; 中添加元素时，首先会检查 &lt;code&gt;ArrayList&lt;/code&gt; 的当前大小（也就是它内部的数组大小）是否能够容纳新的元素。如果可以，那么新元素就直接被添加到 &lt;code&gt;ArrayList&lt;/code&gt; 中。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;ArrayList&lt;/code&gt; 的当前大小不足以容纳新的元素，那么 &lt;code&gt;ArrayList&lt;/code&gt; 就需要进行扩容操作。在扩容操作中，&lt;code&gt;ArrayList&lt;/code&gt; 会创建一个新的数组，新数组的大小是原数组大小的 1.5 倍，这个值是在 JDK 的源码中定义的，之所以扩容是 1.5 倍，是因为 1.5 可以充分利用移位操作，减少浮点数或者运算时间和运算次数：&lt;code&gt;newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;接着，&lt;code&gt;ArrayList&lt;/code&gt; 会使用 &lt;code&gt;System.arraycopy&lt;/code&gt; 方法，将原有数组中的所有元素复制到新的数组中。&lt;/li&gt;
&lt;li&gt;最后，新的数组会替代原有的数组，成为 &lt;code&gt;ArrayList&lt;/code&gt; 的内部数组。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;值得注意的是，&lt;code&gt;ArrayList&lt;/code&gt; 的扩容操作需要重新分配内存空间，并将原来的元素复制到新的数组中，这可能会导致性能问题。因此，在实例化 &lt;code&gt;ArrayList&lt;/code&gt; 时设置足够的初始容量，并且尽可能减少数组扩容的次数，可以帮助提高性能：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;List&amp;lt;Integer&amp;gt; list = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;(&lt;span class=&#34;number&#34;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-7-为什么-ArrayList-不是线程安全的，具体来说是哪里不安全？&#34;&gt;1.7 为什么 ArrayList 不是线程安全的，具体来说是哪里不安全？&lt;/h3&gt;
&lt;p&gt;首先 &lt;code&gt;ArrayList&lt;/code&gt; 的 &lt;code&gt;add&lt;/code&gt; 添加元素方法的代码如下：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(E e)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    modCount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (s == elementData.length)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        elementData = grow();  &lt;span class=&#34;comment&#34;&gt;// 扩容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    elementData[s] = e;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    size = s + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在高并发添加数据下，&lt;code&gt;ArrayList&lt;/code&gt; 会暴露以下三个问题：&lt;/p&gt;
&lt;p&gt;（1）部分值为 &lt;code&gt;null&lt;/code&gt;（我们并没有 &lt;code&gt;add(null)&lt;/code&gt; 进去）&lt;/p&gt;
&lt;p&gt;当线程 1 走到了扩容那里发现当前 &lt;code&gt;size&lt;/code&gt; 是 9，而数组容量是 10，所以不用扩容，这时候 CPU 让出执行权，线程 2 也进来了，发现 &lt;code&gt;size&lt;/code&gt; 是 9，而数组容量是 10，所以不用扩容，这时候线程 1 继续执行，将数组下标索引为 9 的位置 &lt;code&gt;set&lt;/code&gt; 值了，还没有来得及执行 &lt;code&gt;size = s + 1&lt;/code&gt;，这时候线程 2 也来执行了，又把数组下标索引为 9 的位置 &lt;code&gt;set&lt;/code&gt; 了一遍，这时候两个线程先后执行 &lt;code&gt;size = s + 1&lt;/code&gt;，导致下标索引 10 的地方就为 &lt;code&gt;null&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;（2）索引越界异常&lt;/p&gt;
&lt;p&gt;线程 1 走到扩容那里发现当前 &lt;code&gt;size&lt;/code&gt; 是 9，数组容量是 10 不用扩容，CPU 让出执行权，线程 2 也发现不用扩容，这时候数组的容量就是 10，而线程 1 &lt;code&gt;set&lt;/code&gt; 完之后执行 &lt;code&gt;size = s + 1&lt;/code&gt;，这时候线程 2 再进来 &lt;code&gt;size&lt;/code&gt; 就是 10，数组的大小只有 10，而你要设置下标索引为 10 的位置就会越界。&lt;/p&gt;
&lt;p&gt;（3）&lt;code&gt;size&lt;/code&gt; 与我们 &lt;code&gt;add&lt;/code&gt; 的数量不符&lt;/p&gt;
&lt;p&gt;这个基本上每次都会发生，这个理解起来也很简单，因为 &lt;code&gt;size = s + 1&lt;/code&gt; 本身就不是原子操作，可以分为三步：获取 &lt;code&gt;s&lt;/code&gt; 的值，将 &lt;code&gt;s&lt;/code&gt; 的值加 1，将新的 &lt;code&gt;s&lt;/code&gt; 值覆盖掉原来的 &lt;code&gt;size&lt;/code&gt;，线程 1 和线程 2 拿到一样的 &lt;code&gt;s&lt;/code&gt; 值加完了同时覆盖，就会导致有一次没有加上。&lt;/p&gt;
&lt;h3 id=&#34;1-8-CopyOnWriteArrayList-是如何实现线程安全的？&#34;&gt;1.8 CopyOnWriteArrayList 是如何实现线程安全的？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; 底层也是通过一个数组保存数据，使用 &lt;code&gt;volatile&lt;/code&gt; 关键字修饰数组，保证当前线程对数组对象重新赋值后，其他线程可以及时感知到：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;transient&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;volatile&lt;/span&gt; Object[] array;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来看一下 &lt;code&gt;CopyOnWriteArrayList&lt;/code&gt; 添加元素的源码：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(E e)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;synchronized&lt;/span&gt; (lock) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        Object[] es = getArray();  &lt;span class=&#34;comment&#34;&gt;// 获取到当前 List 集合保存数据的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; es.length;  &lt;span class=&#34;comment&#34;&gt;// 获取该数组的长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        es = Arrays.copyOf(es, len + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;// 将当前数组拷贝一份的同时，让其长度加一&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        es[len] = e;  &lt;span class=&#34;comment&#34;&gt;// 将加入的元素放在新数组最后一位&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        setArray(es);  &lt;span class=&#34;comment&#34;&gt;// 替换引用，将数组的引用指向给新数组的地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;写入新元素时，首先会先将原来的数组拷贝一份并且让原来数组的长度加一后就得到了一个新数组，新数组里的元素和旧数组的元素一样并且长度比旧数组多一个长度，然后将新加入的元素放置在新数组最后一个位置，最后用新数组的地址替换掉老数组的地址就能得到最新的数据了。&lt;/p&gt;
&lt;p&gt;在我们执行替换地址操作之前，读取的是老数组的数据，数据是有效数据；执行替换地址操作之后，读取的是新数组的数据，同样也是有效数据，而且使用该方式能比读写都加锁要更加的效率。&lt;/p&gt;
&lt;p&gt;现在我们来看读操作，读是没有加锁的，所以读是一直都能读：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; E &lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; index)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; elementAt(getArray(), index);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-9-HashMap-的底层数据结构是什么？&#34;&gt;1.9 HashMap 的底层数据结构是什么？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt; 的底层数据结构主要包括哈希表（数组）、链表和红黑树。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希表（数组）：&lt;code&gt;HashMap&lt;/code&gt; 主要依赖于哈希表来存储数据。哈希表中的每个元素被称为槽位（Bucket）。数组的每个位置都可以存放一个元素（键值对），数组的索引是通过&lt;strong&gt;键的哈希码&lt;/strong&gt;经过&lt;strong&gt;哈希函数&lt;/strong&gt;计算得来的。这样我们就可以通过键快速定位到数组的某个位置，取出相应的值，这就是 &lt;code&gt;HashMap&lt;/code&gt; 快速获取数据的原理。&lt;/li&gt;
&lt;li&gt;链表：在理想的情况下，哈希函数将每个键均匀地散列到哈希表的各个位置。但在实际中，我们可能会遇到两个不同的键计算出相同的哈希值，这就是所谓的&lt;strong&gt;哈希冲突&lt;/strong&gt;。&lt;code&gt;HashMap&lt;/code&gt; 通过使用链表来解决这个问题。当哈希冲突发生时，&lt;code&gt;HashMap&lt;/code&gt; 会在冲突的 Bucket 增加一个链表，新的元素会被添加到链表的末尾。每个链表中的元素都包含了相同哈希值的键值对。&lt;/li&gt;
&lt;li&gt;红黑树：从 Java 8 开始，如果链表的长度超过一定的阈值（默认为 8），那么链表会被转换为红黑树。红黑树是一种自平衡的二叉查找树，通过保持树的平衡，可以提高查找效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-10-哈希冲突的解决方法有哪些？&#34;&gt;1.10 哈希冲突的解决方法有哪些？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;链接法：使用链表或其他数据结构来存储冲突的键值对，将它们链接在同一个哈希桶中。&lt;/li&gt;
&lt;li&gt;开放寻址法：在哈希表中找到另一个可用的位置来存储冲突的键值对，而不是存储在链表中。常见的开放寻址方法包括线性探测、二次探测和双重散列。&lt;/li&gt;
&lt;li&gt;再哈希法（Rehashing）：当发生冲突时，使用另一个哈希函数再次计算键的哈希值，直到找到一个空槽来存储键值对。&lt;/li&gt;
&lt;li&gt;哈希桶扩容：当哈希冲突过多时，可以动态地扩大哈希桶的数量，重新分配键值对，以减少冲突的概率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-11-HashMap-的-Put-和-Get-过程介绍一下？&#34;&gt;1.11 HashMap 的 Put 和 Get 过程介绍一下？&lt;/h3&gt;
&lt;p&gt;存储对象时，我们将 &lt;code&gt;&amp;lt;Key, Value&amp;gt;&lt;/code&gt; 传给 &lt;code&gt;put(key, val)&lt;/code&gt; 方法时，它调用 &lt;code&gt;hashCode()&lt;/code&gt; 方法计算哈希值从而得到 Bucket 位置，检查该位置是否为空，如果为空则直接在该位置创建一个新的 &lt;code&gt;Entry&lt;/code&gt; 对象来存储键值对，否则检查该位置的第一个键值对的哈希码和键是否与要添加的键值对相同，如果相同则表示找到了相同的键，直接将新的值替换旧的值，完成更新操作，否则需要遍历链表或红黑树来查找是否有相同的键。完成插入后 &lt;code&gt;HashMap&lt;/code&gt; 会根据当前 Bucket 的占用情况自动调整容量（Load Factor 超过阈值则扩容为原来的 2 倍）。&lt;/p&gt;
&lt;p&gt;获取对象时，我们将 Key 传给 &lt;code&gt;get(key)&lt;/code&gt; 方法，它调用 &lt;code&gt;hashCode()&lt;/code&gt; 计算哈希值从而得到 Bucket 位置，并进一步调用 &lt;code&gt;equals()&lt;/code&gt; 方法确定键值对。&lt;/p&gt;
&lt;h3 id=&#34;1-12-HashMap-调用-Get-方法一定安全吗？&#34;&gt;1.12 HashMap 调用 Get 方法一定安全吗？&lt;/h3&gt;
&lt;p&gt;不一定，调用 &lt;code&gt;get()&lt;/code&gt; 方法有几点需要注意的地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空指针异常（NullPointerException）：如果你尝试用 &lt;code&gt;null&lt;/code&gt; 作为键调用 &lt;code&gt;get()&lt;/code&gt; 方法，而 &lt;code&gt;HashMap&lt;/code&gt; 没有被初始化（即为 &lt;code&gt;null&lt;/code&gt;），那么会抛出空指针异常。不过，如果 &lt;code&gt;HashMap&lt;/code&gt; 已经初始化，使用 &lt;code&gt;null&lt;/code&gt; 作为键是允许的，因为 &lt;code&gt;HashMap&lt;/code&gt; 支持 &lt;code&gt;null&lt;/code&gt; 键（当 Key 为空时，直接令 Key 的哈希值为 0）。&lt;/li&gt;
&lt;li&gt;线程安全：&lt;code&gt;HashMap&lt;/code&gt; 本身不是线程安全的。如果在多线程环境中，没有适当的同步措施，同时对 &lt;code&gt;HashMap&lt;/code&gt; 进行读写操作可能会导致不可预测的行为。例如，在一个线程中调用 &lt;code&gt;get()&lt;/code&gt; 方法读取数据，而另一个线程同时修改了结构（如增加或删除元素），可能会导致读取操作得到错误的结果或抛出 &lt;code&gt;ConcurrentModificationException&lt;/code&gt;。如果需要在多线程环境中使用类似 &lt;code&gt;HashMap&lt;/code&gt; 的数据结构，可以考虑使用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-13-为什么-String-适合做-HashMap-的-Key？&#34;&gt;1.13 为什么 String 适合做 HashMap 的 Key？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;String&lt;/code&gt; 对象是不可变的，一旦创建就不能被修改，这确保了 Key 的稳定性。如果 Key 是可变的，可能会导致 &lt;code&gt;hashCode()&lt;/code&gt; 和 &lt;code&gt;equals()&lt;/code&gt; 方法的不一致，进而影响 &lt;code&gt;HashMap&lt;/code&gt; 的正确性。&lt;/p&gt;
&lt;h3 id=&#34;1-14-为什么-HashMap-要用红黑树而不是平衡二叉树？&#34;&gt;1.14 为什么 HashMap 要用红黑树而不是平衡二叉树？&lt;/h3&gt;
&lt;p&gt;平衡二叉树追求的是&lt;strong&gt;完全平衡&lt;/strong&gt;的状态，即任何结点的左右子树的高度差不会超过 1，优势是树的结点是很平均分配的。这个要求实在是太严了，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过&lt;strong&gt;左旋和右旋&lt;/strong&gt;来进行调整，使之再次成为一颗符合要求的平衡树。&lt;/p&gt;
&lt;p&gt;红黑树不追求这种完全平衡状态，而是追求一种&lt;strong&gt;弱平衡&lt;/strong&gt;状态，即整个树最长路径不会超过最短路径的 2 倍。优势是虽然牺牲了一部分查找的性能效率，但是能够换取一部分维持树平衡状态的成本。与平衡二叉树不同的是，红黑树在插入、删除等操作，&lt;strong&gt;不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁做调整&lt;/strong&gt;，这也是我们为什么大多数情况下使用红黑树的原因。&lt;/p&gt;
&lt;h3 id=&#34;1-15-重写-HashMap-的-equals-和-hashCode-方法需要注意什么？&#34;&gt;1.15 重写 HashMap 的 equals() 和 hashCode() 方法需要注意什么？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt; 在比较元素时，会先通过 &lt;code&gt;hashCode()&lt;/code&gt; 进行比较，相同的情况下再通过 &lt;code&gt;equals()&lt;/code&gt; 进行比较。所以 &lt;code&gt;equals()&lt;/code&gt; 相等的两个对象，&lt;code&gt;hashCode()&lt;/code&gt; 一定相等，而 &lt;code&gt;hashCode()&lt;/code&gt; 相等的两个对象，&lt;code&gt;equals()&lt;/code&gt; 不一定相等（如散列冲突的情况）。&lt;/p&gt;
&lt;p&gt;所有不允许存储重复数据的集合类都使用 &lt;code&gt;hashCode()&lt;/code&gt; 和 &lt;code&gt;equals()&lt;/code&gt; 去查找重复，所以正确实现它们非常重要。&lt;code&gt;equals()&lt;/code&gt; 和 &lt;code&gt;hashCode()&lt;/code&gt; 的实现应该遵循以下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;o1.equals(o2)&lt;/code&gt;，那么 &lt;code&gt;o1.hashCode() == o2.hashCode()&lt;/code&gt; 总是为 &lt;code&gt;true&lt;/code&gt; 的。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;o1.hashCode() == o2.hashCode()&lt;/code&gt;，并不意味着 &lt;code&gt;o1.equals(o2)&lt;/code&gt; 一定为 &lt;code&gt;true&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-16-为什么在解决-Hash-冲突的时候，不直接用红黑树，而是先用链表再转红黑树？&#34;&gt;1.16 为什么在解决 Hash 冲突的时候，不直接用红黑树，而是先用链表再转红黑树？&lt;/h3&gt;
&lt;p&gt;在解决 Hash 冲突的时候，&lt;code&gt;HashMap&lt;/code&gt; 在链表长度大于 8 的时候才会将链表转换为红黑树，而不是直接使用红黑树，这主要有以下几个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询效率：红黑树的平均查找长度是 &lt;code&gt;log(n)&lt;/code&gt;，当链表长度为 8 时，查找长度为 &lt;code&gt;log(8) = 3&lt;/code&gt;，而链表的平均查找长度为 &lt;code&gt;n / 2&lt;/code&gt;，当长度为 8 时，平均查找长度为 &lt;code&gt;8 / 2 = 4&lt;/code&gt;。因此，当链表长度小于等于 8 时，使用链表的查询效率其实并不比红黑树差。&lt;/li&gt;
&lt;li&gt;插入效率和空间效率：链表的插入操作比红黑树快，且链表的空间占用也比红黑树小。因此，在元素数量较少时，使用链表比红黑树更高效。&lt;/li&gt;
&lt;li&gt;防止频繁转换：如果链表长度在 8 左右徘徊，且频繁地进行插入和删除操作，可能会导致链表和红黑树之间频繁地转换，这会降低效率。因此，&lt;code&gt;HashMap&lt;/code&gt; 设计了两个阈值，链表长度超过 8 时转为红黑树，少于 6 时转回链表，这样可以减少转换的频率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总的来说，这种设计是为了在保证查询效率的同时，尽可能地提高插入效率和空间效率，以及减少因频繁转换而带来的开销。&lt;/p&gt;
&lt;h3 id=&#34;1-17-什么是负载因子？为什么-HashMap-的默认负载因子为-0-75？&#34;&gt;1.17 什么是负载因子？为什么 HashMap 的默认负载因子为 0.75？&lt;/h3&gt;
&lt;p&gt;负载因子是用于表示哈希表中元素填满的程度的一个参数。在哈希表（如 Java 的 &lt;code&gt;HashMap&lt;/code&gt;）中，负载因子是和扩容机制有关的，当哈希表中的元素个数超过了容量乘以负载因子时，就会进行扩容。例如，如果初始容量是 16，负载因子是 0.75，&lt;code&gt;16 * 0.75 = 12&lt;/code&gt;，也就是说，当容量达到了 12 的时候就会进行扩容操作。&lt;/p&gt;
&lt;p&gt;负载因子的大小对哈希表的性能有重要影响。如果负载因子过大，那么哈希表中的冲突会更频繁，导致&lt;strong&gt;查找效率降低&lt;/strong&gt;。反之，如果负载因子过小，那么哈希表的空间利用率就会降低，导致&lt;strong&gt;内存浪费&lt;/strong&gt;。因此，选择一个合适的负载因子，可以在时间效率和空间效率之间达到一个平衡。在 Java 的 &lt;code&gt;HashMap&lt;/code&gt; 中，负载因子的默认值是 0.75，这是一个在时间和空间效率之间的折衷选择。&lt;/p&gt;
&lt;h3 id=&#34;1-18-ConcurrentHashMap-是怎么实现的？&#34;&gt;1.18 ConcurrentHashMap 是怎么实现的？&lt;/h3&gt;
&lt;p&gt;在 JDK 1.7 中它使用的是分段数组+链表的形式实现的，而数组又分为：大数组 &lt;code&gt;Segment&lt;/code&gt; 和小数组 &lt;code&gt;HashEntry&lt;/code&gt;。&lt;code&gt;Segment&lt;/code&gt; 是一种可重入锁（ReentrantLock），在 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 里扮演锁的角色，&lt;code&gt;HashEntry&lt;/code&gt; 则用于存储键值对数据。一个 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 里包含一个 &lt;code&gt;Segment&lt;/code&gt; 数组，一个 &lt;code&gt;Segment&lt;/code&gt; 里包含一个 &lt;code&gt;HashEntry&lt;/code&gt; 数组，每个 &lt;code&gt;HashEntry&lt;/code&gt; 是一个链表结构的元素。&lt;/p&gt;
&lt;p&gt;在 JDK 1.7 中，&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 虽然是线程安全的，但因为它的底层实现是数组+链表的形式，所以在数据比较多的情况下访问是很慢的，因为要遍历整个链表。JDK 1.8 则使用了数组+链表/红黑树的方式优化了 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 的实现。&lt;/p&gt;
&lt;p&gt;JDK 1.8 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 主要通过 &lt;code&gt;volatile&lt;/code&gt; 加 CAS（乐观锁）或者 &lt;code&gt;synchronized&lt;/code&gt;（悲观锁）来实现的线程安全的。添加元素时首先会判断容器是否为空：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果为空则使用 &lt;code&gt;volatile&lt;/code&gt; 加 CAS 来初始化。&lt;/li&gt;
&lt;li&gt;如果容器不为空，则根据存储的元素计算该位置是否为空。
&lt;ul&gt;
&lt;li&gt;如果为空，则利用 CAS 设置该节点；&lt;/li&gt;
&lt;li&gt;如果不为空，则使用 &lt;code&gt;synchronized&lt;/code&gt;，然后遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相当于是 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 通过对头结点加锁来保证线程安全的，锁的粒度相比 &lt;code&gt;Segment&lt;/code&gt; 来说更小了，发生冲突和加锁的频率降低了，并发操作的性能就提高了。&lt;/p&gt;
&lt;p&gt;通过上面的介绍可以知道 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 悲观锁和乐观锁都有用到。&lt;/p&gt;
&lt;h2 id=&#34;2-多线程&#34;&gt;2. 多线程&lt;/h2&gt;
&lt;h3 id=&#34;2-1-Java-里面的线程和操作系统的线程一样吗？&#34;&gt;2.1 Java 里面的线程和操作系统的线程一样吗？&lt;/h3&gt;
&lt;p&gt;Java 底层会调用 &lt;code&gt;pthread_create&lt;/code&gt; 来创建线程，所以本质上 Java 程序创建的线程，就是和操作系统线程是一样的，是一对一的线程模型。&lt;/p&gt;
&lt;h3 id=&#34;2-2-使用多线程要注意哪些问题？&#34;&gt;2.2 使用多线程要注意哪些问题？&lt;/h3&gt;
&lt;p&gt;要保证多线程的程序安全，不要出现数据竞争造成的数据混乱的问题。Java 的线程安全在三个方面体现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，在 Java 中使用了 &lt;code&gt;atomic&lt;/code&gt; 包（这个包提供了一些支持原子操作的类，这些类可以在多线程环境下保证操作的原子性）和 &lt;code&gt;synchronized&lt;/code&gt; 关键字来确保原子性。&lt;/li&gt;
&lt;li&gt;可见性：一个线程对主内存的修改可以及时地被其他线程看到，在 Java 中使用了 &lt;code&gt;synchronized&lt;/code&gt; 和 &lt;code&gt;volatile&lt;/code&gt; 这两个关键字确保可见性。&lt;/li&gt;
&lt;li&gt;有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，在 Java 中使用了 &lt;code&gt;happens-before&lt;/code&gt; 原则来确保有序性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-3-保证数据的一致性有哪些方案呢？&#34;&gt;2.3 保证数据的一致性有哪些方案呢？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;事务管理：使用数据库事务来确保一组数据库操作要么全部成功提交，要么全部失败回滚。通过 ACID 属性，数据库事务可以保证数据的一致性。&lt;/li&gt;
&lt;li&gt;锁机制：使用锁来实现对共享资源的互斥访问。在 Java 中，可以使用 &lt;code&gt;synchronized&lt;/code&gt; 关键字、&lt;code&gt;ReentrantLock&lt;/code&gt; 或其他锁机制来控制并发访问，从而避免并发操作导致数据不一致。&lt;/li&gt;
&lt;li&gt;版本控制：通过乐观锁的方式，在更新数据时记录数据的版本信息，从而避免同时对同一数据进行修改，进而保证数据的一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-4-线程的创建方式有哪些？&#34;&gt;2.4 线程的创建方式有哪些？&lt;/h3&gt;
&lt;p&gt;（1）继承 &lt;code&gt;Thread&lt;/code&gt; 类&lt;/p&gt;
&lt;p&gt;这是最直接的一种方式，用户自定义类继承 &lt;code&gt;java.lang.Thread&lt;/code&gt; 类，重写其 &lt;code&gt;run()&lt;/code&gt; 方法，&lt;code&gt;run()&lt;/code&gt; 方法中定义线程执行的具体任务。创建该类的实例后，通过调用 &lt;code&gt;start()&lt;/code&gt; 方法启动线程。&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyThread&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Thread&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 线程执行的代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(String[] args)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;MyThread&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyThread&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    t.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种创建方式的优缺点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：编写简单，如果需要访问当前线程，无需使用 &lt;code&gt;Thread.currentThread()&lt;/code&gt; 方法，直接使用 &lt;code&gt;this&lt;/code&gt; 即可获得当前线程。&lt;/li&gt;
&lt;li&gt;缺点：因为线程类已经继承了 &lt;code&gt;Thread&lt;/code&gt; 类，所以不能再继承其他的父类。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）实现 &lt;code&gt;Runnable&lt;/code&gt; 接口&lt;/p&gt;
&lt;p&gt;实现 &lt;code&gt;Runnable&lt;/code&gt; 接口需要重写 &lt;code&gt;run()&lt;/code&gt; 方法，然后将此 &lt;code&gt;Runnable&lt;/code&gt; 对象作为参数传递给 &lt;code&gt;Thread&lt;/code&gt; 类的构造器，创建 &lt;code&gt;Thread&lt;/code&gt; 对象后调用其 &lt;code&gt;start()&lt;/code&gt; 方法启动线程。&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyRunnable&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Runnable&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 线程执行的代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(String[] args)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;Thread&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Thread&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyRunnable&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    t.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种创建方式的优缺点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：线程类只是实现了 &lt;code&gt;Runable&lt;/code&gt; 接口，还可以继承其他的类，在这种方式下，可以多个线程共享同一个目标对象，所以非常适合&lt;strong&gt;多个相同线程来处理同一份资源&lt;/strong&gt;的情况，从而可以将 CPU 代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。&lt;/li&gt;
&lt;li&gt;缺点：编程有点复杂，如果需要访问当前线程，必须使用 &lt;code&gt;Thread.currentThread()&lt;/code&gt; 方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（3）实现 &lt;code&gt;Callable&lt;/code&gt; 接口与 &lt;code&gt;FutureTask&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java.util.concurrent.Callable&lt;/code&gt; 接口类似于 &lt;code&gt;Runnable&lt;/code&gt;，但 &lt;code&gt;Callable&lt;/code&gt; 的 &lt;code&gt;call()&lt;/code&gt; 方法可以有返回值并且可以抛出异常。要执行 &lt;code&gt;Callable&lt;/code&gt; 任务，需将它包装进一个 &lt;code&gt;FutureTask&lt;/code&gt;，因为 &lt;code&gt;Thread&lt;/code&gt; 类的构造器只接受 &lt;code&gt;Runnable&lt;/code&gt; 参数，而 &lt;code&gt;FutureTask&lt;/code&gt; 实现了 &lt;code&gt;Runnable&lt;/code&gt; 接口。这种创建方式的优缺点与 &lt;code&gt;Runnable&lt;/code&gt; 一样。&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyCallable&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Callable&lt;/span&gt;&amp;lt;Integer&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; Integer &lt;span class=&#34;title function_&#34;&gt;call&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;throws&lt;/span&gt; Exception &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 线程执行的代码，这里返回一个整型结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(String[] args)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;MyCallable&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;task&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MyCallable&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    FutureTask&amp;lt;Integer&amp;gt; futureTask = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;FutureTask&lt;/span&gt;&amp;lt;&amp;gt;(task);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;Thread&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Thread&lt;/span&gt;(futureTask);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    t.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; futureTask.get();  &lt;span class=&#34;comment&#34;&gt;// 获取线程执行结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Result: &amp;quot;&lt;/span&gt; + result);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125; &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (InterruptedException | ExecutionException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（4）使用线程池（Executor 框架）&lt;/p&gt;
&lt;p&gt;Java 5 开始引入的 &lt;code&gt;java.util.concurrent.ExecutorService&lt;/code&gt; 和相关类提供了线程池的支持，这是一种更高效的线程管理方式，避免了频繁创建和销毁线程的开销。可以通过 &lt;code&gt;Executors&lt;/code&gt; 类的静态方法创建不同类型的线程池。&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Task&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Runnable&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;meta&#34;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 线程执行的代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(String[] args)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;ExecutorService&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;executor&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; Executors.newFixedThreadPool(&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;// 创建固定大小的线程池&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;number&#34;&gt;100&lt;/span&gt;; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        executor.submit(&lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Task&lt;/span&gt;());  &lt;span class=&#34;comment&#34;&gt;// 提交任务到线程池执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    executor.shutdown();  &lt;span class=&#34;comment&#34;&gt;// 关闭线程池&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种创建方式的优缺点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：线程池可以重用预先创建的线程，避免了线程创建和销毁的开销，显著提高了程序的性能。对于需要快速响应的并发请求，线程池可以迅速提供线程来处理任务，减少等待时间。并且，线程池能够有效控制运行的线程数量，防止因创建过多线程导致的系统资源耗尽（如内存溢出）。通过合理配置线程池大小，可以最大化 CPU 利用率和系统吞吐量。&lt;/li&gt;
&lt;li&gt;缺点：程池增加了程序的复杂度，特别是当涉及线程池参数调整和故障排查时。错误的配置可能导致死锁、资源耗尽等问题，这些问题的诊断和修复可能较为复杂。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-5-如何停止一个线程的运行？&#34;&gt;2.5 如何停止一个线程的运行？&lt;/h3&gt;
&lt;p&gt;启动线程是通过 &lt;code&gt;Thread&lt;/code&gt; 类的 &lt;code&gt;start()&lt;/code&gt;，停止线程则主要有以下这些方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;异常法停止：线程调用 &lt;code&gt;interrupt()&lt;/code&gt; 方法后，在线程的 &lt;code&gt;run()&lt;/code&gt; 方法中判断当前对象的 &lt;code&gt;interrupted()&lt;/code&gt; 状态，如果是中断状态则抛出异常，达到中断线程的效果。&lt;/li&gt;
&lt;li&gt;在沉睡中停止：先将线程 Sleep，然后调用 &lt;code&gt;interrupt()&lt;/code&gt; 标记中断状态，&lt;code&gt;interrupt()&lt;/code&gt; 会将阻塞状态的线程中断，会抛出中断异常，达到停止线程的效果。&lt;/li&gt;
&lt;li&gt;暴力停止：线程调用 &lt;code&gt;stop()&lt;/code&gt; 方法会被暴力停止，方法已弃用，强制让线程停止有可能使一些请理性的工作得不到完成。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;return&lt;/code&gt; 停止线程：调用 &lt;code&gt;interrupt()&lt;/code&gt; 标记为中断状态后，在 &lt;code&gt;run()&lt;/code&gt; 方法中判断当前线程状态，如果为中断状态则 &lt;code&gt;return&lt;/code&gt;，能达到停止线程的效果。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-6-Java-线程的状态有哪些？&#34;&gt;2.6 Java 线程的状态有哪些？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;java.lang.Thread.State&lt;/code&gt; 枚举类中定义了六种线程的状态，可以调用 &lt;code&gt;Thread&lt;/code&gt; 中的 &lt;code&gt;getState()&lt;/code&gt; 方法获取当前线程的状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NEW&lt;/code&gt;：尚未启动的线程状态，即线程创建，还未调用 &lt;code&gt;start()&lt;/code&gt; 方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RUNNABLE&lt;/code&gt;：就绪状态（调用 &lt;code&gt;start()&lt;/code&gt;，等待调度），此时线程正在运行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BLOCKED&lt;/code&gt;：等待监视器锁时，陷入阻塞状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WAITING&lt;/code&gt;：等待状态的线程正在等待另一线程执行特定的操作（如 &lt;code&gt;notify&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt;：具有指定等待时间的等待状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TERMINATED&lt;/code&gt;：线程完成执行，进入终止状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-7-sleep-和-wait-有什么区别？&#34;&gt;2.7 sleep() 和 wait() 有什么区别？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;所属分类的不同：&lt;code&gt;sleep()&lt;/code&gt; 是 &lt;code&gt;Thread&lt;/code&gt; 类的静态方法，可以在任何地方直接通过 &lt;code&gt;Thread.sleep()&lt;/code&gt; 调用，无需依赖对象实例。&lt;code&gt;wait()&lt;/code&gt; 是 &lt;code&gt;Object&lt;/code&gt; 类的实例方法，这意味着必须通过对象实例来调用。&lt;/li&gt;
&lt;li&gt;锁释放的情况：&lt;code&gt;sleep()&lt;/code&gt; 在调用时，线程会暂停执行指定的时间，线程&lt;strong&gt;会释放 CPU，主动让出 CPU 时间片&lt;/strong&gt;，进入 &lt;code&gt;TIMED_WAITING&lt;/code&gt; 状态，但&lt;strong&gt;不会释放持有的对象锁&lt;/strong&gt;。也就是说，在 Sleep 期间，其他线程无法获得该线程持有的锁。调用 &lt;code&gt;wait()&lt;/code&gt; 方法时，线程会释放持有的对象锁，进入等待状态，直到其他线程调用相同对象的 &lt;code&gt;notify()&lt;/code&gt; 或 &lt;code&gt;notifyAll()&lt;/code&gt; 方法唤醒它。&lt;/li&gt;
&lt;li&gt;使用条件：&lt;code&gt;sleep()&lt;/code&gt; 可在任意位置调用，无需事先获取锁。&lt;code&gt;wait()&lt;/code&gt; 必须在同步块或同步方法内调用（即线程需持有该对象的锁），否则抛出 &lt;code&gt;IllegalMonitorStateException&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;唤醒机制：&lt;code&gt;sleep()&lt;/code&gt; 休眠时间结束后，线程&lt;strong&gt;自动恢复到就绪状态&lt;/strong&gt;，等待 CPU 调度。&lt;code&gt;wait()&lt;/code&gt; 需要其他线程调用相同对象的 &lt;code&gt;notify()&lt;/code&gt; 或 &lt;code&gt;notifyAll()&lt;/code&gt; 方法才能被唤醒。&lt;code&gt;notify()&lt;/code&gt; 会随机唤醒一个在该对象上等待的线程，而 &lt;code&gt;notifyAll()&lt;/code&gt; 会唤醒所有在该对象上等待的线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-8-BLOCKED-和-WAITING-有什么区别？&#34;&gt;2.8 BLOCKED 和 WAITING 有什么区别？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;BLOCKED&lt;/code&gt; 和 &lt;code&gt;WAITING&lt;/code&gt; 两个状态最大的区别有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BLOCKED&lt;/code&gt; 是锁竞争失败后&lt;strong&gt;被动触发&lt;/strong&gt;的状态，&lt;code&gt;WAITING&lt;/code&gt; 是人为&lt;strong&gt;主动触发&lt;/strong&gt;的状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BLOCKED&lt;/code&gt; 的唤醒是自动触发的，而 &lt;code&gt;WAITING&lt;/code&gt; 状态是必须要通过特定的方法来主动唤醒。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体展开解释如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;触发条件：线程进入 &lt;code&gt;BLOCKED&lt;/code&gt; 状态通常是因为试图获取一个对象的锁，但该锁已经被另一个线程持有。这通常发生在尝试进入 &lt;code&gt;synchronized&lt;/code&gt; 块或方法时，如果锁已被占用，则线程将被阻塞直到锁可用。线程进入 &lt;code&gt;WAITING&lt;/code&gt; 状态是因为它正在等待另一个线程执行某些操作，例如调用 &lt;code&gt;Object.wait()&lt;/code&gt; 方法、&lt;code&gt;Thread.join()&lt;/code&gt; 方法或 &lt;code&gt;LockSupport.park()&lt;/code&gt; 方法。在这种状态下，线程将不会消耗 CPU 资源，并且不会参与锁的竞争。&lt;/li&gt;
&lt;li&gt;唤醒机制：当一个线程等待锁被阻塞时，一旦锁被释放，线程将有机会重新尝试获取锁。如果锁此时未被其他线程获取，那么线程可以从 &lt;code&gt;BLOCKED&lt;/code&gt; 状态变为 &lt;code&gt;RUNNABLE&lt;/code&gt; 状态。线程在 &lt;code&gt;WAITING&lt;/code&gt; 状态中则需要被显式唤醒。例如，如果线程调用了 &lt;code&gt;wait()&lt;/code&gt;，那么它必须等待另一个线程调用同一对象上的 &lt;code&gt;notify()&lt;/code&gt; 或 &lt;code&gt;notifyAll()&lt;/code&gt; 方法才能被唤醒。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-9-不同的线程之间如何通信？&#34;&gt;2.9 不同的线程之间如何通信？&lt;/h3&gt;
&lt;p&gt;共享变量是最基本的线程间通信方式，多个线程可以访问和修改同一个共享变量，从而实现信息的传递。为了保证线程安全，通常需要使用 &lt;code&gt;synchronized&lt;/code&gt; 关键字或 &lt;code&gt;volatile&lt;/code&gt; 关键字。&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;SharedVariableExample&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;volatile&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;flag&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(String[] args)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 生产者线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;Thread&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;producer&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Thread&lt;/span&gt;(() -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (&lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Producer date now: &amp;quot;&lt;/span&gt; + &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Date&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    Thread.sleep(&lt;span class=&#34;number&#34;&gt;2000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    flag = &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Producer: Flag is set to true.&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &amp;#125; &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (InterruptedException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 消费者线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;Thread&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;consumer&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Thread&lt;/span&gt;(() -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (&lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Consumer date now: &amp;quot;&lt;/span&gt; + &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Date&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;number&#34;&gt;50&lt;/span&gt;; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                        Thread.sleep(&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (flag) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                        flag = &lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Consumer: Flag is set to false.&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &amp;#125; &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (InterruptedException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        producer.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        consumer.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面这段代码中生产者线程每隔 2 秒将 &lt;code&gt;flag&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt;，消费者线程每隔 0.5 秒判断一次 &lt;code&gt;flag&lt;/code&gt; 是否为 &lt;code&gt;true&lt;/code&gt;，如果为 &lt;code&gt;true&lt;/code&gt; 则将其改为 &lt;code&gt;false&lt;/code&gt;。&lt;code&gt;volatile&lt;/code&gt; 关键字确保了 &lt;code&gt;flag&lt;/code&gt; 变量在多个线程之间的可见性，即一个线程修改了 &lt;code&gt;flag&lt;/code&gt; 的值，其他线程能立即看到。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object&lt;/code&gt; 类中的 &lt;code&gt;wait()&lt;/code&gt;、&lt;code&gt;notify()&lt;/code&gt; 和 &lt;code&gt;notifyAll()&lt;/code&gt; 方法可以用于线程间的协作。&lt;code&gt;wait()&lt;/code&gt; 方法使当前线程进入等待状态，&lt;code&gt;notify()&lt;/code&gt; 方法唤醒在此对象监视器上等待的单个线程，&lt;code&gt;notifyAll()&lt;/code&gt; 方法唤醒在此对象监视器上等待的所有线程。&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;WaitNotifyExample&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;volatile&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;flag&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;lock&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(String[] args)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 生产者线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;Thread&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;producer&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Thread&lt;/span&gt;(() -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;synchronized&lt;/span&gt; (lock) &amp;#123;  &lt;span class=&#34;comment&#34;&gt;// 等消费者释放锁后开始执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Producer: Producing...&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    Thread.sleep(&lt;span class=&#34;number&#34;&gt;2000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    flag = &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Producer: Production finished. Notifying consumer.&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    lock.notify();  &lt;span class=&#34;comment&#34;&gt;// 唤醒等待的线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &amp;#125; &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (InterruptedException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 消费者线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;Thread&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;consumer&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Thread&lt;/span&gt;(() -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;synchronized&lt;/span&gt; (lock) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (flag)  &lt;span class=&#34;comment&#34;&gt;// 此时 flag = false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Consumer: Consuming before wait...&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Consumer: Waiting for production to finish.&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    lock.wait();  &lt;span class=&#34;comment&#34;&gt;// flag = false，进入等待状态，释放锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (flag)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                        System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;Consumer: Consuming after wait...&amp;quot;&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;// 会在这里执行输出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &amp;#125; &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (InterruptedException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        consumer.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        producer.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码中 &lt;code&gt;lock&lt;/code&gt; 是一个用于同步的对象，生产者和消费者线程都需要获取该对象的锁才能执行相应的操作。注意我们先启动的是消费者线程，消费者获取对象锁后生产者还处于阻塞状态，消费者线程此时判断 &lt;code&gt;flag&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;，于是调用 &lt;code&gt;lock.wait()&lt;/code&gt; 方法进入等待状态，并释放锁，生产者线程执行完生产任务后调用 &lt;code&gt;lock.notify()&lt;/code&gt; 方法唤醒等待的消费者线程。&lt;/p&gt;
</content>
        <category term="Interview" />
        <updated>2023-11-24T02:32:00.000Z</updated>
    </entry>
    <entry>
        <id>https://asanosaki.github.io/posts/36915.html</id>
        <title>Java基础面试题总结</title>
        <link rel="alternate" href="https://asanosaki.github.io/posts/36915.html"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;Java 基础常见面试题总结，涉及 Java 基本概念、OOP、反射等内容，文章将不断更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;h2 id=&#34;1-Java基本概念&#34;&gt;1. Java基本概念&lt;/h2&gt;
&lt;h3 id=&#34;1-1-Java语言有哪些特点？&#34;&gt;1.1 Java语言有哪些特点？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;面向对象（封装、继承、多态）：Java 是一种面向对象编程（OOP）的语言，它对类、对象、继承、封装、多态、接口、包等内容均有很好的支持。为了简单起见，Java 只支持类之间的单继承，但是可以使用接口来实现多继承。&lt;/li&gt;
&lt;li&gt;平台无关性：Java是“一次编写，到处运行”（Write Once, Run Anywhere）的语言，因此采用 Java 语言编写的程序具有很好的&lt;strong&gt;可移植性&lt;/strong&gt;，而保证这一点的正是 Java 的虚拟机机制，在引入虚拟机之后，Java 语言在不同的平台上运行不需要重新编译。&lt;/li&gt;
&lt;li&gt;可靠性、安全性：Java 是被设计成编写高可靠和稳健软件的。Java 消除了某些编程错误，使得用它写可靠软件相当容易。&lt;/li&gt;
&lt;li&gt;支持多线程：C++ 没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 具备内置的多线程功能，可以将一个程序的不同程序段设置为不同的线程，使各线程并发、独立执行，提高系统的运行效率。&lt;/li&gt;
&lt;li&gt;支持网络编程：Java 诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便。&lt;/li&gt;
&lt;li&gt;编译与解释并存：Java 是一种先编译后解释的语言，Java 程序在 Java 平台运行时会被编译成字节码文件，然后可以在有 Java 环境的操作系统上运行。&lt;/li&gt;
&lt;li&gt;动态性：Java 语言设计成适应于变化的环境，它是一个动态的语言。例如，Java 中的类是根据需要载入的，甚至有些是通过网络获取的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-2-Java和C-有什么联系和区别？&#34;&gt;1.2 Java和C++有什么联系和区别？&lt;/h3&gt;
&lt;p&gt;联系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向对象：Java 和 C++ 都支持面向对象编程，包括类、对象、继承、封装和多态。&lt;/li&gt;
&lt;li&gt;语法：Java 的语法在很大程度上受到了 C++ 的影响，因此这两种语言在语法上有很多相似之处。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存管理：Java 有垃圾回收机制，可以自动回收不再使用的内存，而 C++ 需要程序员手动管理内存。&lt;/li&gt;
&lt;li&gt;指针和引用：C++ 支持指针，但 Java 没有指针的概念。相反，Java 使用引用来实现某些相似的功能。&lt;/li&gt;
&lt;li&gt;继承：C++ 支持多重继承，而 Java 不支持多重继承，但允许一个类实现多个接口。&lt;/li&gt;
&lt;li&gt;运行环境：Java 程序在 Java 平台上运行，可以在任何安装了 Java 虚拟机的系统上运行，而 C++ 程序是直接编译成特定操作系统的机器码。&lt;/li&gt;
&lt;li&gt;异常处理：Java 有一套完整的异常处理机制，而 C++ 的异常处理机制相对较弱。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-3-Java和Python有什么联系和区别？&#34;&gt;1.3 Java和Python有什么联系和区别？&lt;/h3&gt;
&lt;p&gt;联系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向对象：两者均支持面向对象编程（封装、继承、多态），但 Python 还支持函数式编程、过程式编程等范式。&lt;/li&gt;
&lt;li&gt;跨平台性：Java 通过 JVM（Java 虚拟机）实现“一次编写，到处运行”；Python 通过解释器（如 CPython、PyPy）实现跨平台，但需安装对应环境。&lt;/li&gt;
&lt;li&gt;丰富的生态系统：两者都有庞大的第三方库和框架支持。Java：Spring（企业级开发）、Hibernate（ORM）、Android SDK（移动开发）；Python：Django/Flask（Web 开发）、NumPy/Pandas（数据分析）、TensorFlow/PyTorch（机器学习）。&lt;/li&gt;
&lt;li&gt;自动内存管理：均通过垃圾回收机制（GC）自动管理内存，开发者无需手动分配/释放内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语言设计哲学：Java 为静态类型（编译时检查类型），而 Python 为动态类型（运行时推断类型）；Java 语法严格，需分号和大括号，而 Python 语法简洁，依赖缩进（强制代码可读性）；Java “一次编写，到处运行”（强调稳定性和性能），而 Python “优雅、明确、简单”（强调开发效率和可读性）。&lt;/li&gt;
&lt;li&gt;执行方式：Java 先编译为字节码（&lt;code&gt;.class&lt;/code&gt;），再由 JVM 执行，而 Python 解释执行（逐行翻译），但会生成字节码（&lt;code&gt;.pyc&lt;/code&gt;）缓存；Java 接近 C++，适合高性能场景（如服务器、大型系统），而 Python 解释执行较慢，但可通过 C 扩展（如 NumPy）或 JIT（PyPy）优化。&lt;/li&gt;
&lt;li&gt;应用场景：Java 代码量大，适合长期维护的大型项目，如企业级应用、Android 开发、金融系统、大数据（Hadoop/Spark），而 Python 代码简洁，适合快速原型开发，如数据分析、机器学习、中小型 Web 开发、脚本自动化、科学计算。&lt;/li&gt;
&lt;li&gt;并发模型：Java 原生支持多线程，JVM 利用操作系统线程，通过 &lt;code&gt;java.util.concurrent&lt;/code&gt; 包实现高效并发，而 Python 受 GIL（全局解释器锁）限制，多线程在 CPU 密集型任务中效率低，可使用多进程（&lt;code&gt;multiprocessing&lt;/code&gt; 模块）或异步编程（&lt;code&gt;asyncio&lt;/code&gt;）绕过 GIL 限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-4-JVM、JRE和JDK的关系是什么？&#34;&gt;1.4 JVM、JRE和JDK的关系是什么？&lt;/h3&gt;
&lt;p&gt;JVM、JRE 和 JDK 是 Java 开发和运行的三个核心组件，它们之间的关系可以概括为：JDK 包含 JRE，而 JRE 包含 JVM。下面是对这三者的详细介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JVM（Java Virtual Machine）：Java 虚拟机，是 Java 能够实现跨平台的核心机制。JVM 只认识 &lt;code&gt;.class&lt;/code&gt; 后缀的文件，它能将 &lt;code&gt;class&lt;/code&gt; 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。&lt;/li&gt;
&lt;li&gt;JRE（Java Runtime Environment）：Java 运行环境，包括 Java 虚拟机（JVM）和 Java 程序所需的核心类库等。如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可。&lt;/li&gt;
&lt;li&gt;JDK（Java Development Kit）：Java 的开发工具包，是提供给 Java 开发人员使用的，其中包含了 Java 的开发工具和 JRE。其中的开发工具包括：运行工具（&lt;code&gt;java.exe&lt;/code&gt;）、编译工具（&lt;code&gt;javac.exe&lt;/code&gt;）、打包工具（&lt;code&gt;jar.exe&lt;/code&gt;）等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，简单来说，JDK 是用于开发 Java 应用的，JRE 是用于运行 Java 应用的，而 JVM 则是使 Java 能够跨平台的核心。&lt;/p&gt;
&lt;h3 id=&#34;1-5-什么是字节码？采用字节码的好处是什么？&#34;&gt;1.5 什么是字节码？采用字节码的好处是什么？&lt;/h3&gt;
&lt;p&gt;字节码是一种中间状态的&lt;strong&gt;二进制文件&lt;/strong&gt;，是由源码编译过来的，可读性没有源码的高。CPU 并不能直接读取字节码，在 Java 中，字节码需要经过 JVM 转译成机器码之后，CPU 才能读取并运行。采用字节码的好处主要有以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨平台性：字节码可以在不同的平台上运行，只需要有一个能够识别并解释字节码的解释器即可。&lt;/li&gt;
&lt;li&gt;高效率：字节码可以在运行时动态编译为机器代码，这样就可以在保证程序执行效率的同时避免了额外的编译步骤。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点，所以 Java 程序运行时比较高效。&lt;/li&gt;
&lt;li&gt;可调试性：字节码是可读的，因此可以方便地进行调试和分析。&lt;/li&gt;
&lt;li&gt;可扩展性：字节码可以被扩展以支持新的特性，而不需要更改现有的机器代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-6-Java有哪些数据类型？&#34;&gt;1.6 Java有哪些数据类型？&lt;/h3&gt;
&lt;p&gt;Java 的数据类型可以分为两大类：基本数据类型和引用数据类型。&lt;/p&gt;
&lt;p&gt;基本数据类型包括以下八种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;byte&lt;/code&gt;：8位有符号二进制整数，取值范围为 &lt;code&gt;-128~127&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;short&lt;/code&gt;：16位有符号二进制整数，取值范围为 &lt;code&gt;-32768~32767&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt;：32位有符号二进制整数，取值范围为 &lt;code&gt;-2147483648~2147483647&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;long&lt;/code&gt;：64位有符号二进制整数，取值范围为 &lt;code&gt;-9223372036854775808~9223372036854775807&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;float&lt;/code&gt;：32位单精度浮点数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;double&lt;/code&gt;：64位双精度浮点数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean&lt;/code&gt;：布尔值，只有两个取值：&lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char&lt;/code&gt;：单个16位 Unicode 字符，取值范围为 &lt;code&gt;\u0000~\uffff&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;引用数据类型包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类（Class）：由程序员定义的一种数据类型，它将数据和对数据的操作封装在一起。&lt;/li&gt;
&lt;li&gt;接口（Interface）：一种引用类型，类似于类，由完全抽象的方法和常量组成。&lt;/li&gt;
&lt;li&gt;数组（Array）：可以保存多个同类型变量的容器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-面向对象&#34;&gt;2. 面向对象&lt;/h2&gt;
&lt;h3 id=&#34;2-1-面向对象的三大特性是什么？&#34;&gt;2.1 面向对象的三大特性是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;封装：封装是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。&lt;/li&gt;
&lt;li&gt;继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。&lt;/li&gt;
&lt;li&gt;多态：多态是指允许不同类的对象对同一消息做出响应。也就是说，同一个接口可以具有多种实现方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-2-访问修饰符的区别？&#34;&gt;2.2 访问修饰符的区别？&lt;/h3&gt;
&lt;p&gt;Java 有四种访问修饰符，它们分别是 &lt;code&gt;public&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;、&lt;code&gt;default&lt;/code&gt;（默认，无修饰符）和 &lt;code&gt;private&lt;/code&gt;。以下是它们的详细介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt;：公共访问修饰符，被声明为 &lt;code&gt;public&lt;/code&gt; 的类、方法、构造方法和接口能够被任何其他类访问。如果几个相互访问的 &lt;code&gt;public&lt;/code&gt; 类分布在不同的包中，则需要导入相应 &lt;code&gt;public&lt;/code&gt; 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;protected&lt;/code&gt;：受保护的访问修饰符，被声明为 &lt;code&gt;protected&lt;/code&gt; 的变量、方法和构造器能被同一个包中的任何其他类访问；同时，被 &lt;code&gt;protected&lt;/code&gt; 所修饰的成员也能被该类的所有子类继承下来，无论子类和基类是否在同一包中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;default&lt;/code&gt;（默认，无修饰符）：包私有访问修饰符，表示只能在当前包中的类访问该成员。被 &lt;code&gt;default&lt;/code&gt; 所修饰的成员只能被该类所在同一个包中的子类所继承下来。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;private&lt;/code&gt;：私有访问修饰符，表示只能在当前类中访问该成员，除了当前类都不能访问。私有访问修饰符是最严格的访问级别，所有被声明为 &lt;code&gt;private&lt;/code&gt; 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 &lt;code&gt;private&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-3-Java语言是如何实现多态的？&#34;&gt;2.3 Java语言是如何实现多态的？&lt;/h3&gt;
&lt;p&gt;我们通常所说的多态指的都是运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定，这也是为什么有时候多态方法又被称为延迟方法的原因。Java 语言实现多态主要依赖于以下三个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承：必须存在子类继承父类的继承关系，只有在存在继承关系的前提下，子类才能继承父类的属性和方法，从而实现多态。&lt;/li&gt;
&lt;li&gt;重写：子类需要对父类中的一些方法进行重写，当调用这些方法时，会调用子类重写的方法，而不是原本父类的方法。&lt;/li&gt;
&lt;li&gt;向上转型：在多态中需要将子类的引用赋给父类对象，只有这样，该引用才能够具备调用父类的方法和子类的方法的能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-4-重载和重写的区别？&#34;&gt;2.4 重载和重写的区别？&lt;/h3&gt;
&lt;p&gt;Java 中的重载和重写都是实现多态的方式，但它们的实现方式和使用场景有所不同：&lt;/p&gt;
&lt;p&gt;重载（Overload）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载。&lt;/li&gt;
&lt;li&gt;重载的方法可以改变返回类型；可以相同也可以不同，但不能通过返回类型是否相同来判断重载。&lt;/li&gt;
&lt;li&gt;重载是编译时的多态性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重写（Override）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型。&lt;/li&gt;
&lt;li&gt;重写的方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。&lt;/li&gt;
&lt;li&gt;重写是运行时的多态性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：构造器不能被继承，因此不能被重写，但可以被重载。每一个类必须有自己的构造函数，负责构造自己这部分的构造内容。子类不会覆盖父类的构造函数，相反必须在构造函数的一开始就调用父类的构造函数。&lt;/p&gt;
&lt;h3 id=&#34;2-5-抽象类和接口的区别？&#34;&gt;2.5 抽象类和接口的区别？&lt;/h3&gt;
&lt;p&gt;语法层面上的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口只能定义抽象方法不能实现方法，抽象类既可以定义抽象方法，也可以实现方法。&lt;/li&gt;
&lt;li&gt;抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 &lt;code&gt;public static final&lt;/code&gt; 类型的。&lt;/li&gt;
&lt;li&gt;接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法。&lt;/li&gt;
&lt;li&gt;抽象类是单继承，而接口是多继承。一个类只能继承一个抽象类，但可以实现多个接口。&lt;/li&gt;
&lt;li&gt;抽象类的方法访问控制符无限制，只是抽象类中的 &lt;code&gt;abstract&lt;/code&gt; 方法不能被 &lt;code&gt;private&lt;/code&gt; 修饰；而接口有限制，接口默认为 &lt;code&gt;public&lt;/code&gt; 控制符。&lt;/li&gt;
&lt;li&gt;抽象类可以有构造方法，接口中不能有构造方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设计层面上的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（只有行为）进行抽象。&lt;/li&gt;
&lt;li&gt;二者的设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-6-什么是不可变对象？有什么好处？&#34;&gt;2.6 什么是不可变对象？有什么好处？&lt;/h3&gt;
&lt;p&gt;在 Java 中，不可变对象（Immutable Object）是指一旦被创建后，对象所有的状态及属性在其生命周期内不会发生任何变化。也就是说，一个对象在创建后，不能对该对象进行任何更改。如 &lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Integer&lt;/code&gt; 以及其它包装类。不可变对象有很多优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造、测试和使用都很简单：由于对象状态不会改变，所以可以避免了很多复杂的状态检查和同步。&lt;/li&gt;
&lt;li&gt;线程安全且没有同步问题：线程安全是最大的好处，在并发环境下，不可变对象无需进行额外的同步操作，因此可以极大地简化并发编程。&lt;/li&gt;
&lt;li&gt;不需要担心数据会被其它线程修改：这是因为对象的状态不会改变，所以不会出现一个线程正在读取对象状态，而另一个线程同时修改该状态的情况。&lt;/li&gt;
&lt;li&gt;当用作类的属性时不需要保护性拷贝：如果类的属性是可变的，那么在返回属性值或者接收新的属性值时，需要进行保护性拷贝以防止属性被外部代码修改。而对于不可变对象，由于其状态不能被修改，所以无需进行保护性拷贝。&lt;/li&gt;
&lt;li&gt;可以很好的用作 &lt;code&gt;Map&lt;/code&gt; 键值和 &lt;code&gt;Set&lt;/code&gt; 元素：由于不可变对象一旦创建就不能改变，所以它们是值得信赖的键值，可以确保在对象被用作键值的过程中始终保持一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然而，不可变对象也有一些缺点，最大的缺点就是创建对象的开销，因为每一步修改操作都会产生一个新的对象。&lt;/p&gt;
&lt;h3 id=&#34;2-7-equals方法和-的区别？&#34;&gt;2.7 equals方法和==的区别？&lt;/h3&gt;
&lt;p&gt;在 Java 中，&lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;equals()&lt;/code&gt; 方法都可以用来比较两个对象，但它们的比较方式和使用场景有所不同：&lt;/p&gt;
&lt;p&gt;首先 &lt;code&gt;==&lt;/code&gt; 是一个运算符，而 &lt;code&gt;equals()&lt;/code&gt; 是一个方法，二者比较的内容有以下不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt;：如果比较的是&lt;strong&gt;基本数据类型&lt;/strong&gt;，则比较的是&lt;strong&gt;数值&lt;/strong&gt;是否相等；如果比较的是&lt;strong&gt;引用数据类型&lt;/strong&gt;，则比较的是两个对象的&lt;strong&gt;内存地址&lt;/strong&gt;是否相等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;equals()&lt;/code&gt;：默认情况下，比较的是两个对象的&lt;strong&gt;内存地址&lt;/strong&gt;。但是，许多类（如 &lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Integer&lt;/code&gt; 等）已经&lt;strong&gt;重写&lt;/strong&gt;了 &lt;code&gt;equals()&lt;/code&gt; 方法，使其能够比较两个对象的&lt;strong&gt;内容&lt;/strong&gt;是否相等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二者的一般使用场景如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt;：通常用于比较基本数据类型，或者比较两个对象是否指向同一内存地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;equals()&lt;/code&gt;：通常用于比较两个对象的内容是否相等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-8-String、StringBuffer、StringBuilder的区别是什么？&#34;&gt;2.8 String、StringBuffer、StringBuilder的区别是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可变性：&lt;code&gt;String&lt;/code&gt; 是不可变的，也就是说，一旦 &lt;code&gt;String&lt;/code&gt; 对象被创建，其值就不能被改变。如果需要修改 &lt;code&gt;String&lt;/code&gt;，Java 会创建一个新的 &lt;code&gt;String&lt;/code&gt; 对象。&lt;code&gt;StringBuffer&lt;/code&gt; 和 &lt;code&gt;StringBuilder&lt;/code&gt; 是可变的，也就是说，它们可以在原地修改字符串，而不需要创建新的对象。&lt;/li&gt;
&lt;li&gt;线程安全性：&lt;code&gt;StringBuffer&lt;/code&gt; 是线程安全的，因为它的所有公共方法都是同步的。这意味着在多线程环境下，&lt;code&gt;StringBuffer&lt;/code&gt; 可以安全地使用。&lt;code&gt;StringBuilder&lt;/code&gt; 不是线程安全的。因此，如果你的代码只在单线程环境下运行，使用 &lt;code&gt;StringBuilder&lt;/code&gt; 通常会比 &lt;code&gt;StringBuffer&lt;/code&gt; 更快。&lt;/li&gt;
&lt;li&gt;性能：对于需要频繁修改字符串的情况，使用 &lt;code&gt;StringBuffer&lt;/code&gt; 或 &lt;code&gt;StringBuilder&lt;/code&gt; 通常比使用 &lt;code&gt;String&lt;/code&gt; 更高效。这是因为每次修改 &lt;code&gt;String&lt;/code&gt; 时，都会创建一个新的对象，这会对性能产生影响。在大部分情况下，&lt;code&gt;StringBuilder&lt;/code&gt; 的性能优于 &lt;code&gt;StringBuffer&lt;/code&gt;，这主要是因为 &lt;code&gt;StringBuilder&lt;/code&gt; 不需要考虑线程安全。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-9-为什么Java中的String要设计成不可变的？&#34;&gt;2.9 为什么Java中的String要设计成不可变的？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;安全性：不可变对象本身是线程安全的，可以在多线程环境下安全使用，无需额外的同步。此外，&lt;code&gt;String&lt;/code&gt; 经常被用作许多 Java 类的参数，例如网络连接和文件路径，如果是可变的，那么它的值可能在你不知情的情况下被改变，这可能会导致安全问题。&lt;/li&gt;
&lt;li&gt;哈希码缓存：由于 &lt;code&gt;String&lt;/code&gt; 是不可变的，所以它的哈希码是固定的，可以被缓存，这对于哈希映射（如 &lt;code&gt;HashMap&lt;/code&gt;）来说非常有用，可以提高查找效率。&lt;/li&gt;
&lt;li&gt;字符串池：在 Java 中，相同的字符串字面量只会在内存中存在一份，这被称为字符串池（String Pool）。这种设计可以节省内存，提高效率。如果 &lt;code&gt;String&lt;/code&gt; 是可变的那么字符串池就无法实现了。&lt;/li&gt;
&lt;li&gt;类加载器安全：&lt;code&gt;String&lt;/code&gt; 是 Java 类加载器使用的关键类，如果是可变的那么可能会影响到类加载器的安全性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-10-基本类型和包装类型有什么区别？什么是自动装箱-拆箱？&#34;&gt;2.10 基本类型和包装类型有什么区别？什么是自动装箱/拆箱？&lt;/h3&gt;
&lt;p&gt;基本类型和包装类型的主要区别如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始值：基本类型有初始值，而包装类型的默认值是 &lt;code&gt;null&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;null&lt;/code&gt; 值：包装类型可以为 &lt;code&gt;null&lt;/code&gt;，而基本类型不可以。&lt;/li&gt;
&lt;li&gt;存储位置：如果一个基本类型是成员变量就存储在堆内存里，如果是局部变量就存储在栈内存里；而包装类型则存储的是堆中的引用。&lt;/li&gt;
&lt;li&gt;泛型：包装类型可用于泛型，而基本类型不可以。&lt;/li&gt;
&lt;li&gt;比较：在使用 &lt;code&gt;==&lt;/code&gt; 进行判断的时候，基本类型使用 &lt;code&gt;==&lt;/code&gt; 直接判断其值是否相等，而包装类型判断的是其指向的地址是否相等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自动装箱和自动拆箱是 Java 语言的特性，使得基本类型和包装类型之间的转换更加方便：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动装箱：就是将基本数据类型自动转换为对应的包装类。例如，&lt;code&gt;Integer i = 10;&lt;/code&gt;，这里的10是一个 &lt;code&gt;int&lt;/code&gt; 类型，但 Java 会自动将其转换（装箱）为 &lt;code&gt;Integer&lt;/code&gt; 类型。&lt;/li&gt;
&lt;li&gt;自动拆箱：就是将包装类自动转换为基本数据类型。例如，&lt;code&gt;int a = i;&lt;/code&gt;，这里的 &lt;code&gt;i&lt;/code&gt; 是 &lt;code&gt;Integer&lt;/code&gt; 类型，但 Java 会自动将其转换（拆箱）为 &lt;code&gt;int&lt;/code&gt; 类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些特性使得我们在编写 Java 代码时可以更自然地混合使用基本类型和包装类型，而不需要关心它们之间的转换细节。&lt;/p&gt;
&lt;h3 id=&#34;2-11-B-S和C-S架构分别是什么？&#34;&gt;2.11 B/S和C/S架构分别是什么？&lt;/h3&gt;
&lt;p&gt;B/S 架构和 C/S 架构是两种常见的软件系统体系结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B/S 架构，全称为 Browser/Server，即浏览器/服务器结构。它是 Web 兴起后的一种网络结构模式，Web 浏览器是客户端最主要的应用软件。这种模式统一了客户端，将系统功能实现的核心部分集中到服务器上，简化了系统的开发、维护和使用。客户端只需要安装一个浏览器，通过 Web 服务器与数据库服务器进行数据交互。B/S 架构利用了 Web 浏览器技术和 Internet 协议，实现了异构系统的连接和信息的共享。&lt;/li&gt;
&lt;li&gt;C/S 架构，全称是 Client/Server，即客户端/服务器体系结构，主要应用于局域网内。它是一种网络体系结构，通常采取两层结构，服务器负责数据的管理，客户端负责完成与用户的交互任务。即客户端是用户运行应用程序的 PC 端或者工作站，客户端要依靠服务器来获取资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-反射&#34;&gt;3. 反射&lt;/h2&gt;
&lt;h3 id=&#34;3-1-什么是反射？&#34;&gt;3.1 什么是反射？&lt;/h3&gt;
&lt;p&gt;在 Java 中，反射是一种强大的工具，它允许程序在&lt;strong&gt;运行时&lt;/strong&gt;访问类或对象的信息，并&lt;strong&gt;动态地&lt;/strong&gt;操作它们。以下是反射的一些主要特性和用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态创建对象：反射可以在运行时动态地创建任意一个类的对象。&lt;/li&gt;
&lt;li&gt;获取类的信息：反射可以获取任意一个类的所有属性和方法，包括私有的。&lt;/li&gt;
&lt;li&gt;动态调用方法和属性：反射可以在运行时动态地调用任意一个对象的任意方法和属性。&lt;/li&gt;
&lt;li&gt;动态修改属性：反射可以改变对象的属性，甚至可以打破封装性，导致 Java 对象的属性不安全。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反射在许多 Java 框架中都有应用，例如 Spring 和 Hibernate，它们使用反射来实现依赖注入和对象关系映射。然而，反射也有其缺点，例如可能会消耗更多的系统资源，如果不需要动态地创建一个对象，那么就不需要用反射。此外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。&lt;/p&gt;
&lt;h3 id=&#34;3-2-举一下反射使用的例子？&#34;&gt;3.2 举一下反射使用的例子？&lt;/h3&gt;
&lt;p&gt;（1）获取 &lt;code&gt;Class&lt;/code&gt; 对象：我们可以通过三种方式获取 &lt;code&gt;Class&lt;/code&gt; 对象：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 1. 通过类名.class的方式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Class&amp;lt;String&amp;gt; c1 = String.class;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 2. 通过对象的getClass()方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Class&amp;lt;? &lt;span class=&#34;keyword&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;String&lt;/span&gt;&amp;gt; c2 = s.getClass();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 3. 通过Class类的静态方法forName(String className)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Class&amp;lt;?&amp;gt; c3 = Class.forName(&lt;span class=&#34;string&#34;&gt;&amp;quot;java.lang.String&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（2）创建对象：我们可以通过 &lt;code&gt;Class&lt;/code&gt; 对象的 &lt;code&gt;newInstance()&lt;/code&gt; 方法来创建对应类的对象：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;Class&amp;lt;?&amp;gt; c = Class.forName(&lt;span class=&#34;string&#34;&gt;&amp;quot;java.lang.String&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; (String) c.newInstance();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（3）获取方法并调用：我们可以通过 &lt;code&gt;Class&lt;/code&gt; 对象的 &lt;code&gt;getMethod()&lt;/code&gt; 方法来获取一个类的方法，然后通过 &lt;code&gt;Method&lt;/code&gt; 对象的 &lt;code&gt;invoke()&lt;/code&gt; 方法来调用这个方法：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;Class&amp;lt;?&amp;gt; c = Class.forName(&lt;span class=&#34;string&#34;&gt;&amp;quot;java.lang.String&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;Method&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; c.getMethod(&lt;span class=&#34;string&#34;&gt;&amp;quot;substring&amp;quot;&lt;/span&gt;, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;.class, &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; (String) method.invoke(&lt;span class=&#34;string&#34;&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;// Hello&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（4）获取和设置字段：我们可以通过 &lt;code&gt;Class&lt;/code&gt; 对象的 &lt;code&gt;getField()&lt;/code&gt; 方法来获取一个类的公有字段，然后通过 &lt;code&gt;Field&lt;/code&gt; 对象的 &lt;code&gt;get()&lt;/code&gt; 和 &lt;code&gt;set()&lt;/code&gt; 方法来获取和设置这个字段的值：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;Class&amp;lt;?&amp;gt; c = Class.forName(&lt;span class=&#34;string&#34;&gt;&amp;quot;java.awt.Dimension&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; c.newInstance();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; c.getField(&lt;span class=&#34;string&#34;&gt;&amp;quot;width&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;f.set(o, &lt;span class=&#34;number&#34;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;System.out.println(f.getInt(o));  &lt;span class=&#34;comment&#34;&gt;// 100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-3-介绍一下反射在JDBC和Spring中的应用&#34;&gt;3.3 介绍一下反射在JDBC和Spring中的应用&lt;/h3&gt;
&lt;p&gt;（1）在 JDBC 中的应用：我们在使用 JDBC 连接数据库时，会使用 &lt;code&gt;Class.forName()&lt;/code&gt; 通过反射加载数据库的驱动程序。例如，假设我们有 &lt;code&gt;com.mysql.cj.jdbc.Driver&lt;/code&gt; 这个类，如果我们使用 MySQL 数据库，那么就传入 MySQL 的驱动类：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 加载并注册JDBC驱动&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Class.forName(&lt;span class=&#34;string&#34;&gt;&amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 创建数据库连接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;Connection&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;conn&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; DriverManager.getConnection(&lt;span class=&#34;string&#34;&gt;&amp;quot;jdbc:mysql://localhost:3306/&amp;lt;DatabaseName&amp;gt;&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;&amp;lt;username&amp;gt;&amp;quot;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;quot;&amp;lt;password&amp;gt;&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（2）在 Spring 中的应用：Spring 通过配置文件配置各种各样的 &lt;code&gt;bean&lt;/code&gt;，你需要用到哪些 &lt;code&gt;bean&lt;/code&gt; 就配哪些，Spring 容器就会根据你的需求去动态加载。Spring 的 IoC 容器可以动态地加载和管理 &lt;code&gt;bean&lt;/code&gt;，创建对象。这是通过反射实现的，Spring 会读取配置文件中的类全名，然后通过反射来创建对象：&lt;/p&gt;
&lt;figure class=&#34;highlight xml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;&amp;lt;!-- Spring配置文件 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;beans&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;bean&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;id&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;myBean&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;class&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;com.example.MyClass&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;property&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;name&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;myProperty&amp;quot;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;value&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;beans&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 从Spring IoC容器中获取bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;context&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ClassPathXmlApplicationContext&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;beans.xml&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;MyClass&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;myBean&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; (MyClass) context.getBean(&lt;span class=&#34;string&#34;&gt;&amp;quot;myBean&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 输出：Hello World&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;System.out.println(myBean.getMyProperty());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-4-反射机制的原理是什么？&#34;&gt;3.4 反射机制的原理是什么？&lt;/h3&gt;
&lt;p&gt;Java 反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质上，当 JVM 得到 &lt;code&gt;Class&lt;/code&gt; 对象之后，再通过 &lt;code&gt;Class&lt;/code&gt; 对象进行反编译，从而获取对象的各种信息。Java 属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到 JVM。通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。&lt;/p&gt;
&lt;p&gt;反射的原理可以通过以下步骤来理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加载：首先，将 &lt;code&gt;.class&lt;/code&gt; 文件读入内存，并为之创建一个 &lt;code&gt;Class&lt;/code&gt; 对象。&lt;/li&gt;
&lt;li&gt;反编译：然后，通过 &lt;code&gt;Class&lt;/code&gt; 对象进行反编译，从而获取对象的各种信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反射机制的优点是在运行时获得类的各种内容，进行反编译，对于 Java 这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。&lt;/p&gt;
</content>
        <category term="Interview" />
        <updated>2023-11-23T08:13:00.000Z</updated>
    </entry>
    <entry>
        <id>https://asanosaki.github.io/posts/48028.html</id>
        <title>MySQL面试题总结</title>
        <link rel="alternate" href="https://asanosaki.github.io/posts/48028.html"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;MySQL 常见面试题总结，涉及 SQL 基础、事务、锁、索引、存储引擎等内容，文章将不断更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;h2 id=&#34;1-SQL-基础&#34;&gt;1. SQL 基础&lt;/h2&gt;
&lt;h3 id=&#34;1-1-数据库的三大范式是什么？&#34;&gt;1.1 数据库的三大范式是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第一范式（1NF）：强调的是列的原子性，即数据库表的&lt;strong&gt;每一列都是不可分割的原子数据项&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;第二范式（2NF）：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，即在 1NF 基础上消除非主属性对主码的部分函数依赖。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。&lt;/li&gt;
&lt;li&gt;第三范式（3NF）：任何非主属性不依赖于其它非主属性（在 2NF 基础上消除传递依赖）。第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-2-NOSQL-和-SQL-的区别？&#34;&gt;1.2 NOSQL 和 SQL 的区别？&lt;/h3&gt;
&lt;p&gt;SQL 指关系型数据库，主要代表：SQL Server、Oracle、MySQL（开源）、PostgreSQL（开源）。关系型数据库存储结构化数据，这些数据逻辑上以行列二维表的形式存在，每一列代表数据的一种属性，每一行代表一个数据实体。&lt;/p&gt;
&lt;p&gt;NoSQL 指非关系型数据库，主要代表：MongoDB、Redis。NoSQL 数据库逻辑上提供了不同于二维表的存储方式，存储方式可以是 JSON 文档、哈希表或者其他方式。&lt;/p&gt;
&lt;p&gt;选择 SQL 还是 NoSQL，考虑以下因素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ACID vs. BASE：关系型数据库支持 ACID 即原子性、一致性、隔离性和持续性，NoSQL 采用更宽松的模型 BASE，即基本可用，软状态和最终一致性。我们需要考虑对于面对的应用场景，ACID 是否是必须的，比如银行应用就必须保证 ACID，否则一笔钱可能被使用两次；又比如社交软件不必保证 ACID，因为一条状态的更新对于所有用户读取先后时间有数秒不同并不影响使用。&lt;/li&gt;
&lt;li&gt;扩展性对比：NoSQL 数据之间无关系，这样就非常容易扩展，也无形之间在架构的层面上带来了可扩展的能力。比如 Redis 自带主从复制模式、哨兵模式、切片集群模式。相反关系型数据库的数据之间存在关联性，水平扩展较难，需要解决跨服务器 JOIN，分布式事务等问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-3-超键、候选键、主键、外键分别是什么？&#34;&gt;1.3 超键、候选键、主键、外键分别是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。&lt;strong&gt;超键包含候选键和主键&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;候选键：是&lt;strong&gt;最小超键&lt;/strong&gt;，即没有冗余元素的超键。&lt;/li&gt;
&lt;li&gt;主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（NULL）。&lt;/li&gt;
&lt;li&gt;外键：在一个表中存在的另一个表的主键称此表的外键。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-4-SQL-约束有哪几种？&#34;&gt;1.4 SQL 约束有哪几种？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NOT NULL&lt;/code&gt;：用于控制字段的内容一定不能为空（NULL）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UNIQUE&lt;/code&gt;：控制字段内容不能重复，一个表允许有多个 &lt;code&gt;UNIQUE&lt;/code&gt; 约束。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PRIMARY KEY&lt;/code&gt;：也是用于控制字段内容不能重复，但它在一个表只允许出现一个。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FOREIGN KEY&lt;/code&gt;：用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CHECK&lt;/code&gt;：用于控制字段的值范围。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-5-MySQL-怎么连表查询？&#34;&gt;1.5 MySQL 怎么连表查询？&lt;/h3&gt;
&lt;p&gt;数据库有四种联表查询类型：内连接（INNER JOIN）、左外连接（LEFT JOIN）、右外连接（RIGHT JOIN）、全外连接（FULL JOIN）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内连接：返回&lt;strong&gt;两个表中连接条件完全匹配&lt;/strong&gt;的所有行（即两个表的交集）。&lt;/li&gt;
&lt;li&gt;左外连接：返回左表的所有行，即使它们在右表中没有匹配的行，对于左表中存在而右表中没有匹配的行，右表的结果列将填充为 &lt;code&gt;NULL&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;右外连接：返回右表的所有行，即使它们在左表中没有匹配的行，对于右表中存在而左表中没有匹配的行，左表的结果列将填充为 &lt;code&gt;NULL&lt;/code&gt;，RIGHT JOIN 本质上是 LEFT JOIN 的反向操作。&lt;/li&gt;
&lt;li&gt;全外连接：返回左表和右表的所有行，当某一行在另一个表中没有匹配时，另一个表的结果列将填充为 &lt;code&gt;NULL&lt;/code&gt;，它结合了 LEFT JOIN 和 RIGHT JOIN 的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;连表查询写法如下：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; e.name &lt;span class=&#34;keyword&#34;&gt;AS&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;name&amp;#x27;&lt;/span&gt;, d.name &lt;span class=&#34;keyword&#34;&gt;AS&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;department&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; employees e&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;INNER&lt;/span&gt;&lt;span class=&#34;operator&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;keyword&#34;&gt;LEFT&lt;/span&gt;&lt;span class=&#34;operator&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;keyword&#34;&gt;RIGHT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;JOIN&lt;/span&gt; departments d &lt;span class=&#34;keyword&#34;&gt;ON&lt;/span&gt; e.department_id &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; d.id;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- 若写 JOIN 则默认表示 INNER JOIN&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意的是 MySQL 本身并不直接支持 FULL JOIN 语法，需要使用 &lt;code&gt;UNION&lt;/code&gt; 组合 LEFT JOIN 和 RIGHT JOIN 的结果：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; e.name &lt;span class=&#34;keyword&#34;&gt;AS&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;name&amp;#x27;&lt;/span&gt;, d.name &lt;span class=&#34;keyword&#34;&gt;AS&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;department&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; employees e&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;keyword&#34;&gt;LEFT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;JOIN&lt;/span&gt; departments d &lt;span class=&#34;keyword&#34;&gt;ON&lt;/span&gt; e.department_id &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; d.id)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;UNION&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; e.name &lt;span class=&#34;keyword&#34;&gt;AS&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;name&amp;#x27;&lt;/span&gt;, d.name &lt;span class=&#34;keyword&#34;&gt;AS&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;department&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; employees e&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt; &lt;span class=&#34;keyword&#34;&gt;RIGHT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;JOIN&lt;/span&gt; departments d &lt;span class=&#34;keyword&#34;&gt;ON&lt;/span&gt; e.department_id &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; d.id);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-6-MySQL-如何避免重复插入数据？&#34;&gt;1.6 MySQL 如何避免重复插入数据？&lt;/h3&gt;
&lt;p&gt;（1）使用 &lt;code&gt;UNIQUE&lt;/code&gt; 约束&lt;/p&gt;
&lt;p&gt;在表的相关列上添加 UNIQUE 约束，确保每个值在该列中唯一。例如：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;CREATE&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;TABLE&lt;/span&gt; users (&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    id &lt;span class=&#34;type&#34;&gt;INT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;PRIMARY&lt;/span&gt; KEY AUTO_INCREMENT,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    email &lt;span class=&#34;type&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;255&lt;/span&gt;) &lt;span class=&#34;keyword&#34;&gt;UNIQUE&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    name &lt;span class=&#34;type&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;255&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果尝试插入重复的 &lt;code&gt;email&lt;/code&gt;，MySQL 会返回错误。&lt;/p&gt;
&lt;p&gt;（2）使用 &lt;code&gt;INSERT ... ON DUPLICATE KEY UPDATE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这种语句允许在插入记录时处理重复键的情况，如果插入的记录与现有记录冲突，可以选择更新现有记录：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;INSERT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;INTO&lt;/span&gt; users (email, name)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;VALUES&lt;/span&gt; (&lt;span class=&#34;string&#34;&gt;&amp;#x27;example@example.com&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;John Doe&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;ON&lt;/span&gt; DUPLICATE KEY &lt;span class=&#34;keyword&#34;&gt;UPDATE&lt;/span&gt; name &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;VALUES&lt;/span&gt;(name);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（3）使用 &lt;code&gt;INSERT IGNORE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该语句会在插入记录时忽略那些因重复键而导致的插入错误。例如：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;INSERT&lt;/span&gt; IGNORE &lt;span class=&#34;keyword&#34;&gt;INTO&lt;/span&gt; users (email, name)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;VALUES&lt;/span&gt; (&lt;span class=&#34;string&#34;&gt;&amp;#x27;example@example.com&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;John Doe&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果 &lt;code&gt;email&lt;/code&gt; 已经存在，这条插入语句将被忽略而不会返回错误。&lt;/p&gt;
&lt;p&gt;选择哪种方法取决于具体的需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果需要保证全局唯一性，使用 &lt;code&gt;UNIQUE&lt;/code&gt; 约束是最佳做法。&lt;/li&gt;
&lt;li&gt;如果需要插入和更新结合可以使用 &lt;code&gt;ON DUPLICATE KEY UPDATE&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;对于快速忽略重复插入，&lt;code&gt;INSERT IGNORE&lt;/code&gt; 是合适的选择。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-7-MySQL-中的-VARCHAR-和-CHAR-有什么区别？&#34;&gt;1.7 MySQL 中的 VARCHAR 和 CHAR 有什么区别？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CHAR&lt;/code&gt; 是一个&lt;strong&gt;定长&lt;/strong&gt;字段，假如申请了 &lt;code&gt;CHAR(10)&lt;/code&gt; 的空间，那么无论实际存储多少内容，该字段都占用 10 个字符；而 &lt;code&gt;VARCHAR&lt;/code&gt; 是&lt;strong&gt;变长&lt;/strong&gt;的，也就是说申请的只是&lt;strong&gt;最大长度&lt;/strong&gt;，占用的空间为实际字符长度再加一，最后一个字符存储使用了多长的空间。&lt;/p&gt;
&lt;p&gt;在检索效率上来讲，&lt;code&gt;CHAR&lt;/code&gt; 优于 &lt;code&gt;VARCHAR&lt;/code&gt;，因此在使用中，如果确定某个字段的值的长度，可以使用 &lt;code&gt;CHAR&lt;/code&gt;，否则应该尽量使用 &lt;code&gt;VARCHAR&lt;/code&gt; 节约存储空间，例如存储用户 MD5 加密后的密码，则可以使用 &lt;code&gt;CHAR&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;1-8-VARCHAR-后面的数字代表字节还是字符？&#34;&gt;1.8 VARCHAR 后面的数字代表字节还是字符？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;VARCHAR&lt;/code&gt; 后面括号里的数字代表的是字符数，而不是字节数。比如 &lt;code&gt;VARCHAR(10)&lt;/code&gt;，这里的 10 表示该字段最多可以存储 10 个字符，字符的字节长度取决于所使用的字符集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果字符集是 ASCII 字符集：ASCII 字符集每个字符占用 1 个字节，那么 &lt;code&gt;VARCHAR(10)&lt;/code&gt; 最多可以存储 10 个 ASCII 字符，同时占用的存储空间最多为 10 个字节（不考虑额外的长度记录开销）。&lt;/li&gt;
&lt;li&gt;如果字符集是 UTF-8 字符集，它的每个字符可能占用 1 到 4 个字节，对于 &lt;code&gt;VARCHAR(10)&lt;/code&gt; 的字段，它最多可以存储 10 个字符，但占用的字节数会根据字符的不同而变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-9-INT-1-和-INT-10-在-MySQL-有什么不同？&#34;&gt;1.9 INT(1) 和 INT(10) 在 MySQL 有什么不同？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;INT(1)&lt;/code&gt; 和 &lt;code&gt;INT(10)&lt;/code&gt; 的区别主要在于&lt;strong&gt;显示宽度&lt;/strong&gt;，而不是存储范围或数据类型本身的大小：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本质是显示宽度，不改变存储方式：&lt;code&gt;INT&lt;/code&gt; 的存储&lt;strong&gt;固定为 4 字节&lt;/strong&gt;，所有 &lt;code&gt;INT&lt;/code&gt;（无论写成 &lt;code&gt;INT(1)&lt;/code&gt; 还是 &lt;code&gt;INT(10)&lt;/code&gt;）占用的存储空间均为 4 字节。括号内的数值是显示宽度，用于在&lt;strong&gt;特定场景&lt;/strong&gt;下控制数值的展示格式。&lt;/li&gt;
&lt;li&gt;唯一作用场景：&lt;code&gt;ZEROFILL&lt;/code&gt; 补零显示，当字段设置 &lt;code&gt;ZEROFILL&lt;/code&gt; 时，数字显示时会用前导零填充至指定宽度。比如，字段类型为 &lt;code&gt;INT(4) ZEROFILL&lt;/code&gt;，实际存入 5 则显示为 0005，实际存入 12345 显示仍为 12345（宽度超限时不截断）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-10-IP-地址如何在数据库里存储？&#34;&gt;1.10 IP 地址如何在数据库里存储？&lt;/h3&gt;
&lt;p&gt;IPv4 地址是一个 32 位的二进制数，通常以点分十进制表示法呈现，例如 &lt;code&gt;192.168.1.1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;（1）字符串类型的存储方式：直接将 IP 地址作为字符串存储在数据库中，比如可以用 &lt;code&gt;VARCHAR(15)&lt;/code&gt; 来存储：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;CREATE&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;TABLE&lt;/span&gt; ip_records (&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    id &lt;span class=&#34;type&#34;&gt;INT&lt;/span&gt; AUTO_INCREMENT &lt;span class=&#34;keyword&#34;&gt;PRIMARY&lt;/span&gt; KEY,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ip_address &lt;span class=&#34;type&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;15&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;INSERT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;INTO&lt;/span&gt; ip_records (ip_address) &lt;span class=&#34;keyword&#34;&gt;VALUES&lt;/span&gt; (&lt;span class=&#34;string&#34;&gt;&amp;#x27;192.168.1.1&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种存储方式的优点是直观易懂，方便直接进行数据的插入、查询和显示，不需要进行额外的转换操作。缺点是占用存储空间较大，字符串比较操作的性能相对较低，不利于进行范围查询。&lt;/p&gt;
&lt;p&gt;（2）整数类型的存储方式：将 IPv4 地址转换为 32 位无符号整数进行存储，常用的数据类型有 &lt;code&gt;INT UNSIGNED&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;CREATE&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;TABLE&lt;/span&gt; ip_records (&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    id &lt;span class=&#34;type&#34;&gt;INT&lt;/span&gt; AUTO_INCREMENT &lt;span class=&#34;keyword&#34;&gt;PRIMARY&lt;/span&gt; KEY,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ip_address &lt;span class=&#34;type&#34;&gt;INT&lt;/span&gt; UNSIGNED&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- 插入数据，需要先将 IPv4 地址转换为整数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;INSERT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;INTO&lt;/span&gt; ip_records (ip_address) &lt;span class=&#34;keyword&#34;&gt;VALUES&lt;/span&gt; (INET_ATON(&lt;span class=&#34;string&#34;&gt;&amp;#x27;192.168.1.1&amp;#x27;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- 查询时将整数转换回 IPv4 地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; INET_NTOA(ip_address) &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; ip_records;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中 &lt;code&gt;INET_ATON()&lt;/code&gt; 和 &lt;code&gt;INET_NTOA()&lt;/code&gt; 是专门用于处理 IPv4 地址与数值格式之间转换的函数。&lt;/p&gt;
&lt;p&gt;这种存储方式的优点是占用存储空间小，整数比较操作的性能较高，便于进行范围查询。缺点是需要进行额外的转换操作，不够直观，增加了开发的复杂度。&lt;/p&gt;
&lt;h3 id=&#34;1-11-说一下外键约束是什么？&#34;&gt;1.11 说一下外键约束是什么？&lt;/h3&gt;
&lt;p&gt;外键约束的作用是维护表与表之间的关系，确保数据的完整性和一致性。让我们举一个简单的例子：&lt;/p&gt;
&lt;p&gt;假设你有两个表，一个是学生表，另一个是课程表，这两个表之间有一个关系，即一个学生可以选修多门课程，而一门课程也可以被多个学生选修。在这种情况下，我们可以在学生表中定义一个指向课程表的外键，如下所示：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;CREATE&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;TABLE&lt;/span&gt; students (&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    id &lt;span class=&#34;type&#34;&gt;INT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;PRIMARY&lt;/span&gt; KEY,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    name &lt;span class=&#34;type&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;50&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    course_id &lt;span class=&#34;type&#34;&gt;INT&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;FOREIGN&lt;/span&gt; KEY (course_id) &lt;span class=&#34;keyword&#34;&gt;REFERENCES&lt;/span&gt; courses(id)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里，&lt;code&gt;students&lt;/code&gt; 表中的 &lt;code&gt;course_id&lt;/code&gt; 字段是一个外键，它指向 &lt;code&gt;courses&lt;/code&gt; 表中的 &lt;code&gt;id&lt;/code&gt; 字段。这个外键约束确保了每个学生所选的课程在 &lt;code&gt;courses&lt;/code&gt; 表中都存在，从而维护了数据的完整性和一致性。&lt;/p&gt;
&lt;p&gt;如果没有定义外键约束，那么就有可能出现学生选了不存在的课程或者删除了一个课程而忘记从学生表中删除选修该课程的学生的情况，这会破坏数据的完整性和一致性，使用外键约束可以帮助我们避免这些问题。&lt;/p&gt;
&lt;h3 id=&#34;1-12-MySQL-中-IN-和-EXISTS-区别？&#34;&gt;1.12 MySQL 中 IN 和 EXISTS 区别？&lt;/h3&gt;
&lt;p&gt;MySQL 中的 &lt;code&gt;IN&lt;/code&gt; 语句是把外表和内表作 Hash 连接，而 &lt;code&gt;EXISTS&lt;/code&gt; 语句是对外表作 Loop 循环，每次 Loop 循环再对内表进行查询。一直大家都认为 &lt;code&gt;EXISTS&lt;/code&gt; 比 &lt;code&gt;IN&lt;/code&gt; 语句的效率要高，这种说法其实是不准确的。这个是要区分环境的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果查询的两个表大小相当，那么用 &lt;code&gt;IN&lt;/code&gt; 和 &lt;code&gt;EXISTS&lt;/code&gt; 差别不大。&lt;/li&gt;
&lt;li&gt;如果两个表中一个较小，一个是大表，则子查询表大的用 &lt;code&gt;EXISTS&lt;/code&gt;，子查询表小的用 &lt;code&gt;IN&lt;/code&gt;。这是因为 &lt;code&gt;EXISTS&lt;/code&gt; 一旦找到匹配项就会立即停止查询，而 &lt;code&gt;IN&lt;/code&gt; 可能会扫描整个子查询结果集。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NOT IN&lt;/code&gt; 和 &lt;code&gt;NOT EXISTS&lt;/code&gt;：如果查询语句使用了 &lt;code&gt;NOT IN&lt;/code&gt;，那么内外表都进行全表扫描，没有用到索引；而 &lt;code&gt;NOT EXISTS&lt;/code&gt; 的子查询依然能用到表上的索引。所以无论哪个表大，用 &lt;code&gt;NOT EXISTS&lt;/code&gt; 都比 &lt;code&gt;NOT IN&lt;/code&gt; 要快。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外 &lt;code&gt;IN&lt;/code&gt; 能够正确处理子查询中包含 &lt;code&gt;NULL&lt;/code&gt; 值的情况，是直接进行值比较，而 &lt;code&gt;EXISTS&lt;/code&gt; 不受子查询结果中 &lt;code&gt;NULL&lt;/code&gt; 值的影响，因为它关注的是行的存在性，而不是具体值。&lt;/p&gt;
&lt;p&gt;这边首先要理解一个概念，SQL 中任何与 &lt;code&gt;NULL&lt;/code&gt; 的比较（如 &lt;code&gt;? = NULL&lt;/code&gt;、&lt;code&gt;? &amp;lt;&amp;gt; NULL&lt;/code&gt;）结果都是 &lt;code&gt;UNKNOWN&lt;/code&gt;，而不是 &lt;code&gt;TRUE&lt;/code&gt; 或 &lt;code&gt;FALSE&lt;/code&gt;。而 &lt;code&gt;WHERE&lt;/code&gt; 子句只返回条件为 &lt;code&gt;TRUE&lt;/code&gt; 的行，&lt;code&gt;UNKNOWN&lt;/code&gt; 和 &lt;code&gt;FALSE&lt;/code&gt; 都会被过滤掉。&lt;/p&gt;
&lt;p&gt;下面通过具体示例说明它们的差异：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;CREATE&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;TABLE&lt;/span&gt; employees (&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    id &lt;span class=&#34;type&#34;&gt;INT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;PRIMARY&lt;/span&gt; KEY,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    name &lt;span class=&#34;type&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;50&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    dept_id &lt;span class=&#34;type&#34;&gt;INT&lt;/span&gt;  &lt;span class=&#34;comment&#34;&gt;-- 可能为 NULL&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;INSERT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;INTO&lt;/span&gt; employees &lt;span class=&#34;keyword&#34;&gt;VALUES&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Alice&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Bob&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;20&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Charlie&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;NULL&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;-- 注意：NULL 值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;CREATE&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;TABLE&lt;/span&gt; departments (&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    dept_id &lt;span class=&#34;type&#34;&gt;INT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;PRIMARY&lt;/span&gt; KEY,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    dept_name &lt;span class=&#34;type&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;50&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;INSERT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;INTO&lt;/span&gt; departments &lt;span class=&#34;keyword&#34;&gt;VALUES&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Sales&amp;#x27;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;number&#34;&gt;20&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Marketing&amp;#x27;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;NULL&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;HR&amp;#x27;&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;-- 注意：NULL 值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果子查询返回的结果包含 &lt;code&gt;NULL&lt;/code&gt;，&lt;code&gt;IN&lt;/code&gt; 会将 &lt;code&gt;NULL&lt;/code&gt; 视为未知值，例如下面这个查询找出有匹配部门的员工，子查询返回 &lt;code&gt;(10, 20, NULL)&lt;/code&gt;，但 &lt;code&gt;dept_id = NULL&lt;/code&gt; 的比较返回 &lt;code&gt;UNKNOWN&lt;/code&gt;，所以 Charlie 的记录被排除：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; employees&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; dept_id &lt;span class=&#34;keyword&#34;&gt;IN&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; dept_id &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; departments);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假设我们需要找出没有匹配部门的员工，下面这个查询即使 Charlie 的部门是 &lt;code&gt;NULL&lt;/code&gt; 也会被过滤掉，因为 &lt;code&gt;dept_id &amp;lt;&amp;gt; NULL&lt;/code&gt; 也是永远返回 &lt;code&gt;UNKNOWN&lt;/code&gt;，导致整个 &lt;code&gt;NOT IN&lt;/code&gt; 条件失败：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; employees &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; dept_id &lt;span class=&#34;keyword&#34;&gt;NOT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;IN&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; dept_id &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; departments);  &lt;span class=&#34;comment&#34;&gt;-- 危险&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在再看用 &lt;code&gt;EXISTS&lt;/code&gt; 找无匹配部门的员工：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; employees e&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;NOT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;EXISTS&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; departments d&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; d.dept_id &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; e.dept_id  &lt;span class=&#34;comment&#34;&gt;-- 关键关联条件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在比较 &lt;code&gt;NULL&lt;/code&gt; 值的时候结果为 &lt;code&gt;UNKNOWN&lt;/code&gt;，导致子查询返回 0 行，这样使得 &lt;code&gt;NOT EXISTS&lt;/code&gt; 为 &lt;code&gt;TRUE&lt;/code&gt;，成功返回无匹配部门的员工 Charlie。&lt;/p&gt;
&lt;h3 id=&#34;1-13-DROP、DELETE-与-TRUNCATE-的区别？&#34;&gt;1.13 DROP、DELETE 与 TRUNCATE 的区别？&lt;/h3&gt;
&lt;p&gt;三者都表示删除，但是三者有一些差别：&lt;/p&gt;
&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;&lt;/th&gt;
            &lt;th&gt;DELETE&lt;/th&gt;
            &lt;th&gt;TRUNCATE&lt;/th&gt;
            &lt;th&gt;DROP&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;类型&lt;/td&gt;
            &lt;td&gt;属于 DML&lt;/td&gt;
            &lt;td&gt;属于 DDL&lt;/td&gt;
            &lt;td&gt;属于 DDL&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;回滚&lt;/td&gt;
            &lt;td&gt;可回滚&lt;/td&gt;
            &lt;td&gt;不可回滚&lt;/td&gt;
            &lt;td&gt;不可回滚&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;删除内容&lt;/td&gt;
            &lt;td&gt;表结构还在，删除表的全部或者一部分数据&lt;/td&gt;
            &lt;td&gt;表结构还在，删除表中的所有数据&lt;/td&gt;
            &lt;td&gt;从数据库中删除表，所有的数据行、索引和权限也会被删除&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;删除速度&lt;/td&gt;
            &lt;td&gt;删除速度慢，需要逐行删除&lt;/td&gt;
            &lt;td&gt;删除速度快&lt;/td&gt;
            &lt;td&gt;删除速度最快&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;1-14-什么是存储过程？有哪些优缺点？&#34;&gt;1.14 什么是存储过程？有哪些优缺点？&lt;/h3&gt;
&lt;p&gt;存储过程是一些预编译的 SQL 语句。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;更加直白的理解：存储过程可以说是一个记录集，它是由一些 T-SQL 语句组成的代码块，这些 T-SQL 语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用它就行了。&lt;/li&gt;
&lt;li&gt;存储过程是一个预编译的代码块，执行效率比较高，一个存储过程替代大量 T-SQL 语句，可以降低网络通信量，提高通信速率，可以一定程度上确保数据安全。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是，在互联网项目中，其实是不太推荐存储过程的，比较出名的就是阿里的《Java 开发手册》中禁止使用存储过程，我个人的理解是，在互联网项目中，迭代太快，项目的生命周期也比较短，人员流动相比于传统的项目也更加频繁，在这样的情况下，存储过程的管理确实是没有那么方便，同时，复用性也没有写在服务层那么好。&lt;/p&gt;
&lt;h3 id=&#34;1-15-MySQL-有哪些基本函数？&#34;&gt;1.15 MySQL 有哪些基本函数？&lt;/h3&gt;
&lt;p&gt;（1）字符串函数&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- CONCAT(str1, str2, ...) 拼接字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; CONCAT(&lt;span class=&#34;string&#34;&gt;&amp;#x27;Hello&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27; &amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;World&amp;#x27;&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;-- 输出：Hello World&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- SUBSTRING(str, start, length) 截取子字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;SUBSTRING&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;MySQL&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;-- 输出：&amp;#x27;SQL&amp;#x27;（从第 3 字符起取 3 位）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- LENGTH(str) 返回字符串字节数（中文通常占 3 字节）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; LENGTH(&lt;span class=&#34;string&#34;&gt;&amp;#x27;数据库&amp;#x27;&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;-- 输出：9（UTF8 编码下）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- CHAR_LENGTH(str) 返回字符个数（中文算 1 个字符）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;CHAR_LENGTH&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;#x27;数据库&amp;#x27;&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;-- 输出：3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- REPLACE(str, from_str, to_str) 替换字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; REPLACE(&lt;span class=&#34;string&#34;&gt;&amp;#x27;I like Java&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Java&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Python&amp;#x27;&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;-- 输出：&amp;#x27;I like Python&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（2）数值函数&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- ROUND(X, D) 四舍五入（D 为小数位数）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; ROUND(&lt;span class=&#34;number&#34;&gt;3.14159&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;-- 输出：3.14&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- CEIL(X) / FLOOR(X) 向上/向下取整&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;CEIL&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;2.3&lt;/span&gt;), &lt;span class=&#34;built_in&#34;&gt;FLOOR&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;2.7&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;-- 输出：3, 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- ABS(X) 取绝对值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;ABS&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;-15&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;-- 输出：15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- RAND() 生成 0~1 的随机数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; RAND();  &lt;span class=&#34;comment&#34;&gt;-- 输出：0.123456（随机值）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- POWER(X, Y) 计算 X 的 Y 次方&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;POWER&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;-- 2³ = 8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（3）日期时间函数&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- NOW() 返回当前日期和时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; NOW();  &lt;span class=&#34;comment&#34;&gt;-- 输出：&amp;#x27;2025-07-13 14:30:45&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- CURDATE() / CURTIME() 返回当前日期/时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; CURDATE();  &lt;span class=&#34;comment&#34;&gt;-- 输出：&amp;#x27;2025-07-13&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- DATE_FORMAT(date, format) 格式化日期&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; DATE_FORMAT(NOW(), &lt;span class=&#34;string&#34;&gt;&amp;#x27;%Y年%m月%d日&amp;#x27;&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;-- 输出：&amp;#x27;2025年07月13日&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- DATEDIFF(date1, date2) 计算两个日期相差的天数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; DATEDIFF(&lt;span class=&#34;string&#34;&gt;&amp;#x27;2025-12-31&amp;#x27;&lt;/span&gt;, NOW()); &lt;span class=&#34;comment&#34;&gt;-- 输出：170天（示例值）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（4）聚合函数&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- COUNT() 统计行数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;COUNT&lt;/span&gt;(&lt;span class=&#34;operator&#34;&gt;*&lt;/span&gt;) &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; users;  &lt;span class=&#34;comment&#34;&gt;-- 返回总用户数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- SUM() 求和&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;SUM&lt;/span&gt;(salary) &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; employees;  &lt;span class=&#34;comment&#34;&gt;-- 计算工资总和&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- AVG() 求平均值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;AVG&lt;/span&gt;(age) &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; students;  &lt;span class=&#34;comment&#34;&gt;-- 平均年龄&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- MAX() / MIN() 最大/最小值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;MAX&lt;/span&gt;(price) &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; products;  &lt;span class=&#34;comment&#34;&gt;-- 最贵商品价格&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（5）条件判断函数&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- IF(expr, true_val, false_val) 条件判断&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; IF(&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;Yes&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;No&amp;#x27;&lt;/span&gt;);  &lt;span class=&#34;comment&#34;&gt;-- 输出：&amp;#x27;Yes&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- CASE WHEN 多条件分支&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;CASE&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;WHEN&lt;/span&gt; score &lt;span class=&#34;operator&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;90&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;THEN&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;A&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;WHEN&lt;/span&gt; score &lt;span class=&#34;operator&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;80&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;THEN&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;B&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;ELSE&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;C&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;END&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;AS&lt;/span&gt; grade&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; students;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-16-SQL-查询语句的执行顺序是怎么样的？&#34;&gt;1.16 SQL 查询语句的执行顺序是怎么样的？&lt;/h3&gt;
&lt;p&gt;所有的查询语句都是从 &lt;code&gt;FROM&lt;/code&gt; 开始执行，在执行过程中，每个步骤都会生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入，最后一个步骤产生的虚拟表即为输出结果。&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;number&#34;&gt;09&lt;/span&gt;) &lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt;  &lt;span class=&#34;comment&#34;&gt;-- 选择最终返回的列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;) &lt;span class=&#34;keyword&#34;&gt;DISTINCT&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;keyword&#34;&gt;column&lt;/span&gt;&lt;span class=&#34;operator&#34;&gt;&amp;gt;&lt;/span&gt;,  &lt;span class=&#34;comment&#34;&gt;-- 去重操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;number&#34;&gt;06&lt;/span&gt;) AGG_FUNC &lt;span class=&#34;operator&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;keyword&#34;&gt;column&lt;/span&gt;&lt;span class=&#34;operator&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;or&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;&amp;lt;&lt;/span&gt;expression&lt;span class=&#34;operator&#34;&gt;&amp;gt;&lt;/span&gt;, ...  &lt;span class=&#34;comment&#34;&gt;-- 聚合计算&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;number&#34;&gt;01&lt;/span&gt;) &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;&amp;lt;&lt;/span&gt;left_table&lt;span class=&#34;operator&#34;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&#34;comment&#34;&gt;-- 首先确定数据来源，包括主表和所有连接表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    (&lt;span class=&#34;number&#34;&gt;03&lt;/span&gt;) &lt;span class=&#34;operator&#34;&gt;&amp;lt;&lt;/span&gt;join_type&lt;span class=&#34;operator&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;JOIN&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;&amp;lt;&lt;/span&gt;right_table&lt;span class=&#34;operator&#34;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&#34;comment&#34;&gt;-- 表的连接操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    (&lt;span class=&#34;number&#34;&gt;02&lt;/span&gt;) &lt;span class=&#34;keyword&#34;&gt;ON&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;&amp;lt;&lt;/span&gt;join_condition&lt;span class=&#34;operator&#34;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;number&#34;&gt;04&lt;/span&gt;) &lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;&amp;lt;&lt;/span&gt;where_condition&lt;span class=&#34;operator&#34;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&#34;comment&#34;&gt;-- 对 FROM/JOIN 生成的虚拟表进行行级过滤&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;number&#34;&gt;05&lt;/span&gt;) &lt;span class=&#34;keyword&#34;&gt;GROUP&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;BY&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;&amp;lt;&lt;/span&gt;group_by_list&lt;span class=&#34;operator&#34;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&#34;comment&#34;&gt;-- 根据指定列对数据进行分组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;number&#34;&gt;07&lt;/span&gt;) &lt;span class=&#34;keyword&#34;&gt;WITH&lt;/span&gt; &amp;#123;&lt;span class=&#34;keyword&#34;&gt;CUBE&lt;/span&gt;&lt;span class=&#34;operator&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;keyword&#34;&gt;ROLLUP&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;number&#34;&gt;08&lt;/span&gt;) &lt;span class=&#34;keyword&#34;&gt;HAVING&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;&amp;lt;&lt;/span&gt;having_condtion&lt;span class=&#34;operator&#34;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&#34;comment&#34;&gt;-- 对分组后的结果进行过滤（针对分组或聚合值）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;number&#34;&gt;11&lt;/span&gt;) &lt;span class=&#34;keyword&#34;&gt;ORDER&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;BY&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;&amp;lt;&lt;/span&gt;order_by_list&lt;span class=&#34;operator&#34;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&#34;comment&#34;&gt;-- 对结果集排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;number&#34;&gt;12&lt;/span&gt;) LIMIT &lt;span class=&#34;operator&#34;&gt;&amp;lt;&lt;/span&gt;limit_number&lt;span class=&#34;operator&#34;&gt;&amp;gt;&lt;/span&gt;;  &lt;span class=&#34;comment&#34;&gt;-- LIMIT/OFFSET 限制返回行数或分页&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;看一个样例：统计 2023 年每个部门的销售额，仅显示销售额超过 10 万的部门，按销售额降序排列返回前 10 条记录：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    department_id &lt;span class=&#34;keyword&#34;&gt;AS&lt;/span&gt; dept,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;SUM&lt;/span&gt;(sales) &lt;span class=&#34;keyword&#34;&gt;AS&lt;/span&gt; total_sales&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; orders&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;JOIN&lt;/span&gt; departments &lt;span class=&#34;keyword&#34;&gt;USING&lt;/span&gt; (dept_id)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; order_date &lt;span class=&#34;operator&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;2023-01-01&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;GROUP&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;BY&lt;/span&gt; department_id&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;HAVING&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;SUM&lt;/span&gt;(sales) &lt;span class=&#34;operator&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;100000&lt;/span&gt;  &lt;span class=&#34;comment&#34;&gt;-- 注意：这里不应该用 total_sales，因为 HAVING 在 SELECT 前执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;ORDER&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;BY&lt;/span&gt; total_sales &lt;span class=&#34;keyword&#34;&gt;DESC&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;LIMIT &lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;FROM orders JOIN departments USING (dept_id)&lt;/code&gt;：加载 &lt;code&gt;orders&lt;/code&gt; 和 &lt;code&gt;departments&lt;/code&gt; 表，根据 &lt;code&gt;dept_id&lt;/code&gt; 连接；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WHERE order_date &amp;gt;= &#39;2023-01-01&#39;&lt;/code&gt;：过滤出 2023 年之后的订单；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GROUP BY department_id&lt;/code&gt;：按部门分组；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HAVING SUM(sales) &amp;gt; 100000&lt;/code&gt;：过滤掉销售额 ≤10 万的部门（注意：不能直接使用别名 &lt;code&gt;total_sales&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT ...&lt;/code&gt;：计算表达式 &lt;code&gt;department_id&lt;/code&gt; 和 &lt;code&gt;SUM(sales)&lt;/code&gt;，并定义别名 &lt;code&gt;dept&lt;/code&gt; 和 &lt;code&gt;total_sales&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ORDER BY total_sales DESC&lt;/code&gt;：使用别名 &lt;code&gt;total_sales&lt;/code&gt; 降序排序；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LIMIT 10&lt;/code&gt;：限制返回前 10 条记录。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-17-SQL-题：给学生表、课程成绩表，求不存在-01-课程但存在-02-课程的学生的成绩？&#34;&gt;1.17 SQL 题：给学生表、课程成绩表，求不存在 01 课程但存在 02 课程的学生的成绩？&lt;/h3&gt;
&lt;p&gt;假设我们有以下两张表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Student&lt;/code&gt; 表，其中包含学生的 &lt;code&gt;sid&lt;/code&gt;（学生编号）和其他相关信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Score&lt;/code&gt; 表，其中包含 &lt;code&gt;sid&lt;/code&gt;（学生编号），&lt;code&gt;cid&lt;/code&gt;（课程编号）和 &lt;code&gt;score&lt;/code&gt;（分数）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（1）使用 &lt;code&gt;LEFT JOIN&lt;/code&gt; 和 &lt;code&gt;IS NULL&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; s.sid, s.sname, sc2.cid, sc2.score&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; Student s&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;LEFT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;JOIN&lt;/span&gt; Score &lt;span class=&#34;keyword&#34;&gt;AS&lt;/span&gt; sc1 &lt;span class=&#34;keyword&#34;&gt;ON&lt;/span&gt; s.sid &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; sc1.sid &lt;span class=&#34;keyword&#34;&gt;AND&lt;/span&gt; sc1.cid &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;01&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;LEFT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;JOIN&lt;/span&gt; Score &lt;span class=&#34;keyword&#34;&gt;AS&lt;/span&gt; sc2 &lt;span class=&#34;keyword&#34;&gt;ON&lt;/span&gt; s.sid &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; sc2.sid &lt;span class=&#34;keyword&#34;&gt;AND&lt;/span&gt; sc2.cid &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;02&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; sc1.cid &lt;span class=&#34;keyword&#34;&gt;IS&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;AND&lt;/span&gt; sc2.cid &lt;span class=&#34;keyword&#34;&gt;IS&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;NOT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（2）使用 &lt;code&gt;NOT EXISTS&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; s.sid, s.sname, sc.cid, sc.score&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; Student s&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;JOIN&lt;/span&gt; Score sc &lt;span class=&#34;keyword&#34;&gt;ON&lt;/span&gt; s.sid &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; sc.sid &lt;span class=&#34;keyword&#34;&gt;AND&lt;/span&gt; sc.cid &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;02&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;NOT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;EXISTS&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; Score sc1 &lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; sc1.sid &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; s.sid &lt;span class=&#34;keyword&#34;&gt;AND&lt;/span&gt; sc1.cid &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;01&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-事务&#34;&gt;2. 事务&lt;/h2&gt;
&lt;h3 id=&#34;2-1-什么是数据库事务？&#34;&gt;2.1 什么是数据库事务？&lt;/h3&gt;
&lt;p&gt;事务是一个&lt;strong&gt;不可分割&lt;/strong&gt;的数据库操作序列，也是数据库&lt;strong&gt;并发控制的基本单位&lt;/strong&gt;，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。&lt;/p&gt;
&lt;p&gt;事务最经典也经常被拿出来说例子就是转账了。&lt;/p&gt;
&lt;p&gt;假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。&lt;/p&gt;
&lt;h3 id=&#34;2-2-事务具有的四个特征？&#34;&gt;2.2 事务具有的四个特征？&lt;/h3&gt;
&lt;p&gt;事务就是一组&lt;strong&gt;原子性&lt;/strong&gt;的操作，这些操作要么全部发生，要么全部不发生。事务把数据库从一种一致性状态转换成另一种一致性状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性（Atomicity）：事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。&lt;/li&gt;
&lt;li&gt;一致性（Consistency）：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。&lt;/li&gt;
&lt;li&gt;隔离性（Isolation）：一个事务的执行不能被其它事务干扰，即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。&lt;/li&gt;
&lt;li&gt;持续性（Durability）：也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-3-什么是脏读、不可重复读与幻读？&#34;&gt;2.3 什么是脏读、不可重复读与幻读？&lt;/h3&gt;
&lt;p&gt;MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况（并发）。那么在同时处理多个事务的时候，就可能出现脏读、不可重复读以及幻读的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脏读（Dirty Read）：事务 A 读取了事务 B 更新但还没有提交的数据，如果 B 发生了回滚操作，那么 A 读取到的数据是脏数据。&lt;/li&gt;
&lt;li&gt;不可重复读（Non-repeatable Read）：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，出现前后两次读到的数据不一致的情况。&lt;/li&gt;
&lt;li&gt;幻读（Phantom Read）：在一个事务内多次查询某个符合查询条件的记录数量，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了幻读现象。例如事务 A 查询年龄大于 30 岁的用户发现共有 5 条记录，然后事务 B 也按相同的搜索条件也是查询出了 5 条记录，接着事务 A 插入了一个年龄大于 30 岁的用户，并提交了事务，此时数据库年龄大于 30 岁的用户个数就变为 6，事务 B 再次查询年龄大于 30 岁的用户，此时查询到的记录数量有 6 条，发现和前一次读到的记录数量不一样了，就感觉发生了幻觉一样。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结：不可重复读侧重于修改，幻读侧重于新增或删除（多了或少了行），脏读是一个事务回滚影响另外一个事务。&lt;/p&gt;
&lt;h3 id=&#34;2-4-MySQL-的四种隔离级别是什么？&#34;&gt;2.4 MySQL 的四种隔离级别是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Read Uncommitted（读取未提交内容）：在该隔离级别，所有事务都可以看到其他&lt;strong&gt;未提交&lt;/strong&gt;事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为&lt;strong&gt;脏读&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Read Committed（读取提交内容）：这是大多数数据库系统的默认隔离级别（但不是 MySQL 默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交的事务所做的改变。这种隔离级别会发生所谓的&lt;strong&gt;不可重复读&lt;/strong&gt;，因为同一事务的其他实例在该实例处理其间可能会有新的 &lt;code&gt;commit&lt;/code&gt;，所以同一 &lt;code&gt;SELECT&lt;/code&gt; 可能返回不同结果。&lt;/li&gt;
&lt;li&gt;Repeatable Read（可重读）：这是 MySQL InnoDB 引擎的&lt;strong&gt;默认事务隔离级别&lt;/strong&gt;，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：&lt;strong&gt;幻读&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Serializable（可串行化）：通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁（对记录加 S 型的 Next-Key 锁）。在这个级别，可能导致大量的超时现象和锁竞争。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;隔离级别&lt;/th&gt;
            &lt;th&gt;脏读&lt;/th&gt;
            &lt;th&gt;不可重复读&lt;/th&gt;
            &lt;th&gt;幻影读&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;Read Uncommitted&lt;/td&gt;
            &lt;td&gt;有&lt;/td&gt;
            &lt;td&gt;有&lt;/td&gt;
            &lt;td&gt;有&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Read Committed&lt;/td&gt;
            &lt;td&gt;无&lt;/td&gt;
            &lt;td&gt;有&lt;/td&gt;
            &lt;td&gt;有&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Repeatable Read&lt;/td&gt;
            &lt;td&gt;无&lt;/td&gt;
            &lt;td&gt;无&lt;/td&gt;
            &lt;td&gt;有&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Serializable&lt;/td&gt;
            &lt;td&gt;无&lt;/td&gt;
            &lt;td&gt;无&lt;/td&gt;
            &lt;td&gt;无&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;MySQL 默认采用的是 &lt;code&gt;REPEATABLE-READ&lt;/code&gt; 隔离级别，Oracle 默认采用的是 &lt;code&gt;READ-COMMITTED&lt;/code&gt; 隔离级别。&lt;/p&gt;
&lt;p&gt;事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是 MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。&lt;/p&gt;
&lt;p&gt;因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 &lt;code&gt;READ-COMMITTED&lt;/code&gt;（读取提交内容），但是你要知道的是 InnoDB 存储引擎默认使用 &lt;code&gt;REPEATABLE-READ&lt;/code&gt;（可重读）并不会有任何性能损失。&lt;/p&gt;
&lt;p&gt;InnoDB 存储引擎在分布式事务的情况下一般会用到 &lt;code&gt;SERIALIZABLE&lt;/code&gt;（可串行化）隔离级别。&lt;/p&gt;
&lt;h3 id=&#34;2-5-四种隔离级别具体是如何实现的呢？&#34;&gt;2.5 四种隔离级别具体是如何实现的呢？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对于&lt;strong&gt;读未提交&lt;/strong&gt;隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了。&lt;/li&gt;
&lt;li&gt;对于&lt;strong&gt;串行化&lt;/strong&gt;隔离级别的事务来说，通过加&lt;strong&gt;读写锁&lt;/strong&gt;的方式来避免并行访问。&lt;/li&gt;
&lt;li&gt;对于&lt;strong&gt;读提交&lt;/strong&gt;和&lt;strong&gt;可重复读&lt;/strong&gt;隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：读提交隔离级别是在&lt;strong&gt;每个语句执行前&lt;/strong&gt;都会重新生成一个 Read View，而可重复读隔离级别是&lt;strong&gt;启动事务时&lt;/strong&gt;生成一个 Read View，然后整个事务期间都在用这个 Read View。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-6-举个例子说一下可重复读下的幻读问题？怎么保证不发生幻读？&#34;&gt;2.6 举个例子说一下可重复读下的幻读问题？怎么保证不发生幻读？&lt;/h3&gt;
&lt;p&gt;可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读。假如当前数据表中没有 ID 为 3 的用户记录，事务 A 第一次执行普通的 &lt;code&gt;SELECT&lt;/code&gt; 语句时生成了一个 Read View，此时事务 A 查不到 ID 为 3 的记录，接着事务 B 插入一条 ID 为 3 的记录，并且提交了事务，假如这时事务 A 在看不到记录的情况下去更新了这条 ID 为 3 的记录（场景确实很违和），然后事务 A 再次查询 ID 为 3 的记录，事务 A 就能看到事务 B 插入的记录了，幻读就是发生在这种违和的场景。因为这种特殊现象的存在，所以我们认为 MySQL InnoDB 中的 MVCC 并&lt;strong&gt;不能完全避免幻读现象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们可以尽量在开启事务之后，马上执行  &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; 这类锁定读的语句，因为它会对记录加临键锁（Next-Key Locks）这是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁，从而避免其他事务插入一条新记录，就避免了幻读的问题。&lt;/p&gt;
&lt;h3 id=&#34;2-7-MySQL-是怎么解决并发问题的？&#34;&gt;2.7 MySQL 是怎么解决并发问题的？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;锁机制：MySQL 提供了多种锁机制来保证数据的一致性，包括行级锁、表级锁、页级锁等，通过锁机制，可以在读写操作时对数据进行加锁，确保同时只有一个操作能够访问或修改数据。&lt;/li&gt;
&lt;li&gt;事务隔离级别：MySQL 提供了多种事务隔离级别，包括读未提交、读已提交、可重复读和串行化。通过设置合适的事务隔离级别，可以在多个事务并发执行时，控制事务之间的隔离程度，以避免数据不一致的问题。&lt;/li&gt;
&lt;li&gt;MVCC（多版本并发控制）：MySQL 使用 MVCC 来管理并发访问，它通过在数据库中保存不同版本的数据来实现不同事务之间的隔离。在读取数据时，MySQL 会根据事务的隔离级别来选择合适的数据版本，从而保证数据的一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-8-事务的实现原理？&#34;&gt;2.8 事务的实现原理？&lt;/h3&gt;
&lt;p&gt;事务是基于重做日志文件（redo log）和回滚日志（undo log）实现的。&lt;/p&gt;
&lt;p&gt;每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。&lt;/p&gt;
&lt;p&gt;每当有修改事务时，还会产生 undo log，如果需要回滚，则根据 undo log 的反向语句进行逻辑操作，比如 &lt;code&gt;insert&lt;/code&gt; 一条记录就 &lt;code&gt;delete&lt;/code&gt; 一条记录。undo log 主要实现数据库的一致性。&lt;/p&gt;
&lt;h3 id=&#34;2-9-介绍一下-MySQL-事务日志？&#34;&gt;2.9 介绍一下 MySQL 事务日志？&lt;/h3&gt;
&lt;p&gt;InnoDB 事务日志包括 redo log 和 undo log。&lt;/p&gt;
&lt;p&gt;undo log 指事务开始之前，在操作任何数据之前，首先将需操作的数据备份到一个地方。redo log 指事务中操作的任何数据，将最新的数据备份到一个地方。&lt;/p&gt;
&lt;p&gt;事务日志的目的：实例或者介质失败，事务日志文件就能派上用场。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;redu log：redo log 不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入 redo log 中。具体的落盘策略可以进行配置。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。redo log 是为了实现事务的持久性而出现的产物。&lt;/li&gt;
&lt;li&gt;undo log：undo log 用来回滚行记录到某个版本。事务未提交之前，undo log 保存了未提交之前的版本数据，undo log 中的数据可作为数据旧版本快照供其他并发事务进行快照读。是为了实现事务的原子性而出现的产物，在 MySQL InnoDB 存储引擎中用来实现多版本并发控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-10-什么是-MySQL-的-binlog？&#34;&gt;2.10 什么是 MySQL 的 binlog？&lt;/h3&gt;
&lt;p&gt;MySQL 的 binlog 是记录所有数据库&lt;strong&gt;表结构变更&lt;/strong&gt;（例如 &lt;code&gt;CREATE&lt;/code&gt;、&lt;code&gt;ALTER TABLE&lt;/code&gt;）以及&lt;strong&gt;表数据修改&lt;/strong&gt;（例如 &lt;code&gt;INSERT&lt;/code&gt;、&lt;code&gt;UPDATE&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt;）的二进制日志。binlog 不会记录 &lt;code&gt;SELECT&lt;/code&gt; 和 &lt;code&gt;SHOW&lt;/code&gt; 这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看 MySQL 执行过的所有语句。&lt;/p&gt;
&lt;p&gt;MySQL binlog 以事件形式记录，还包含语句执行所消耗的时间，MySQL 的二进制日志是事务安全型的。binlog 的主要目的是复制和恢复。&lt;/p&gt;
&lt;p&gt;binlog 有三种格式，各有优缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;statement&lt;/code&gt;：基于 SQL 语句的模式，某些语句和函数如 &lt;code&gt;UUID&lt;/code&gt;、&lt;code&gt;LOAD DATA INFILE&lt;/code&gt; 等在复制过程中可能导致数据不一致甚至出错。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;row&lt;/code&gt;：基于行的模式，记录的是行的变化，很安全。但是 binlog 会比其他两种模式大很多，在一些大表中清除大量数据时在 binlog 中会生成很多条语句，可能导致从库延迟变大。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mixed&lt;/code&gt;：混合模式，根据语句来选用是 &lt;code&gt;statement&lt;/code&gt; 还是 &lt;code&gt;row&lt;/code&gt; 模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-11-在事务中可以混合使用存储引擎吗？&#34;&gt;2.11 在事务中可以混合使用存储引擎吗？&lt;/h3&gt;
&lt;p&gt;尽量不要在同一个事务中使用多种存储引擎，MySQL 服务器层不管理事务，事务是由下层的存储引擎实现的。&lt;/p&gt;
&lt;p&gt;如果在事务中混合使用了事务型和非事务型的表（例如 InnoDB 和 MyISAM 表），在正常提交的情况下不会有什么问题。&lt;/p&gt;
&lt;p&gt;但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。所以，为每张表选择合适的存储引擎非常重要。&lt;/p&gt;
&lt;h3 id=&#34;2-12-什么是-MVCC？&#34;&gt;2.12 什么是 MVCC？&lt;/h3&gt;
&lt;p&gt;MVCC，即多版本并发控制，允许多个事务同时读取同一行数据，而不会彼此阻塞，每个事务看到的数据版本是该事务开始时的数据版本，这意味着如果其他事务在此期间修改了数据，正在运行的事务仍然看到的是它开始时的数据状态，从而实现了非阻塞读操作。&lt;/p&gt;
&lt;h3 id=&#34;2-13-MVCC-的实现原理是什么？&#34;&gt;2.13 MVCC 的实现原理是什么？&lt;/h3&gt;
&lt;p&gt;MVCC 的实现，是通过保存数据在某个时间点的快照来实现的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。&lt;/p&gt;
&lt;p&gt;对于读提交和可重复读隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，Read View 就可以理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读提交隔离级别是在每个 &lt;code&gt;SELECT&lt;/code&gt; 语句执行前都会重新生成一个 Read View。&lt;/li&gt;
&lt;li&gt;可重复读隔离级别是执行第一条 &lt;code&gt;SELECT&lt;/code&gt; 时生成一个 Read View，然后整个事务期间都在用这个 Read View。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 InnoDB，聚簇索引记录中包含 3 个隐藏的列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ROW ID：隐藏的自增 ID，如果表没有主键，InnoDB 会自动按 ROW ID 产生一个聚集索引树。&lt;/li&gt;
&lt;li&gt;事务 ID：记录最后一次修改该记录的事务 ID。&lt;/li&gt;
&lt;li&gt;回滚指针：指向这条记录的上一个版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们举个例子，假如现在有两个事务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务 1：&lt;code&gt;INSERT INTO t1(a, b) VALUES (1, 1);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;事务 2：&lt;code&gt;UPDATE t1 SET b = 666 WHERE a = 1;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如图，首先 &lt;code&gt;INSERT&lt;/code&gt; 语句向表 &lt;code&gt;t1&lt;/code&gt; 中插入了一条数据，&lt;code&gt;a&lt;/code&gt; 字段为 1，&lt;code&gt;b&lt;/code&gt; 字段为 1，ROW ID 也为 1，事务 ID 假设为 1，回滚指针假设为 &lt;code&gt;null&lt;/code&gt;。当执行 &lt;code&gt;UPDATE t1 SET b = 666 WHERE a = 1&lt;/code&gt; 时，大致步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库会先对满足 &lt;code&gt;a = 1&lt;/code&gt; 的行加排他锁；&lt;/li&gt;
&lt;li&gt;然后将原记录复制到 undo 表空间中；&lt;/li&gt;
&lt;li&gt;修改 &lt;code&gt;b&lt;/code&gt; 字段的值为 666，修改事务 ID 为2；&lt;/li&gt;
&lt;li&gt;并通过隐藏的回滚指针指向 undo log 中的历史记录；&lt;/li&gt;
&lt;li&gt;事务提交，释放前面对满足 &lt;code&gt;a = 1&lt;/code&gt; 的行所加的排他锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此可以总结出 MVCC 实现的原理大致是：InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。&lt;/p&gt;
&lt;p&gt;MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性，通过 MVCC 能够保证事务 ACID 中的隔离性。&lt;/p&gt;
&lt;h2 id=&#34;3-锁&#34;&gt;3. 锁&lt;/h2&gt;
&lt;h3 id=&#34;3-1-为什么要加锁？&#34;&gt;3.1 为什么要加锁？&lt;/h3&gt;
&lt;p&gt;当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况，若对并发操作不加控制就可能读取和存储不正确的数据，破坏数据库的一致性，因此需要加锁使得在多用户环境下保证数据库的完整性和一致性。&lt;/p&gt;
&lt;h3 id=&#34;3-2-按照锁的粒度能分为哪些锁？&#34;&gt;3.2 按照锁的粒度能分为哪些锁？&lt;/h3&gt;
&lt;p&gt;在关系型数据库中，可以按照锁的粒度把数据库锁分为&lt;strong&gt;全局锁&lt;/strong&gt;、&lt;strong&gt;行级锁&lt;/strong&gt;（InnoDB 引擎）、&lt;strong&gt;表级锁&lt;/strong&gt;（MyISAM 引擎）和&lt;strong&gt;页级锁&lt;/strong&gt;（BDB 引擎）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局锁：通过 &lt;code&gt;FLUSH TABLES WITH READ LOCK&lt;/code&gt; 语句会让整个数据库处于只读状态，这时其他线程执行增删改或者表结构修改操作都会阻塞。全局锁主要应用于做&lt;strong&gt;全库逻辑备份&lt;/strong&gt;，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。&lt;/li&gt;
&lt;li&gt;表级锁
&lt;ul&gt;
&lt;li&gt;表级锁是 MySQL 中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MyISAM 与 InnoDB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。&lt;/li&gt;
&lt;li&gt;特点是开销小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;LOCK TABLES&lt;/code&gt; 语句可以对表加表锁，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。&lt;/li&gt;
&lt;li&gt;当我们对数据库表进行操作时，会自动给这个表加上 MDL（元数据锁），对一张表进行 CRUD 操作时，加的是 MDL 读锁；对一张表做结构变更操作的时候，加的是 MDL 写锁；MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。&lt;/li&gt;
&lt;li&gt;当执行插入、更新、删除操作，需要先对表加上意向独占锁，然后对该记录加独占锁。意向锁的目的是为了&lt;strong&gt;快速判断表里是否有记录被加锁&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;行级锁
&lt;ul&gt;
&lt;li&gt;行级锁是 MySQL 中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。&lt;/li&gt;
&lt;li&gt;特点是开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高。&lt;/li&gt;
&lt;li&gt;InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;页级锁
&lt;ul&gt;
&lt;li&gt;页级锁是 MySQL 中锁定粒度介于行级锁和表级锁之间的一种锁。表级锁速度快，但冲突多，行级锁冲突少，但速度慢。所以取了折衷的页级锁，一次锁定相邻的一组记录。BDB 支持页级锁。&lt;/li&gt;
&lt;li&gt;开销和加锁时间界于表锁和行锁之间，会出现死锁，锁定粒度界于表锁和行锁之间，并发度一般。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MyISAM 和 InnoDB 存储引擎使用的锁：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MyISAM 采用表级锁（table-level locking）。&lt;/li&gt;
&lt;li&gt;InnoDB 支持行级锁（row-level locking）和表级锁，默认为行级锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-3-数据库的表锁和行锁有什么作用？&#34;&gt;3.3 数据库的表锁和行锁有什么作用？&lt;/h3&gt;
&lt;p&gt;表锁的作用如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整体控制：表锁可以用来控制整个表的并发访问，当一个事务获取了表锁时，其他事务无法对该表进行任何读写操作，从而确保数据的完整性和一致性。&lt;/li&gt;
&lt;li&gt;粒度大：表锁的粒度比较大，在锁定表的情况下，可能会影响到整个表的其他操作，可能会引起锁竞争和性能问题。&lt;/li&gt;
&lt;li&gt;适用于大批量操作：表锁适合于需要大批量操作表中数据的场景，例如表的重建、大量数据的加载等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;行锁的作用如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;细粒度控制：行锁可以精确控制对表中某行数据的访问，使得其他事务可以同时访问表中的其他行数据，在并发量大的系统中能够提高并发性能。&lt;/li&gt;
&lt;li&gt;减少锁冲突：行锁不会像表锁那样造成整个表的锁冲突，减少了锁竞争的可能性，提高了并发访问的效率。&lt;/li&gt;
&lt;li&gt;适用于频繁单行操作：行锁适合于需要频繁对表中单独行进行操作的场景，例如订单系统中的订单修改、删除等操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-4-MySQL-两个线程的-UPDATE-语句同时处理一条数据，会不会有阻塞？&#34;&gt;3.4 MySQL 两个线程的 UPDATE 语句同时处理一条数据，会不会有阻塞？&lt;/h3&gt;
&lt;p&gt;如果两个事务同时更新了 ID 为 1 的记录，比如 &lt;code&gt;UPDATE ... WHERE id = 1;&lt;/code&gt;，那么是会阻塞的，因为 InnoDB 存储引擎实现了行级锁。当 A 事务对 ID 为 1 的这行记录进行更新时，会对主键 ID 为 1 的记录加 X 类型的记录锁，这样另一个事务 B 对 ID 为 1 的记录进行更新时，发现已经有记录锁了，就会陷入阻塞状态。&lt;/p&gt;
&lt;h3 id=&#34;3-5-从锁的类别上分-MySQL-都有哪些锁呢？&#34;&gt;3.5 从锁的类别上分 MySQL 都有哪些锁呢？&lt;/h3&gt;
&lt;p&gt;从锁的类别上来讲，有共享锁和排他锁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享锁：又叫做读锁，当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。&lt;/li&gt;
&lt;li&gt;排他锁：又叫做写锁，当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，它和其它的排他锁，共享锁都相斥。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。&lt;/p&gt;
&lt;p&gt;锁的粒度取决于具体的存储引擎，InnoDB 实现了行级锁，页级锁，表级锁。他们的加锁开销从大到小，并发能力也是从大到小。&lt;/p&gt;
&lt;h3 id=&#34;3-6-数据库的乐观锁和悲观锁是什么？怎么实现的？&#34;&gt;3.6 数据库的乐观锁和悲观锁是什么？怎么实现的？&lt;/h3&gt;
&lt;p&gt;数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制。&lt;/li&gt;
&lt;li&gt;乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过 version 的方式来进行锁定。实现方式：乐观锁一般会使用版本号机制或 CAS 算法实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种锁的使用场景：&lt;/p&gt;
&lt;p&gt;从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。&lt;/p&gt;
&lt;p&gt;但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行 &lt;code&gt;retry&lt;/code&gt;，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。&lt;/p&gt;
&lt;h3 id=&#34;3-7-InnoDB-引擎的行锁是怎么实现的？&#34;&gt;3.7 InnoDB 引擎的行锁是怎么实现的？&lt;/h3&gt;
&lt;p&gt;InnoDB 是基于索引来完成行锁的。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;SELECT * FROM tab_with_index WHERE id = 1 FOR UPDATE;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FOR UPDATE&lt;/code&gt; 可以根据条件来完成行锁锁定，并且 &lt;code&gt;id&lt;/code&gt; 是有索引键的列，如果 &lt;code&gt;id&lt;/code&gt; 不是索引键那么 InnoDB 将完成表锁，并发将无从谈起。&lt;/p&gt;
&lt;h3 id=&#34;3-8-什么是死锁？怎么解决？&#34;&gt;3.8 什么是死锁？怎么解决？&lt;/h3&gt;
&lt;p&gt;死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。常见的解决死锁的方法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。&lt;/li&gt;
&lt;li&gt;在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率。&lt;/li&gt;
&lt;li&gt;对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果业务处理不好可以用分布式事务锁或者使用乐观锁。&lt;/p&gt;
&lt;h3 id=&#34;3-9-隔离级别与锁的关系？&#34;&gt;3.9 隔离级别与锁的关系？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在 Read Uncommitted 级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突。&lt;/li&gt;
&lt;li&gt;在 Read Committed 级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁。&lt;/li&gt;
&lt;li&gt;在 Repeatable Read 级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。&lt;/li&gt;
&lt;li&gt;Serializable 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-10-优化锁方面的意见？&#34;&gt;3.10 优化锁方面的意见？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用较低的隔离级别。&lt;/li&gt;
&lt;li&gt;设计索引，尽量使用索引去访问数据，加锁更加精确，从而减少锁冲突。&lt;/li&gt;
&lt;li&gt;选择合理的事务大小，给记录显示加锁时，最好一次性请求足够级别的锁。例如，修改数据的话最好申请排他锁，而不是先申请共享锁，修改时再申请排他锁，这样会导致死锁。&lt;/li&gt;
&lt;li&gt;不同的程序访问一组表的时候，应尽量约定一个相同的顺序访问各表，对于一个表而言，尽可能固定顺序地获取表中的行，这样将大大减少死锁的机会。&lt;/li&gt;
&lt;li&gt;尽量使用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。&lt;/li&gt;
&lt;li&gt;不要申请超过实际需要的锁级别。&lt;/li&gt;
&lt;li&gt;数据查询的时候不是必要，不要使用加锁。MySQL 的 MVCC 可以实现事务中的查询不用加锁，优化事务性能：MVCC 只在 Read Committed（读提交）和 Repeatable Read（可重复读）两种隔离级别。&lt;/li&gt;
&lt;li&gt;对于特定的事务，可以使用表锁来提高处理速度或者减少死锁的可能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-索引&#34;&gt;4. 索引&lt;/h2&gt;
&lt;h3 id=&#34;4-1-索引是什么？&#34;&gt;4.1 索引是什么？&lt;/h3&gt;
&lt;p&gt;索引是一种特殊的文件/数据结构（InnoDB 数据表上的索引是表空间的一个组成部分），它们包含着对数据表里所有记录的引用指针，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。类似于书籍的目录，可以减少扫描的数据量，提高查询效率。但是索引是一个文件，它是要占据物理空间的。索引的实现通常使用 B 树及其变种 B+ 树。&lt;/p&gt;
&lt;p&gt;MySQL 索引的建立对于 MySQL 的高效运行是很重要的，索引可以大大提高 MySQL 的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，打开字典的页数就可以知道我们要搜索的某一个 Key 的全部值的信息了。&lt;/p&gt;
&lt;h3 id=&#34;4-2-索引有哪些优缺点？&#34;&gt;4.2 索引有哪些优缺点？&lt;/h3&gt;
&lt;p&gt;索引的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以大大加快数据的检索速度，这也是创建索引的最主要的原因。&lt;/li&gt;
&lt;li&gt;通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;索引的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间方面：创建索引和维护索引要耗费时间，所需的时间开销随着数据量的增加而增大。此外还会降低表的增删改的效率，当对表中的数据进行增删改的时候，索引也要动态地维护（B+ 树维护索引有序性）。&lt;/li&gt;
&lt;li&gt;空间方面：索引需要占用物理空间，索引数量越多，占用空间越大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-3-MySQL-有哪几种索引类型？&#34;&gt;4.3 MySQL 有哪几种索引类型？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;从存储结构（数据结构）上来划分：BTree 索引（B-Tree 或 B+Tree 索引）、Hash 索引、Full-index 全文索引、R-Tree 索引。这里所描述的是索引存储时保存的形式。&lt;/li&gt;
&lt;li&gt;从应用层次来分：普通索引、唯一索引、复合索引。
&lt;ul&gt;
&lt;li&gt;普通索引：即一个索引只包含单个列，一个表可以有多个单列索引。&lt;/li&gt;
&lt;li&gt;唯一索引：索引列的值必须唯一，但允许有空值。&lt;/li&gt;
&lt;li&gt;复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;根据表中数据的物理顺序与键值的逻辑（索引）顺序关系：聚簇索引、非聚簇索引。
&lt;ul&gt;
&lt;li&gt;聚簇索引（主键索引）：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB 的聚簇索引其实就是在同一个结构中保存了 B-Tree 索引（技术上来说是 B+Tree）和数据行。&lt;/li&gt;
&lt;li&gt;非聚簇索引：不是聚簇索引，就是非聚簇索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-4-如何创建索引？&#34;&gt;4.4 如何创建索引？&lt;/h3&gt;
&lt;p&gt;创建索引有以下三种方式：&lt;/p&gt;
&lt;p&gt;（1）在执行 &lt;code&gt;CREATE TABLE&lt;/code&gt; 时创建索引：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;CREATE&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;TABLE&lt;/span&gt; table_name (&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    id &lt;span class=&#34;type&#34;&gt;INT&lt;/span&gt; auto_increment &lt;span class=&#34;keyword&#34;&gt;PRIMARY&lt;/span&gt; KEY,  &lt;span class=&#34;comment&#34;&gt;-- 在 id 字段上建立主键索引&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    first_name &lt;span class=&#34;type&#34;&gt;VARCHAR&lt;/span&gt; (&lt;span class=&#34;number&#34;&gt;16&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    last_name &lt;span class=&#34;type&#34;&gt;VARCHAR&lt;/span&gt; (&lt;span class=&#34;number&#34;&gt;16&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    id_card &lt;span class=&#34;type&#34;&gt;VARCHAR&lt;/span&gt; (&lt;span class=&#34;number&#34;&gt;18&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    information text,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    KEY name (first_name, last_name),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    FULLTEXT KEY (information) ,  &lt;span class=&#34;comment&#34;&gt;-- 在 information 字段上建立全文索引&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;UNIQUE&lt;/span&gt; KEY (id_card)  &lt;span class=&#34;comment&#34;&gt;-- 在 id_card 字段上建立唯一索引&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（2）使用 &lt;code&gt;ALTER TABLE&lt;/code&gt; 命令添加索引：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;ALTER&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;TABLE&lt;/span&gt; table_name &lt;span class=&#34;keyword&#34;&gt;ADD&lt;/span&gt; INDEX index_name (column_list);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;ALTER TABLE&lt;/code&gt; 用来创建普通索引、&lt;code&gt;UNIQUE&lt;/code&gt; 索引或 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 索引。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;table_name&lt;/code&gt; 是要增加索引的表名，&lt;code&gt;column_list&lt;/code&gt; 指出对哪些列进行索引，如果索引多列则各列之间用逗号分隔。&lt;/p&gt;
&lt;p&gt;索引名 &lt;code&gt;index_name&lt;/code&gt; 可自己命名，缺省时，MySQL 将根据第一个索引列赋一个名称。另外，&lt;code&gt;ALTER TABLE&lt;/code&gt; 允许在单个语句中更改多个表，因此可以同时创建多个索引。&lt;/p&gt;
&lt;p&gt;（3）使用 &lt;code&gt;CREATE INDEX&lt;/code&gt; 命令创建索引：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;CREATE&lt;/span&gt; INDEX index_name &lt;span class=&#34;keyword&#34;&gt;ON&lt;/span&gt; table_name (column_list);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不同类型索引的具体创建方式如下：&lt;/p&gt;
&lt;p&gt;（1）主键索引&lt;/p&gt;
&lt;p&gt;主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。在创建表时，创建主键索引的方式如下：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;CREATE&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;TABLE&lt;/span&gt; table_name (&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;PRIMARY&lt;/span&gt; KEY (id) &lt;span class=&#34;keyword&#34;&gt;USING&lt;/span&gt; BTREE&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（2）唯一索引&lt;/p&gt;
&lt;p&gt;唯一索引是建立在 &lt;code&gt;UNIQUE&lt;/code&gt; 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。在创建表时，创建唯一索引的方式如下：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;CREATE&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;TABLE&lt;/span&gt; table_name (&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;UNIQUE&lt;/span&gt; KEY (column_1, column_2, ...)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;建表后，如果要创建唯一索引，可以使用这面这条命令：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;CREATE&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;UNIQUE&lt;/span&gt; INDEX index_name&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;ON&lt;/span&gt; table_name (column_1, column_2, ...);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（3）普通索引&lt;/p&gt;
&lt;p&gt;普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 &lt;code&gt;UNIQUE&lt;/code&gt;。在创建表时，创建普通索引的方式如下：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;CREATE&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;TABLE&lt;/span&gt; table_name (&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    INDEX (column_1, column_2, ...)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;建表后，如果要创建普通索引，可以使用这面这条命令：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;CREATE&lt;/span&gt; INDEX index_name&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;ON&lt;/span&gt; table_name (column_1, column_2, ...);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（4）前缀索引&lt;/p&gt;
&lt;p&gt;前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 &lt;code&gt;CHAR&lt;/code&gt;、&lt;code&gt;VARCHAR&lt;/code&gt;、&lt;code&gt;BINARY&lt;/code&gt;、&lt;code&gt;VARBINARY&lt;/code&gt; 的列上。使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。在创建表时，创建前缀索引的方式如下：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;CREATE&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;TABLE&lt;/span&gt; table_name (&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    INDEX (column_name(length))&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;建表后，如果要创建前缀索引，可以使用这面这条命令：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;CREATE&lt;/span&gt; INDEX index_name&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;ON&lt;/span&gt; table_name (column_name(length));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-5-创建索引时需要注意什么？&#34;&gt;4.5 创建索引时需要注意什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;非空字段：应该指定列为 &lt;code&gt;NOT NULL&lt;/code&gt;，除非你想存储 &lt;code&gt;NULL&lt;/code&gt;。在 MySQL 中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用 0 或者一个特殊的值或者一个空串代替空值；&lt;/li&gt;
&lt;li&gt;取值离散（变量各个取值之间的差异程度）大的字段的列放到联合索引的前面，可以通过 &lt;code&gt;COUNT()&lt;/code&gt; 函数查看字段的差异值，返回值越大说明字段的唯一值越多，字段的离散程度高；&lt;/li&gt;
&lt;li&gt;索引字段越小越好：数据库的数据存储以页为单位，一页存储的数据越多则一次 I/O 操作获取的数据越多，效率越高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-6-讲一讲聚簇索引与非聚簇索引？&#34;&gt;4.6 讲一讲聚簇索引与非聚簇索引？&lt;/h3&gt;
&lt;p&gt;在 InnoDB 里，B+ 树的叶子节点存储了整行数据为主键索引，也被称之为聚簇索引，即将数据存储与索引放到了一块，找到索引也就找到了数据。一张表只能有一个聚簇索引，那了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。&lt;/p&gt;
&lt;p&gt;聚簇索引与非聚簇索引的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据存储：聚簇索引中，数据行按照索引键值的顺序存储，即索引的叶子节点包含了实际的数据行，这意味着索引结构本身就是数据的物理存储结构；非聚簇索引的叶子节点不存储表中的数据，而是存储该列对应的主键（包含指向数据行的指针或主键值）。&lt;/li&gt;
&lt;li&gt;索引与数据关系：由于数据与索引紧密相连，当通过聚簇索引查找数据时，可以直接从索引中获得数据行，而不需要额外的步骤去查找数据所在的位置。当通过非聚簇索引查找数据时，首先在非聚簇索引中找到对应的主键值，然后通过这个主键值回溯到聚簇索引中查找实际的数据行，这个过程称为&lt;strong&gt;回表&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;唯一性：聚簇索引通常是基于主键构建的，因此&lt;strong&gt;每个表只能有一个聚簇索引&lt;/strong&gt;，因为数据只能有一种物理排序方式。一个表可以有多个非聚簇索引，因为它们不直接影响数据的物理存储位置。&lt;/li&gt;
&lt;li&gt;效率：通常情况下，聚簇索引查询只会查一次，对于范围查询和排序查询，聚簇索引通常更有效率，因为它避免了额外的寻址开销，而非聚簇索引需要回表查询多次，当然，非聚簇索引在使用覆盖索引进行查询时效率更高，因为它不需要读取完整的数据行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：MyISAM 无论主键索引还是二级索引都是非聚簇索引，而 InnoDB 的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建立的索引基本都是非聚簇索引。&lt;/p&gt;
&lt;p&gt;InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果有主键，默认会使用主键作为聚簇索引的索引键；&lt;/li&gt;
&lt;li&gt;如果没有主键，就选择第一个不包含 &lt;code&gt;NULL&lt;/code&gt; 值的唯一列作为聚簇索引的索引键；&lt;/li&gt;
&lt;li&gt;在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 &lt;code&gt;id&lt;/code&gt; 列作为聚簇索引的索引键。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-7-非聚簇索引一定会回表查询吗？&#34;&gt;4.7 非聚簇索引一定会回表查询吗？&lt;/h3&gt;
&lt;p&gt;不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为&lt;strong&gt;覆盖索引&lt;/strong&gt;。举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行 &lt;code&gt;SELECT age FROM employee WHERE age &amp;gt; 30&lt;/code&gt; 的查询时，在索引的叶子节点上，已经包含了 &lt;code&gt;age&lt;/code&gt; 信息，不会再次进行回表查询。&lt;/p&gt;
&lt;h3 id=&#34;4-8-什么字段适合当做主键？&#34;&gt;4.8 什么字段适合当做主键？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;字段具有唯一性，且不能为空的特性。&lt;/li&gt;
&lt;li&gt;字段最好的是有递增的趋势的，如果字段的值是随机无序的，可能会引发页分裂的问题，造成性能影响。&lt;/li&gt;
&lt;li&gt;不建议用业务数据作为主键，比如会员卡号、订单号、学生号之类的，因为我们无法预测未来会不会因为业务需要，而出现业务字段重复或者重用的情况。&lt;/li&gt;
&lt;li&gt;通常情况下会用自增字段来做主键，对于单机系统来说是没问题的。但是如果有多台服务器，各自都可以录入数据，那就不一定适用了。因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题，这时候就需要考虑分布式 ID 的方案了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-9-性别字段能加索引么？&#34;&gt;4.9 性别字段能加索引么？&lt;/h3&gt;
&lt;p&gt;不建议针对性别字段加索引，因为索引创建规则之一需要考虑区分度，性别字段假设有 100w 条数据，50w 男、50w 女，区分度几乎等于 0。区分度的计算方式为 &lt;code&gt;SELECT COUNT(DISTINCT sex)/COUNT(*) FROM users&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于性别字段不适合创建索引，是因为 &lt;code&gt;SELECT *&lt;/code&gt; 操作，还得进行 50w 次回表操作，根据主键从聚簇索引中找到其他字段，这一部分开销从上面的测试来说还是比较大的，加上索引并不是索引失效，而是回表操作使得变慢的。&lt;/p&gt;
&lt;p&gt;既然走索引的查询的成本比全表扫描高，优化器就会选择全表扫描的方向进行查询，这时候建立的性别字段索引就没有启到加快查询的作用，反而还因为创建了索引占用了空间。&lt;/p&gt;
&lt;h3 id=&#34;4-10-你主键用自增-ID-还是-UUID，为什么？&#34;&gt;4.10 你主键用自增 ID 还是 UUID，为什么？&lt;/h3&gt;
&lt;p&gt;用的是自增 ID，因为 UUID 相对于顺序的自增 ID 来说是毫无规律可言的，新行的值不一定要比之前的主键的值要大，所以 InnoDB 无法做到总是把新行插入到索引的最后，而是需要为新行寻找新的合适的位置从而来分配新的空间。&lt;/p&gt;
&lt;p&gt;这个过程需要做很多额外的操作，数据的毫无顺序会导致数据分布散乱，将会导致以下的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写入的目标页很可能已经刷新到磁盘上并且从缓存上移除，或者还没有被加载到缓存中，InnoDB 在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机 I/O。&lt;/li&gt;
&lt;li&gt;因为写入是乱序的，InnoDB 不得不频繁的做页分裂操作，以便为新的行分配空间，页分裂导致移动大量的数据，影响性能。&lt;/li&gt;
&lt;li&gt;由于频繁的页分裂，页会变得稀疏并被不规则的填充，最终会导致数据会有碎片。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此使用 InnoDB 应该尽可能地按主键的自增顺序插入，并且尽可能使用单调增加的聚簇键的值来插入新行。&lt;/p&gt;
&lt;h3 id=&#34;4-11-MySQL-中的索引是怎么实现的？&#34;&gt;4.11 MySQL 中的索引是怎么实现的？&lt;/h3&gt;
&lt;p&gt;MySQL InnoDB 引擎是用了 B+ 树作为索引的数据结构。B+ 树是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。&lt;/p&gt;
&lt;p&gt;数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I/O 操作。B+ 树存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以 B+ 树相比于 B 树和二叉树来说，最大的优势在于&lt;strong&gt;查询效率很高&lt;/strong&gt;，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4 次。&lt;/p&gt;
&lt;h3 id=&#34;4-12-B-树的特性是什么？&#34;&gt;4.12 B+ 树的特性是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;所有叶子节点都在同一层：这是 B+ 树的一个重要特性，确保了所有数据项的检索都具有相同的 I/O 延迟，提高了搜索效率。每个叶子节点都包含指向相邻叶子节点的指针，形成一个链表，由于叶子节点之间的链接，B+ 树非常适合进行范围查询和排序扫描。可以沿着叶子节点的链表顺序访问数据，而无需进行多次随机访问。&lt;/li&gt;
&lt;li&gt;非叶子节点存储键值：非叶子节点仅存储键值和指向子节点的指针，不包含数据记录。这些键值用于指导搜索路径，帮助快速定位到正确的叶子节点。并且由于非叶子节点只存放键值，当数据量比较大时，相对于 B 树，B+ 树的层高更少，查找效率也就更高。&lt;/li&gt;
&lt;li&gt;叶子节点存储数据记录：与 B 树不同，B+ 树的叶子节点存储实际的数据记录或指向数据记录的指针，这意味着每次搜索都会到达叶子节点，才能找到所需数据。&lt;/li&gt;
&lt;li&gt;自平衡：B+ 树在插入、删除和更新操作后会自动重新平衡，确保树的高度保持相对稳定，从而保持良好的搜索性能。每个节点最多可以有 &lt;code&gt;M&lt;/code&gt; 个子节点，最少可以有 &lt;code&gt;ceil(M / 2)&lt;/code&gt; 个子节点（除了根节点），这里的 &lt;code&gt;M&lt;/code&gt; 是树的阶数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-13-B-树和-B-树的区别是什么？&#34;&gt;4.13 B+ 树和 B 树的区别是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在 B+ 树中，数据都存储在叶子节点上，而非叶子节点只存储索引信息；而 B 树的非叶子节点既存储索引信息也存储部分数据。在数据量相同的情况下，B+ 树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更“矮胖”，查询底层节点的磁盘 I/O 次数会更少。&lt;/li&gt;
&lt;li&gt;B+ 树的叶子节点使用链表相连，便于范围查询和顺序访问；B 树的叶子节点没有链表连接，因此 B 树只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。&lt;/li&gt;
&lt;li&gt;B+ 树的查找性能更稳定，每次查找都需要查找到叶子节点；而 B 树的查找可能会在非叶子节点找到数据，性能相对不稳定。&lt;/li&gt;
&lt;li&gt;B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-14-说一说索引的底层实现？&#34;&gt;4.14 说一说索引的底层实现？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Hash 索引：基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且 Hash 索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。&lt;/li&gt;
&lt;li&gt;B 树索引：B 树能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。&lt;/li&gt;
&lt;li&gt;B+ 树索引：B 树的改进版本，同时也是数据库索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比 B 树来说，进行范围查找时只需要查找两个节点，进行遍历即可。而 B 树需要获取所有节点，相比之下 B+ 树效率更高。B+ 树性质如下：
&lt;ul&gt;
&lt;li&gt;N 棵子树的节点包含 N 个关键字，不用来保存数据而是保存数据的索引。&lt;/li&gt;
&lt;li&gt;所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身根据关键字的大小自小而大顺序链接。&lt;/li&gt;
&lt;li&gt;所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。&lt;/li&gt;
&lt;li&gt;B+ 树中，数据对象的插入和删除仅在叶节点上进行。&lt;/li&gt;
&lt;li&gt;B+ 树有 2 个头指针，一个是树的根节点，一个是最小关键码的叶节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-15-为什么索引结构默认使用-B-树，而不是-B-树、Hash、二叉树、红黑树？&#34;&gt;4.15 为什么索引结构默认使用 B+ 树，而不是 B 树、Hash、二叉树、红黑树？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;B 树：B+ 树只在叶子节点存储数据，分支结点均为索引，而 B 树的非叶子节点也要存储数据，所以 B+ 树的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。另外，B+ 树叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。&lt;/li&gt;
&lt;li&gt;Hash：哈希索引基于哈希表实现，只有 Memory 存储引擎显式支持哈希索引，哈希索引在做等值查询（如 &lt;code&gt;=&lt;/code&gt;、&lt;code&gt;IN()&lt;/code&gt;、&lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;）的时候效率贼快，搜索复杂度为常数级，但是哈希表没有顺序，I/O 复杂度高，不适合做范围查询，这也是 B+ 树索引要比哈希索引有着更广泛的适用场景的原因。此外因为哈希索引始终索引&lt;strong&gt;所有列的全部内容&lt;/strong&gt;，所以不支持部分索引列的匹配查找，并且如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在&lt;strong&gt;哈希碰撞&lt;/strong&gt;问题。&lt;/li&gt;
&lt;li&gt;二叉树：树的高度不均匀，不能自平衡，且二叉树的每个父节点的儿子节点个数只能是 2 个，树的高度比 B+ 树高很多，由于查找效率跟树的高度相关，即使数据达到千万级别时，B+ 树的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据，比二叉树效率高不少。&lt;/li&gt;
&lt;li&gt;红黑树：树的高度随着数据量增加而增加，I/O 代价高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-16-联合索引是什么？为什么需要注意联合索引中的顺序？&#34;&gt;4.16 联合索引是什么？为什么需要注意联合索引中的顺序？&lt;/h3&gt;
&lt;p&gt;MySQL 可以&lt;strong&gt;使用多个字段同时建立一个索引&lt;/strong&gt;，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。具体原因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL 使用索引时需要索引有序，假设现在建立了 &lt;code&gt;name, age, school&lt;/code&gt; 的联合索引，那么索引的排序为：先按照 &lt;code&gt;name&lt;/code&gt; 排序，如果 &lt;code&gt;name&lt;/code&gt; 相同，则按照 &lt;code&gt;age&lt;/code&gt; 排序，如果 &lt;code&gt;age&lt;/code&gt; 的值也相等，则按照 &lt;code&gt;school&lt;/code&gt; 进行排序。&lt;/li&gt;
&lt;li&gt;当进行查询时，此时索引仅仅按照 &lt;code&gt;name&lt;/code&gt; 严格有序，因此必须首先使用 &lt;code&gt;name&lt;/code&gt; 字段进行&lt;strong&gt;等值查询&lt;/strong&gt;，之后对于匹配到的列而言，其按照 &lt;code&gt;age&lt;/code&gt; 字段严格有序，此时可以使用 &lt;code&gt;age&lt;/code&gt; 字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，&lt;strong&gt;将查询需求频繁或者字段选择性高（区分度大）的列放在前面&lt;/strong&gt;。此外可以根据特例的查询或者表结构进行单独的调整。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-17-索引失效的情况有哪些？&#34;&gt;4.17 索引失效的情况有哪些？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当我们使用左或者左右模糊匹配的时候，也就是 &lt;code&gt;LIKE %xx&lt;/code&gt; 或者 &lt;code&gt;LIKE %xx%&lt;/code&gt; 这两种方式都会造成索引失效。&lt;/li&gt;
&lt;li&gt;当我们在查询条件中对索引列使用函数，就会导致索引失效。&lt;/li&gt;
&lt;li&gt;当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。&lt;/li&gt;
&lt;li&gt;MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 &lt;code&gt;CAST&lt;/code&gt; 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。&lt;/li&gt;
&lt;li&gt;联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;WHERE&lt;/code&gt; 子句中，如果在 &lt;code&gt;OR&lt;/code&gt; 前的条件列是索引列，而在 &lt;code&gt;OR&lt;/code&gt; 后的条件列不是索引列，那么索引会失效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-18-MySQL-的最左前缀原则是什么？&#34;&gt;4.18 MySQL 的最左前缀原则是什么？&lt;/h3&gt;
&lt;p&gt;最左前缀原则就是&lt;strong&gt;最左优先&lt;/strong&gt;，当使用联合索引时，MySQL 只能从索引的最左列开始并向右&lt;strong&gt;连续&lt;/strong&gt;使用索引列，&lt;strong&gt;不能跳过中间列&lt;/strong&gt;，如果查询条件不包含联合索引的最左列，或中间出现断裂，则索引会部分失效（甚至完全失效）。此外如果某列使用了范围查询（&lt;code&gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;&lt;/code&gt;、&lt;code&gt;BETWEEN&lt;/code&gt;、&lt;code&gt;LIKE &#39;%xx&#39;&lt;/code&gt;），其右侧所有列的索引失效。&lt;/p&gt;
&lt;p&gt;例如我们有以下表结构：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;CREATE&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;TABLE&lt;/span&gt; users (&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    id &lt;span class=&#34;type&#34;&gt;INT&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;PRIMARY&lt;/span&gt; KEY,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    name &lt;span class=&#34;type&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;50&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    age &lt;span class=&#34;type&#34;&gt;INT&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    city &lt;span class=&#34;type&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;50&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    INDEX idx_name_age_city (name, age, city)  &lt;span class=&#34;comment&#34;&gt;-- 联合索引&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过几个例子来看看如何满足最左前缀原则的条件：&lt;/p&gt;
&lt;figure class=&#34;highlight sql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- 有效：使用了索引的前两列（name + age）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; users &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; name &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;Bob&amp;#x27;&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;AND&lt;/span&gt; age &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;30&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- 失效：未使用最左列 name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; users &lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; age &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;25&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- 失效：跳过了 age 列（索引断裂）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; users &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; name &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;David&amp;#x27;&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;AND&lt;/span&gt; city &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;Guangzhou&amp;#x27;&lt;/span&gt;;  &lt;span class=&#34;comment&#34;&gt;-- age 列缺失&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- 部分有效：name 生效，age 范围查询导致 city 失效&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; users &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; name &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;Eva&amp;#x27;&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;AND&lt;/span&gt; age &lt;span class=&#34;operator&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;20&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;AND&lt;/span&gt; city &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;Shenzhen&amp;#x27;&lt;/span&gt;;  &lt;span class=&#34;comment&#34;&gt;-- city 无法用索引&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- 有效：查询列被索引覆盖（即使跳过 age）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; name, city &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; users  &lt;span class=&#34;comment&#34;&gt;-- 所有列都在索引中，触发覆盖索引&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; name &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;Grace&amp;#x27;&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;AND&lt;/span&gt; city &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;Wuhan&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- 有效：排序遵循索引顺序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; users &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; name &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;Henry&amp;#x27;&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;ORDER&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;BY&lt;/span&gt; age;  &lt;span class=&#34;comment&#34;&gt;-- 索引第二列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;-- 失效：排序未从最左开始&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;FROM&lt;/span&gt; users &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;WHERE&lt;/span&gt; name &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;#x27;Ivy&amp;#x27;&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;ORDER&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;BY&lt;/span&gt; city;  &lt;span class=&#34;comment&#34;&gt;-- 跳过了 age 列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-19-前缀索引是什么？&#34;&gt;4.19 前缀索引是什么？&lt;/h3&gt;
&lt;p&gt;因为可能我们索引的字段非常长，这既占内存空间，也不利于维护。所以我们就想，如果只把很长字段的前面的公共部分作为一个索引，就会产生超级加倍的效果。但是我们需要注意，&lt;code&gt;ORDER BY&lt;/code&gt; 不支持前缀索引。&lt;/p&gt;
&lt;p&gt;创建前缀索引的流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先计算完整列的选择性：&lt;code&gt;SELECT COUNT(DISTINCT col_1)/COUNT(1) FROM table_1&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;再计算不同前缀长度的选择性：&lt;code&gt;SELECT COUNT(DISTINCT LEFT(col_1, 4))/COUNT(1) FROM table_1&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;找到最优长度之后，创建前缀索引：&lt;code&gt;CREATE INDEX idx_front ON table_1 (col_1(4))&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-20-怎么决定建立哪些索引？&#34;&gt;4.20 怎么决定建立哪些索引？&lt;/h3&gt;
&lt;p&gt;（1）什么时候适用索引？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字段有唯一性限制的，比如商品编码。&lt;/li&gt;
&lt;li&gt;经常用于 &lt;code&gt;WHERE&lt;/code&gt; 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。&lt;/li&gt;
&lt;li&gt;经常用于 &lt;code&gt;GROUP BY&lt;/code&gt; 和 &lt;code&gt;ORDER BY&lt;/code&gt; 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+ 树中的记录都是排序好的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）什么时候不需要创建索引？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WHERE&lt;/code&gt; 条件，&lt;code&gt;GROUP BY&lt;/code&gt;，&lt;code&gt;ORDER BY&lt;/code&gt; 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。&lt;/li&gt;
&lt;li&gt;字段中存在大量重复数据，不需要创建索引，比如性别字段只有男/女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。&lt;/li&gt;
&lt;li&gt;表数据太少的时候，不需要创建索引。&lt;/li&gt;
&lt;li&gt;经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，B+ 树为了维护索引有序性会造成更多时间开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-存储引擎&#34;&gt;5. 存储引擎&lt;/h2&gt;
&lt;h3 id=&#34;5-1-MySQL-执行查询的过程是什么？&#34;&gt;5.1 MySQL 执行查询的过程是什么？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;客户端通过 TCP 连接发送连接请求到 MySQL 连接器，连接器会对该请求进行权限验证及连接资源分配，建立并管理连接。&lt;/li&gt;
&lt;li&gt;查缓存：当判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用 SQL 语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。MySQL 8.0 已删除该模块。&lt;/li&gt;
&lt;li&gt;解析 SQL：通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型。&lt;/li&gt;
&lt;li&gt;执行 SQL：执行 SQL 共有三个阶段：
&lt;ul&gt;
&lt;li&gt;预处理阶段：检查表或字段是否存在，将 &lt;code&gt;SELECT *&lt;/code&gt; 中的 &lt;code&gt;*&lt;/code&gt; 符号扩展为表上的所有列；&lt;/li&gt;
&lt;li&gt;优化阶段：基于查询成本的考虑，选择查询成本最小的执行计划；&lt;/li&gt;
&lt;li&gt;执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;更新语句执行会复杂一点，需要检查表是否有排它锁，写 &lt;code&gt;binlog&lt;/code&gt;、刷盘、是否执行 &lt;code&gt;commit&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;5-2-MySQL-支持哪些存储引擎？为什么-InnoDB-是默认引擎？&#34;&gt;5.2 MySQL 支持哪些存储引擎？为什么 InnoDB 是默认引擎？&lt;/h3&gt;
&lt;p&gt;MySQL 支持多种存储引擎，比如 InnoDB、MyISAM、Memory、Archive 等：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB：InnoDB 是 MySQL 的默认存储引擎，具有 ACID 事务支持、行级锁、外键约束等特性。它适用于高并发的读写操作，支持较好的数据完整性和并发控制。&lt;/li&gt;
&lt;li&gt;MyISAM：MyISAM 是 MySQL 的另一种常见的存储引擎，具有较低的存储空间和内存消耗，适用于大量读操作的场景。然而，MyISAM 不支持事务、行级锁和外键约束，因此在并发写入和数据完整性方面有一定的限制。&lt;/li&gt;
&lt;li&gt;Memory：Memory 引擎将数据存储在内存中，适用于对性能要求较高的读操作，但是在服务器重启或崩溃时数据会丢失。它不支持事务、行级锁和外键约束。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在大多数的情况下，直接选择使用 InnoDB 引擎都是最合适的，因为 InnoDB 引擎在事务支持、并发性能、崩溃恢复等方面具有优势，所以 InnoDB 也是 MySQL 的默认存储引擎。&lt;/p&gt;
&lt;p&gt;MyISAM 和 InnoDB 的区别有哪些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB 支持&lt;strong&gt;事务&lt;/strong&gt;，可以进行 ACID（原子性、一致性、隔离性、持久性）属性的操作，MyISAM 不支持。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的&lt;strong&gt;重要原因&lt;/strong&gt;之一。&lt;/li&gt;
&lt;li&gt;MyISAM 只支持&lt;strong&gt;表级锁&lt;/strong&gt;（table-level locking），锁的粒度比较大，一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此&lt;strong&gt;并发访问受限&lt;/strong&gt;；InnoDB 支持&lt;strong&gt;行级锁&lt;/strong&gt;（row-level locking）和表级锁，默认为行级锁，可以提供更好的并发性能。&lt;/li&gt;
&lt;li&gt;InnoDB 引引擎通过 &lt;code&gt;redolog&lt;/code&gt; 日志实现了崩溃恢复，可以在数据库发生异常情况（如断电）时，通过日志文件进行恢复，保证数据的持久性和一致性，MyISAM 是不支持崩溃恢复的。&lt;/li&gt;
&lt;li&gt;InnoDB 支持&lt;strong&gt;外键&lt;/strong&gt;，MyISAM 不支持。&lt;/li&gt;
&lt;li&gt;InnoDB 是&lt;strong&gt;聚簇索引&lt;/strong&gt;，数据文件是和索引绑在一起的，文件存放在主键索引的叶子节点上，必须要有主键，通过主键索引效率很高，但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据，因此主键不应该过大，因为主键太大，其他索引也都会很大；MyISAM 是&lt;strong&gt;非聚簇索引&lt;/strong&gt;，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。&lt;/li&gt;
&lt;li&gt;InnoDB 不支持&lt;strong&gt;全文索引&lt;/strong&gt;，MyISAM 支持全文索引，查询效率上 MyISAM 更高。&lt;/li&gt;
&lt;li&gt;InnoDB 不保存表的具体行数，执行 &lt;code&gt;SELECT COUNT(*) FROM &amp;lt;table&amp;gt;&lt;/code&gt; 时需要全表扫描，MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="Interview" />
        <updated>2022-12-04T09:13:00.000Z</updated>
    </entry>
    <entry>
        <id>https://asanosaki.github.io/posts/54431.html</id>
        <title>计算机网络面试题总结</title>
        <link rel="alternate" href="https://asanosaki.github.io/posts/54431.html"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;计算机网络常见面试题总结，涉及网络模型、应用层、传输层等内容，文章将不断更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;h2 id=&#34;1-计算机网络模型&#34;&gt;1. 计算机网络模型&lt;/h2&gt;
&lt;p&gt;计算机网络体系可以大致分为三种：OSI 七层模型、TCP/IP 四层模型和五层模型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OSI 七层模型：大而全，但是比较复杂，提出的也只是概念理论上的分层，并没有提供具体的实现方案。&lt;/li&gt;
&lt;li&gt;TCP/IP 四层模型：是由实际应用发展总结出来的，从实质上讲，TCP/IP 只有最上面两层，最下面一层没有什么具体内容，TCP/IP 参考模型没有真正描述这一层的实现。&lt;/li&gt;
&lt;li&gt;TCP/IP 五层模型：五层模型只出现在计算机网络教学过程中，这是对七层模型和四层模型的一个折中，既简洁又能将概念阐述清楚。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;七层网络体系结构各层的主要功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用层：为应用程序提供交互服务，负责给应用程序提供统一的接口。在互联网中的应用层协议有很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等。&lt;/li&gt;
&lt;li&gt;表示层：主要负责数据格式的转换，如加密解密、转换翻译、压缩解压缩等。&lt;/li&gt;
&lt;li&gt;会话层：负责在网络中的两节点之间建立、维持和终止通信，如服务器验证用户登录便是由会话层完成的。&lt;/li&gt;
&lt;li&gt;运输层：有时也译为传输层，向主机进程提供通用的数据传输服务，负责端到端的数据传输。该层主要有以下两种协议：
&lt;ul&gt;
&lt;li&gt;TCP：提供面向连接的、可靠的数据传输服务。&lt;/li&gt;
&lt;li&gt;UDP：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网络层：负责数据的路由、转发、分片，选择合适的路由和交换结点，确保数据及时传送。主要包括 IP 协议。&lt;/li&gt;
&lt;li&gt;数据链路层：数据链路层通常简称为链路层。负责数据的封帧和差错检测以及 MAC 寻址，将网络层传下来的 IP 数据包组装成帧，并在相邻节点的链路上传送帧。&lt;/li&gt;
&lt;li&gt;物理层：负责在物理线路中传输数据帧，实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TCP/IP 网络通常是由上到下分成 4 层，分别是&lt;strong&gt;应用层&lt;/strong&gt;（对应 OSI 的应用层、表示层、会话层），&lt;strong&gt;传输层&lt;/strong&gt;（对应 OSI 的传输层），&lt;strong&gt;网络层&lt;/strong&gt;（对应 OSI 的网络层）和&lt;strong&gt;网络接口层&lt;/strong&gt;（对应 OSI 的数据链路层、物理层）。&lt;/p&gt;
&lt;h2 id=&#34;2-应用层&#34;&gt;2. 应用层&lt;/h2&gt;
&lt;h3 id=&#34;2-1-HTTP-报文有哪些部分？&#34;&gt;2.1 HTTP 报文有哪些部分？&lt;/h3&gt;
&lt;p&gt;HTTP 报文分为请求报文和响应报文：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求报文
&lt;ul&gt;
&lt;li&gt;请求行：包含请求方法、请求目标（URL 或 URI）和 HTTP 协议版本。&lt;/li&gt;
&lt;li&gt;请求头部：包含关于请求的附加信息，如 Host、User-Agent、Content-Type 等。&lt;/li&gt;
&lt;li&gt;空行：请求头部和请求体之间用空行分隔。&lt;/li&gt;
&lt;li&gt;请求体：可选，包含请求的数据，通常用于 POST 请求等需要传输数据的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;响应报文
&lt;ul&gt;
&lt;li&gt;状态行：包含 HTTP 协议版本、状态码和状态信息。&lt;/li&gt;
&lt;li&gt;响应头部：包含关于响应的附加信息，如 Content-Type、Content-Length 等。&lt;/li&gt;
&lt;li&gt;空行：响应头部和响应体之间用空行分隔。&lt;/li&gt;
&lt;li&gt;响应体：包含响应的数据，通常是服务器返回的 HTML、JSON 等内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-2-HTTP-常见的状态码有哪些？&#34;&gt;2.2 HTTP 常见的状态码有哪些？&lt;/h3&gt;
&lt;p&gt;常见状态码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;200：服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。&lt;/li&gt;
&lt;li&gt;301：请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置（永久移动）。&lt;/li&gt;
&lt;li&gt;302：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求（临时移动）。&lt;/li&gt;
&lt;li&gt;400：客户端请求有语法错误，不能被服务器所理解。&lt;/li&gt;
&lt;li&gt;403：服务器收到请求，但是拒绝提供服务。&lt;/li&gt;
&lt;li&gt;404：服务器找不到请求的网页。&lt;/li&gt;
&lt;li&gt;405：请求的方法类型不支持。&lt;/li&gt;
&lt;li&gt;500：服务器内部遇到错误，无法完成请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;状态码开头代表类型：&lt;/p&gt;
&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;&lt;/th&gt;
            &lt;th&gt;类别&lt;/th&gt;
            &lt;th&gt;原因短语&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;1XX&lt;/td&gt;
            &lt;td&gt;Informational（信息性状态码）&lt;/td&gt;
            &lt;td&gt;接收的请求正在处理&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;2XX&lt;/td&gt;
            &lt;td&gt;Success（成功状态码）&lt;/td&gt;
            &lt;td&gt;请求正常处理完毕&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;3XX&lt;/td&gt;
            &lt;td&gt;Redirection（重定向状态码）&lt;/td&gt;
            &lt;td&gt;需要进行附加操作以完成请求&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;4XX&lt;/td&gt;
            &lt;td&gt;Client Error（客户端错误状态码）&lt;/td&gt;
            &lt;td&gt;服务器无法处理请求&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;5XX&lt;/td&gt;
            &lt;td&gt;Server Error（服务器错误状态码）&lt;/td&gt;
            &lt;td&gt;服务器处理请求出错&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;2-3-状态码-301-和-302-的区别是什么？&#34;&gt;2.3 状态码 301 和 302 的区别是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;共同点：301 和 302 状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的 URL 地址，这个地址可以从响应的 Location 首部中获取（用户看到的效果就是他输入的地址 A 瞬间变成了另一个地址 B）。&lt;/li&gt;
&lt;li&gt;不同点：301 表示&lt;strong&gt;永久重定向&lt;/strong&gt;，即旧地址 A 的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。302 表示旧地址 A 的资源还在（仍然可以访问），这个重定向只是临时地从旧地址 A 跳转到地址 B，搜索引擎会抓取新的内容而保存旧的网址。SEO 中 302 好于 301。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重定向原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网站调整（如改变网页目录结构）。&lt;/li&gt;
&lt;li&gt;网页被移到一个新地址。&lt;/li&gt;
&lt;li&gt;网页扩展名改变（如应用需要把 &lt;code&gt;.php&lt;/code&gt; 改成 &lt;code&gt;.html&lt;/code&gt; 或 &lt;code&gt;.shtml&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-4-状态码-502-和-504-的区别是什么？&#34;&gt;2.4 状态码 502 和 504 的区别是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到&lt;strong&gt;无效&lt;/strong&gt;的响应。例如假设 Nginx 是代理服务器，收到客户端的请求后，将请求转发到后端服务器（Tomcat 等），当 Nginx 收到了无效的响应时，就返回 502。&lt;/li&gt;
&lt;li&gt;504 Gateway Time-out：作为网关或者代理工作的服务器尝试执行请求时，&lt;strong&gt;未能及时&lt;/strong&gt;从上游服务器收到响应。例如当 Nginx 超过自己配置的超时时间，还没有收到请求时，就返回 504。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-5-HTTP-常用的请求方式有哪些？&#34;&gt;2.5 HTTP 常用的请求方式有哪些？&lt;/h3&gt;
&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;方法&lt;/th&gt;
            &lt;th&gt;作用&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;GET&lt;/td&gt;
            &lt;td&gt;请求获取指定资源，通常用于获取数据&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;POST&lt;/td&gt;
            &lt;td&gt;向服务器提交数据，通常用于提交表单数据或进行资源的创建&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;PUT&lt;/td&gt;
            &lt;td&gt;向服务器更新指定资源，通常用于更新已存在的资源&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;DELETE&lt;/td&gt;
            &lt;td&gt;请求服务器删除指定资源&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;HEAD&lt;/td&gt;
            &lt;td&gt;类似于 GET 请求，但只返回资源的头部信息，用于获取资源的元数据而不获取实际内容&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;PATCH&lt;/td&gt;
            &lt;td&gt;对资源进行部分修改&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OPTIONS&lt;/td&gt;
            &lt;td&gt;查询指定的 URL 支持的方法&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;CONNECT&lt;/td&gt;
            &lt;td&gt;要求用隧道协议连接代理&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;TRACE&lt;/td&gt;
            &lt;td&gt;服务器会将通信路径返回给客户端&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;为了方便记忆，可以将 PUT、DELETE、POST、GET 理解为客户端对服务端的增删改查：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PUT：上传文件，向服务器添加数据。&lt;/li&gt;
&lt;li&gt;DELETE：删除文件。&lt;/li&gt;
&lt;li&gt;POST：传输数据，向服务器提交数据，对服务器数据进行更新。&lt;/li&gt;
&lt;li&gt;GET：获取资源，查询服务器资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-6-GET-请求和-POST-请求的区别？&#34;&gt;2.6 GET 请求和 POST 请求的区别？&lt;/h3&gt;
&lt;p&gt;使用上的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用：GET 用于获取资源，而 POST 用于传输实体。&lt;/li&gt;
&lt;li&gt;参数：GET 使用 URL 或 Cookie 传参，而 POST 将数据放在 Request Body 中，这个是因为 HTTP 协议用法的约定。&lt;/li&gt;
&lt;li&gt;缓存：GET 请求会被浏览器主动缓存，而 POST 一般不会，除非手动设置。&lt;/li&gt;
&lt;li&gt;请求长度：GET 方式提交的数据有长度限制，基本为 2kb，而 POST 的数据则可以非常大，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。&lt;/li&gt;
&lt;li&gt;安全性：POST 比 GET 安全，因为数据在地址栏上不可见，而 GET 的参数直接暴露在 URL 上。这个说法没毛病，但依然不是 GET 和 POST 本身的区别。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本质区别：GET 和 POST 最大的区别主要是 GET 请求是&lt;strong&gt;幂等性&lt;/strong&gt;的，POST 请求不是。幂等性是指一次和多次请求某一个资源应该具有同样的副作用，简单来说意味着对同一 URL 的多个请求应该返回同样的结果。GET 方法是&lt;strong&gt;只读&lt;/strong&gt;操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的，所以可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如 Nginx），而且在浏览器中 GET 请求可以保存为书签。&lt;/p&gt;
&lt;h3 id=&#34;2-7-解释一下-HTTP-长连接和短连接？&#34;&gt;2.7 解释一下 HTTP 长连接和短连接？&lt;/h3&gt;
&lt;p&gt;在 &lt;strong&gt;HTTP/1.0&lt;/strong&gt; 中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次 HTTP 操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源，如 JavaScript 文件、图像文件、CSS 文件等，当浏览器每遇到这样一个 Web 资源，就会建立一个 HTTP 会话。&lt;/p&gt;
&lt;p&gt;但从 &lt;strong&gt;HTTP/1.1&lt;/strong&gt; 起，默认使用长连接，用以保持连接特性。具体地说，Keep-Alive 实现了长连接功能，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，避免了连接建立和释放的开销，使用长连接的 HTTP 协议，会在响应头加入这行代码：&lt;code&gt;Connection: Keep-Alive&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（例如 Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;2-8-HTTP1-0-和-HTTP1-1-的区别是什么？&#34;&gt;2.8 HTTP1.0 和 HTTP1.1 的区别是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;长连接：HTTP1.1 支持长连接（Persistent Connection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 &lt;code&gt;Connection: Keep-Alive&lt;/code&gt;，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。&lt;/li&gt;
&lt;li&gt;缓存处理：在 HTTP1.0 中主要使用 &lt;code&gt;header&lt;/code&gt; 里的 &lt;code&gt;If-Modified-Since, Expires&lt;/code&gt; 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略，可供选择的缓存头来控制缓存策略。&lt;/li&gt;
&lt;li&gt;带宽优化及网络连接的使用：HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 &lt;code&gt;range&lt;/code&gt; 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。&lt;/li&gt;
&lt;li&gt;错误通知的管理：在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突，410（Gone）表示服务器上的某个资源被永久性的删除。&lt;/li&gt;
&lt;li&gt;Host 头处理：在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（Hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-9-HTTP1-1-和-HTTP2-0-的区别是什么？&#34;&gt;2.9 HTTP1.1 和 HTTP2.0 的区别是什么？&lt;/h3&gt;
&lt;p&gt;HTTP2.0 相比 HTTP1.1 支持的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新的二进制格式：HTTP1.1 的解析是基于文本的。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。&lt;/li&gt;
&lt;li&gt;多路复用：即连接共享，每一个 Request 都是用作连接共享机制的。一个 Request 对应一个 ID，这样一个连接上可以有多个 Request，每个连接的 Request 可以随机的混杂在一起，接收方可以根据 Request 的 ID 将 Request 再归属到各自不同的服务端请求里面。&lt;/li&gt;
&lt;li&gt;头部压缩：HTTP1.1 的头部（Header）带有大量信息，而且每次都要重复发送。HTTP2.0 使用 Encoder 来减少需要传输的 Header 大小，通讯双方各自缓存一份 Header Fields 表，既避免了重复 Header 的传输，又减小了需要传输的大小。&lt;/li&gt;
&lt;li&gt;服务端推送：服务器除了对最初请求的响应外，服务器还可以额外地向客户端推送资源，而无需客户端明确的请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-10-HTTP-和-HTTPS-的区别？&#34;&gt;2.10 HTTP 和 HTTPS 的区别？&lt;/h3&gt;
&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;&lt;/th&gt;
            &lt;th&gt;HTTP&lt;/th&gt;
            &lt;th&gt;HTTPS&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;端口&lt;/td&gt;
            &lt;td&gt;80&lt;/td&gt;
            &lt;td&gt;443&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;安全性&lt;/td&gt;
            &lt;td&gt;明文传输无加密，安全性较差&lt;/td&gt;
            &lt;td&gt;在 TCP 和 HTTP 之间加入了 SSL/TLS 安全协议，有加密机制，安全性较高&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;资源消耗&lt;/td&gt;
            &lt;td&gt;较少&lt;/td&gt;
            &lt;td&gt;由于加密处理，资源消耗更多&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;是否需要证书&lt;/td&gt;
            &lt;td&gt;不需要&lt;/td&gt;
            &lt;td&gt;需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;协议&lt;/td&gt;
            &lt;td&gt;运行在 TCP 协议之上&lt;/td&gt;
            &lt;td&gt;运行在 SSL 协议之上，SSL 运行在 TCP 协议之上&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;2-11-HTTPS-的优缺点？&#34;&gt;2.11 HTTPS 的优缺点？&lt;/h3&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全性：
&lt;ul&gt;
&lt;li&gt;使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。&lt;/li&gt;
&lt;li&gt;HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。&lt;/li&gt;
&lt;li&gt;HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SEO 方面：谷歌曾在 2014 年调整搜索引擎算法，并称比起同等 HTTP 网站，采用 HTTPS 加密的网站在搜索结果中的排名将会更高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。&lt;/li&gt;
&lt;li&gt;HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。&lt;/li&gt;
&lt;li&gt;在现有的证书机制下，中间人攻击依然有可能发生。&lt;/li&gt;
&lt;li&gt;HTTPS 需要更多的服务器资源，也会导致成本的升高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-12-HTTPS-的原理-握手过程是什么？&#34;&gt;2.12 HTTPS 的原理/握手过程是什么？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;第一次握手&lt;/strong&gt;：客户端首先生成第一个随机数 &lt;code&gt;Client Random&lt;/code&gt;，然后请求 HTTPS 网址，例如：&lt;code&gt;https://www.baidu.com&lt;/code&gt;，然后连接到服务器的 443 端口（HTTPS 默认端口，类似于 HTTP 的 80 端口）。&lt;/li&gt;
&lt;li&gt;采用 HTTPS 协议的服务器必须要有一套数字 CA（Certification Authority）证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二次握手&lt;/strong&gt;：服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等，此外还向客户端发送第二个随机数 &lt;code&gt;Server Random&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥 A。然后客户端还会继续生成第三个随机码 &lt;code&gt;Pre-master Key&lt;/code&gt;，并使用公钥 A 将其加密。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三次握手&lt;/strong&gt;：客户端把加密后的随机码 &lt;code&gt;Pre-master Key&lt;/code&gt; 发送给服务器，作为后面对称加密的密钥。&lt;/li&gt;
&lt;li&gt;服务器在收到随机码 &lt;code&gt;Pre-master Key&lt;/code&gt; 之后会使用私钥 B 将其解密，现在客户端和服务器都拥有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的&lt;strong&gt;会话秘钥&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第四次握手&lt;/strong&gt;：服务器向客户端发送最后的信息，表示随后的信息都将用会话秘钥加密通信，且服务器的握手阶段已经结束，同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。&lt;/li&gt;
&lt;li&gt;经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-13-介绍一下-DNS-及其工作流程是什么？&#34;&gt;2.13 介绍一下 DNS 及其工作流程是什么？&lt;/h3&gt;
&lt;p&gt;DNS 的全称是 Domain Name System（域名系统），它是互联网中用于将域名转换为对应 IP 地址的&lt;strong&gt;分布式数据库系统&lt;/strong&gt;，默认端口号为 53。DNS 扮演着重要的角色，使得人们可以通过易记的域名访问互联网资源，而无需记住复杂的 IP 地址。&lt;/p&gt;
&lt;p&gt;DNS 基于 UDP 协议实现，因为基于 UDP 实现 DNS 能够提供低延迟、简单快速、轻量级的特性，更适合 DNS 这种需要快速响应的域名解析服务。尽管 UDP 存在丢包和数据包损坏的风险，但在 DNS 的设计中，这些风险是可以被容忍的，DNS 使用了一些机制来提高可靠性，例如查询超时重传、请求重试、缓存等，以确保数据传输的可靠性和正确性。&lt;/p&gt;
&lt;p&gt;域名解析的工作流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端首先会发出一个 DNS 请求，问 &lt;code&gt;www.example.com&lt;/code&gt; 的 IP 是啥，并发给&lt;strong&gt;本地 DNS 服务器&lt;/strong&gt;（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。&lt;/li&gt;
&lt;li&gt;本地 DNS 服务器收到客户端的请求后，如果缓存里的表格能找到 &lt;code&gt;www.example.com&lt;/code&gt;，则它直接返回该域名对应的 IP 地址。如果没有，本地 DNS 会去问它的&lt;strong&gt;根域名服务器&lt;/strong&gt;，根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。&lt;/li&gt;
&lt;li&gt;根 DNS 收到来自本地 DNS 的请求后，发现后缀是 &lt;code&gt;.com&lt;/code&gt;，于是将 &lt;code&gt;.com&lt;/code&gt; &lt;strong&gt;顶级域 DNS 服务器&lt;/strong&gt;地址返回给本地 DNS。&lt;/li&gt;
&lt;li&gt;本地 DNS 收到顶级域 DNS 服务器的地址后，继续向顶级域 DNS 服务器发起请求询问 &lt;code&gt;www.example.com&lt;/code&gt; 的地址。&lt;/li&gt;
&lt;li&gt;顶级域 DNS 服务器发现后缀是 &lt;code&gt;.example.com&lt;/code&gt;，于是将负责 &lt;code&gt;.example.com&lt;/code&gt; 区域的&lt;strong&gt;权威 DNS 服务器&lt;/strong&gt;地址返回给本地 DNS。&lt;/li&gt;
&lt;li&gt;本地 DNS 继续转向权威 DNS 服务器进行询问，权威 DNS 服务器查询后将对应的 IP 地址 &lt;code&gt;X.X.X.X&lt;/code&gt; 告诉给本地 DNS。&lt;/li&gt;
&lt;li&gt;本地 DNS 最后再将 IP 地址返回客户端，客户端和目标 IP 建立连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-14-HTTP-是无状态的吗？&#34;&gt;2.14 HTTP 是无状态的吗？&lt;/h3&gt;
&lt;p&gt;HTTP 是无状态的，这意味着每个请求都是独立的，服务器不会在多个请求之间保留关于客户端状态的信息，即在每个 HTTP 请求中，服务器不会记住之前的请求或会话状态，因此每个请求都是相互独立的。&lt;/p&gt;
&lt;p&gt;虽然 HTTP 本身是无状态的，但可以通过一些机制来实现状态保持，其中最常见的方式是使用 Cookie 和 Session 来跟踪用户状态。通过在客户端存储会话信息或状态信息，服务器可以识别和跟踪特定用户的状态，以提供一定程度的状态保持功能。&lt;/p&gt;
&lt;h3 id=&#34;2-15-什么是-Cookie-和-Session？&#34;&gt;2.15 什么是 Cookie 和 Session？&lt;/h3&gt;
&lt;p&gt;HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。&lt;/p&gt;
&lt;p&gt;Cookie 主要用于以下三个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）。&lt;/li&gt;
&lt;li&gt;个性化设置（如用户自定义设置、主题等）。&lt;/li&gt;
&lt;li&gt;浏览器行为跟踪（如跟踪分析用户行为等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。&lt;/p&gt;
&lt;h3 id=&#34;2-16-Cookie-和-Session-是如何配合的呢？&#34;&gt;2.16 Cookie 和 Session 是如何配合的呢？&lt;/h3&gt;
&lt;p&gt;用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。&lt;/p&gt;
&lt;p&gt;当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在则自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。&lt;/p&gt;
&lt;p&gt;根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。&lt;/p&gt;
&lt;h3 id=&#34;2-17-Cookie-和-Session-有什么区别？&#34;&gt;2.17 Cookie 和 Session 有什么区别？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;存储位置：Cookie 保存在客户端（浏览器），当浏览器向服务器发送请求时，会自动附带Cookie中的数据。Session 保存在服务器端，服务器为每个用户分配一个唯一的 Session ID，这个 ID 通常通过 Cookie 或 URL 重写的方式发送给客户端，客户端后续的请求会带上这个 Session ID，服务器根据 ID 查找对应的 Session 数据。&lt;/li&gt;
&lt;li&gt;存取方式：Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserID 等。&lt;/li&gt;
&lt;li&gt;生命周期：Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。&lt;/li&gt;
&lt;li&gt;安全性：Cookie 存储在客户端，容易受到 XSS（跨站脚本攻击）的威胁，可以通过设置 HttpOnly 属性来防止 JavaScript 访问，减少 XSS 攻击的风险，但仍然可能受到 CSRF（跨站请求伪造）的攻击；Session 存储在服务端，安全性相对 Cookie 要好一些，但仍然需要防范 Session 劫持（获取他人的 Session ID）和会话固定攻击。&lt;/li&gt;
&lt;li&gt;存储大小：单个 Cookie 保存的数据不能超过 4KB，且大多数浏览器对每个域名的总 Cookie 数量也有限制。Session 可存储数据远高于 Cookie，理论上不受数据大小的限制，主要受限于服务器的内存大小。&lt;/li&gt;
&lt;li&gt;性能：使用 Cookie 时，因为数据随每个请求发送到服务器，可能会影响网络传输效率，尤其是在 Cookie 数据较大时。使用 Session 时，因为数据存储在服务器端，每次请求都需要查询服务器上的 Session 数据，这可能会增加服务器的负载，特别是在高并发场景下。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-18-Local-Storage-和-Cookie-有什么区别？&#34;&gt;2.18 Local Storage 和 Cookie 有什么区别？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;存储容量：Cookie 的存储容量通常较小，每个 Cookie 的大小一般不能超过 4KB。LocalStorage 的存储容量通常较大，一般限制在几 MB 左右。&lt;/li&gt;
&lt;li&gt;数据发送：Cookie 在每次 HTTP 请求中都会自动发送到服务器，这使得 Cookie 适合用于在客户端和服务器之间传递数据。LocalStorage 的数据不会自动发送到服务器，它仅在浏览器端存储数据，因此 Local Storage 适合用于在同一域名下的不同页面之间共享数据。&lt;/li&gt;
&lt;li&gt;生命周期：Cookie 可以设置一个过期时间，使得数据在指定时间后自动过期。LocalStorage 的数据将永久存储在浏览器中，除非通过 JavaScript 代码手动删除。&lt;/li&gt;
&lt;li&gt;安全性：Cookie 的安全性较低，因为 Cookie 在每次 HTTP 请求中都会自动发送到服务器，存在被窃取或篡改的风险。LocalStorage 的数据仅在浏览器端存储，不会自动发送到服务器，相对而言更安全一些。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-19-前端是如何存储-JWT-的？&#34;&gt;2.19 前端是如何存储 JWT 的？&lt;/h3&gt;
&lt;p&gt;互联网服务离不开用户认证，JWT（JSON Web Token）是目前最流行的跨域认证解决方案，JWT 令牌由三个部分组成：头部（Header）、载荷（Payload）和签名（Signature）。其中，头部和载荷均为 JSON 格式，使用 Base64 编码进行序列化，而签名部分是对头部、载荷和密钥进行签名后的结果。&lt;/p&gt;
&lt;p&gt;传统的 Session 认证流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户向服务器发送用户名和密码。&lt;/li&gt;
&lt;li&gt;服务器验证通过后，在当前会话（Session）里面保存相关数据，比如用户角色、登录时间等等。&lt;/li&gt;
&lt;li&gt;服务器向用户返回一个 &lt;code&gt;session_id&lt;/code&gt;，写入用户的 Cookie。&lt;/li&gt;
&lt;li&gt;用户随后的每一次请求，都会通过 Cookie，将 &lt;code&gt;session_id&lt;/code&gt; 传回服务器。&lt;/li&gt;
&lt;li&gt;服务器收到 &lt;code&gt;session_id&lt;/code&gt;，找到前期保存的数据，由此得知用户的身份。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种模式的问题在于扩展性不好，如果是服务器集群，或者是跨域的服务导向架构，就要求 Session 数据共享，每台服务器都能够读取 Session。&lt;/p&gt;
&lt;p&gt;举例来说，A 网站和 B 网站是同一家公司的关联服务，现在要求用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？&lt;/p&gt;
&lt;p&gt;一种解决方案是 Session 数据持久化，写入数据库或别的持久层，各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大，另外如果持久层挂了，就会导致单点失败。&lt;/p&gt;
&lt;p&gt;另一种方案是服务器索性不保存 Session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。&lt;/p&gt;
&lt;p&gt;客户端收到服务器返回的 JWT，可以储存在 Local Storage 里面，也可以储存在 Cookie 里面，还可以存储在 Session Storage 里面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Local Storage
&lt;ul&gt;
&lt;li&gt;优点：Local Storage 提供了较大的存储空间（一般为 5MB），且不会随着 HTTP 请求一起发送到服务器，因此不会出现在 HTTP 缓存或日志中。&lt;/li&gt;
&lt;li&gt;缺点：存在 XSS（跨站脚本攻击）的风险，恶意脚本可以通过 JavaScript 访问到存储在 Local Storage 中的 JWT，从而盗取用户凭证。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Session Storage
&lt;ul&gt;
&lt;li&gt;优点：与 Local Storage 类似，但仅限于当前浏览器窗口或标签页，当窗口关闭后数据会被清除，这在一定程度上减少了数据泄露的风险。&lt;/li&gt;
&lt;li&gt;缺点：用户体验可能受影响，因为刷新页面或在新标签页打开相同应用时需要重新认证。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cookie
&lt;ul&gt;
&lt;li&gt;优点：可以设置 HttpOnly 标志来防止通过 JavaScript 访问，减少 XSS 攻击的风险；可以利用 Secure 标志确保仅通过 HTTPS 发送，增加安全性。&lt;/li&gt;
&lt;li&gt;缺点：大小限制较小（通常 4KB），并且每次 HTTP 请求都会携带 Cookie，可能影响性能；设置不当可能会受到 CSRF（跨站请求伪造）攻击。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-20-JWT-令牌和传统方式有什么区别？&#34;&gt;2.20 JWT 令牌和传统方式有什么区别？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;无状态性：JWT 是无状态的令牌，不需要在服务器端存储会话信息。相反，JWT 令牌中包含了所有必要的信息，如用户身份、权限等。这使得 JWT 在分布式系统中更加适用，可以方便地进行扩展和跨域访问。&lt;/li&gt;
&lt;li&gt;安全性：JWT 使用密钥对令牌进行签名，确保令牌的完整性和真实性，只有持有正确密钥的服务器才能对令牌进行验证和解析。这种方式比传统的基于会话和 Cookie 的验证更加安全，有效防止了 CSRF（跨站请求伪造）等攻击。&lt;/li&gt;
&lt;li&gt;跨域支持：JWT 令牌可以在不同域之间传递，适用于跨域访问的场景。通过在请求的头部或参数中携带 JWT 令牌，可以实现无需 Cookie 的跨域身份验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-21-JWT-令牌如果泄露了怎么解决？&#34;&gt;2.21 JWT 令牌如果泄露了怎么解决？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;及时失效令牌：当检测到 JWT 令牌泄露或存在风险时，可以立即将令牌标记为失效状态，服务器在接收到带有失效标记的令牌时，会拒绝对其进行任何操作，从而保护用户的身份和数据安全。&lt;/li&gt;
&lt;li&gt;刷新令牌：JWT 令牌通常具有一定的有效期，过期后需要重新获取新的令牌。当检测到令牌泄露时，可以主动刷新令牌，即重新生成一个新的令牌，并将旧令牌标记为失效状态。&lt;/li&gt;
&lt;li&gt;使用黑名单：服务器可以维护一个令牌的黑名单，将泄露的令牌添加到黑名单中。在接收到令牌时，先检查令牌是否在黑名单中，如果在则拒绝操作。这种方法需要服务器维护黑名单的状态，对性能有一定的影响，但可以有效地保护泄露的令牌不被滥用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-22-Nginx-有哪些负载均衡算法？&#34;&gt;2.22 Nginx 有哪些负载均衡算法？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;轮询：按照顺序依次将请求分配给后端服务器。这种算法最简单，但是也无法处理某个节点变慢或者客户端操作有连续性的情况。&lt;/li&gt;
&lt;li&gt;IP 哈希：根据客户端 IP 地址的哈希值来确定分配请求的后端服务器。适用于需要保持同一客户端的请求始终发送到同一台后端服务器的场景，如会话保持。&lt;/li&gt;
&lt;li&gt;URL 哈希：按访问的 URL 的哈希结果来分配请求，使每个 URL 定向到一台后端服务器，可以进一步提高后端缓存服务器的效率。&lt;/li&gt;
&lt;li&gt;最短响应时间：按照后端服务器的响应时间来分配请求，响应时间短的优先分配。适用于后端服务器性能不同的场景，能够将请求发送到响应时间快的服务器，实现负载均衡。&lt;/li&gt;
&lt;li&gt;加权轮询：按照后端服务器的权重来分配请求，权重越高的服务器获得更多的请求。适用于后端服务器性能不同的场景，可以根据服务器权重分配请求，提高高性能服务器的利用率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-传输层&#34;&gt;3. 传输层&lt;/h2&gt;
&lt;h3 id=&#34;3-1-TCP-和-UDP-的区别？&#34;&gt;3.1 TCP 和 UDP 的区别？&lt;/h3&gt;
&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;&lt;/th&gt;
            &lt;th&gt;TCP&lt;/th&gt;
            &lt;th&gt;UDP&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;是否连接&lt;/td&gt;
            &lt;td&gt;面向连接&lt;/td&gt;
            &lt;td&gt;无连接&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;是否可靠&lt;/td&gt;
            &lt;td&gt;可靠传输，使用流量控制和拥塞控制&lt;/td&gt;
            &lt;td&gt;不可靠传输，不使用流量控制和拥塞控制&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;是否有序&lt;/td&gt;
            &lt;td&gt;有序，消息在传输过程中可能会乱序，TCP 会重新排序&lt;/td&gt;
            &lt;td&gt;无序&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;传输速度&lt;/td&gt;
            &lt;td&gt;慢&lt;/td&gt;
            &lt;td&gt;快&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;连接对象个数&lt;/td&gt;
            &lt;td&gt;只能一对一通信&lt;/td&gt;
            &lt;td&gt;支持一对一、一对多、多对一和多对多交互通信&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;传输方式&lt;/td&gt;
            &lt;td&gt;面向字节流&lt;/td&gt;
            &lt;td&gt;面向报文&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;首部开销&lt;/td&gt;
            &lt;td&gt;首部开销大，最小 20 字节，最大 60 字节&lt;/td&gt;
            &lt;td&gt;首部开销小，仅 8 字节&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;适用场景&lt;/td&gt;
            &lt;td&gt;适用于要求可靠传输的应用，例如文件传输&lt;/td&gt;
            &lt;td&gt;适用于实时应用例如 IP 电话、视频会议、直播等&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;总结：TCP 用于在传输层有必要实现可靠传输的情况，UDP 用于对高速传输和实时性有较高要求的通信。TCP 和 UDP 应该根据应用目的按需使用。&lt;/p&gt;
&lt;h3 id=&#34;3-2-TCP-和-UDP-对应的应用场景是什么？&#34;&gt;3.2 TCP 和 UDP 对应的应用场景是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TCP 是面向连接的，能保证数据的可靠性交付，因此经常用于：
&lt;ul&gt;
&lt;li&gt;FTP 文件传输。&lt;/li&gt;
&lt;li&gt;HTTP/HTTPS。&lt;/li&gt;
&lt;li&gt;SMTP 简单邮件传输。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;UDP 是无连接的，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：
&lt;ul&gt;
&lt;li&gt;包总量较少的通信，如 DNS、SNMP 等。&lt;/li&gt;
&lt;li&gt;视频、音频等多媒体通信。&lt;/li&gt;
&lt;li&gt;广播通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-3-TCP-报文段的头部是什么？&#34;&gt;3.3 TCP 报文段的头部是什么？&lt;/h3&gt;
&lt;p&gt;TCP 报文段的头部至少 20 字节，常见字段包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源端口号和目的端口号：各占 16 位，用于标识通信双方的应用程序端口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;序列号&lt;/strong&gt;（Sequence Number）：占 32 位，用于标记发送的数据字节（不是报文段）在整个数据流中的位置（偏移量），用来&lt;strong&gt;解决网络包乱序问题&lt;/strong&gt;。连接建立时选取一个随机初始序号（ISN），通过 SYN 包传给接收端主机，后续每发送一个字节序号递增。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;确认应答号&lt;/strong&gt;（Acknowledgment Number）：占 32 位，表示期望接收的下一个字节的序列号，确保数据的有序确认，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被接收端正常接收，用来&lt;strong&gt;解决丢包的问题&lt;/strong&gt;。例如接收方发送 ACK = 555 时说明已经收到了 554 及之前的字节。&lt;/li&gt;
&lt;li&gt;数据偏移（Data Offset）：占 4 位，指明 TCP 首部的长度，以 4 字节为单位，使得选项字段长度可变。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制标志位&lt;/strong&gt;：共有 6 个，包括 URG（紧急指针有效）、ACK（确认号有效，该位为 1 时，确认应答号的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1）、PSH（推送数据）、RST（复位连接，该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接）、SYN（同步序列号，该位为 1 时，表示希望建立连接，并在其序列号的字段进行序列号初始值的设定）和 FIN（终止连接，该位为 1 时，表示今后不会再有数据发送，希望断开连接，当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段）。&lt;/li&gt;
&lt;li&gt;窗口大小（Window Size）：占 16 位，表示接收方当前能接收的数据量，用于流量控制。&lt;/li&gt;
&lt;li&gt;校验和（Checksum）：占 16 位，对 TCP 首部和数据进行错误检测，确保传输过程中数据未被损坏。&lt;/li&gt;
&lt;li&gt;紧急指针（Urgent Pointer）：占 16 位，仅当 URG 标志为 1 时有效，指示紧急数据的末尾。&lt;/li&gt;
&lt;li&gt;选项（Options）：如最大报文段长度（MSS）、窗口缩放、时间戳、SACK 等，用于扩展 TCP 功能和优化传输性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-4-TCP-的三次握手过程是什么？&#34;&gt;3.4 TCP 的三次握手过程是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第一次握手：首先服务器主动监听某个端口，处于 &lt;code&gt;LISTEN&lt;/code&gt; 状态，客户端请求建立连接，向服务器发送一个同步报文（&lt;code&gt;SYN = 1&lt;/code&gt;），同时选择一个随机数 &lt;code&gt;seq = x&lt;/code&gt; 作为初始序列号，并进入 &lt;code&gt;SYN_SENT&lt;/code&gt;（同步已发送）状态，等待服务器确认。&lt;/li&gt;
&lt;li&gt;第二次握手：服务器收到连接请求报文后，如果同意建立连接，则向客户端发送同步确认报文（&lt;code&gt;SYN = 1, ACK = 1&lt;/code&gt;），确认应答号为 &lt;code&gt;ack = x + 1&lt;/code&gt;，同时选择一个随机数 &lt;code&gt;seq = y&lt;/code&gt; 作为初始序列号，此时服务器进入 &lt;code&gt;SYN_RCVD&lt;/code&gt;（同步收到）状态。&lt;/li&gt;
&lt;li&gt;第三次握手：客户端收到服务器的确认报文后，向服务器发送一个应答报文（&lt;code&gt;ACK = 1&lt;/code&gt;），确认应答号为 &lt;code&gt;ack = y + 1&lt;/code&gt;，序列号为 &lt;code&gt;seq = x + 1&lt;/code&gt;，这段报文&lt;strong&gt;可以携带客户端到服务器的数据&lt;/strong&gt;，服务器收到客户端的应答报文后，客户端和服务器进入 &lt;code&gt;ESTABLISHED&lt;/code&gt;（已建立连接）状态，完成三次握手。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面的过程可以发现第三次握手是可以携带数据的，&lt;strong&gt;前两次握手是不可以携带数据的&lt;/strong&gt;，这也是面试常问的题。&lt;/p&gt;
&lt;p&gt;理想状态下，TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。&lt;/p&gt;
&lt;h3 id=&#34;3-5-为什么需要三次握手，而不是两次？&#34;&gt;3.5 为什么需要三次握手，而不是两次？&lt;/h3&gt;
&lt;p&gt;主要有三个原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;避免历史连接（主要原因）：防止已过期的连接请求报文突然又传送到服务器，因而产生错误和资源浪费。在双方两次握手即可建立连接的情况下，假设客户端发送报文段 A 请求建立连接，由于网络原因造成 A 暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段。客户端在长时间得不到应答的情况下重新发送请求报文段 B，这次 B 顺利到达服务器，服务器随即返回确认报文并进入 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态，客户端在收到确认报文后也进入 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态，双方建立连接并传输数据，之后正常断开连接。此时姗姗来迟的报文段 A 才到达服务器，服务器随即返回确认报文并进入 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态，但是已经进入 &lt;code&gt;CLOSED&lt;/code&gt; 状态的客户端无法再接受确认报文段，更无法进入 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态，这将导致服务器长时间单方面等待，造成资源浪费。&lt;/li&gt;
&lt;li&gt;三次握手才能让双方均确认自己和对方的发送和接收能力都正常：
&lt;ul&gt;
&lt;li&gt;第一次握手：客户端只是发送出请求报文段，什么都无法确认，而服务器可以确认自己的接收能力和客户端的发送能力正常。&lt;/li&gt;
&lt;li&gt;第二次握手：客户端可以确认自己发送能力和接收能力正常，服务器的发送能力和接收能力正常。&lt;/li&gt;
&lt;li&gt;第三次握手：服务器才可以确认&lt;strong&gt;自己的发送能力&lt;/strong&gt;以及&lt;strong&gt;客户端的接受能力&lt;/strong&gt;正常。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步双方初始序列号：告知对方自己的初始序号值，并确认收到对方的初始序号值。TCP 实现了可靠的数据传输，原因之一就是 TCP 报文段中维护了序号字段和确认序号字段，通过这两个字段双方都可以知道在自己发出的数据中，哪些是已经被对方确认接收的。这两个字段的值会在初始序号值的基础上递增，如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的初始序号则得不到确认，一来一回才能确保双方的初始序列号能被可靠的同步。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-6-为什么需要三次握手，而不是四次？&#34;&gt;3.6 为什么需要三次握手，而不是四次？&lt;/h3&gt;
&lt;p&gt;因为三次握手已经可以确认双方的发送和接收能力正常，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值的确认，也就无需第四次握手了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次握手：服务端确认&lt;strong&gt;自己收、对方发&lt;/strong&gt;报文功能正常。&lt;/li&gt;
&lt;li&gt;第二次握手：客户端确认&lt;strong&gt;自己发、自己收、对方收、对方发&lt;/strong&gt;报文功能正常，客户端认为连接己建立。&lt;/li&gt;
&lt;li&gt;第三次握手：服务端确认&lt;strong&gt;自己发、对方收&lt;/strong&gt;报文功能正常，此时双方均建立连接，可以正常通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-7-三次握手时如果客户端第三次发送的确认包丢失了会怎样？&#34;&gt;3.7 三次握手时如果客户端第三次发送的确认包丢失了会怎样？&lt;/h3&gt;
&lt;p&gt;客户端收到服务器的 SYN-ACK 报文后，就会给服务器回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 &lt;code&gt;ESTABLISH&lt;/code&gt; 状态。&lt;/p&gt;
&lt;p&gt;因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务器那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。第二次握手的最大重传次数由 &lt;code&gt;tcp_synack_retries&lt;/code&gt; 参数控制。&lt;/p&gt;
&lt;p&gt;注意，&lt;strong&gt;ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;3-8-客户端发送的第一个-SYN-报文，服务器没有收到怎么办？&#34;&gt;3.8 客户端发送的第一个 SYN 报文，服务器没有收到怎么办？&lt;/h3&gt;
&lt;p&gt;当客户端想和服务器建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 &lt;code&gt;SYN_SENT&lt;/code&gt; 状态。如果客户端迟迟收不到服务器的 SYN-ACK 报文（第二次握手），就会触发超时重传机制，重传 SYN 报文，而且重传的 SYN 报文的&lt;strong&gt;序列号都是一样的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。&lt;/p&gt;
&lt;p&gt;当客户端在 1 秒后没收到服务器的 SYN-ACK 报文后，客户端就会重发 SYN 报文，在 Linux 里，客户端的 SYN 报文最大重传次数由 &lt;code&gt;tcp_syn_retries&lt;/code&gt; 内核参数控制，这个参数是可以自定义的，默认值一般是 5。&lt;/p&gt;
&lt;p&gt;通常，第一次超时重传是在 1 秒后，第二次为 2 秒，第三次为 4 秒，即&lt;strong&gt;每次超时的时间设定是上一次的 2 倍&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;3-9-第一次握手过程中服务器内部做了哪些工作？&#34;&gt;3.9 第一次握手过程中服务器内部做了哪些工作？&lt;/h3&gt;
&lt;p&gt;服务器收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN + ACK，接着客户端会返回 ACK，服务器收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 Accept 队列，等待进程调用 &lt;code&gt;accept()&lt;/code&gt; 函数时把连接取出来。&lt;/p&gt;
&lt;h3 id=&#34;3-10-什么是-SYN-洪泛攻击？如何防范？&#34;&gt;3.10 什么是 SYN 洪泛攻击？如何防范？&lt;/h3&gt;
&lt;p&gt;SYN 洪泛攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的&lt;strong&gt;半连接&lt;/strong&gt;请求，耗费 CPU 和内存资源。&lt;/p&gt;
&lt;p&gt;原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在三次握手过程中，服务器发送 &lt;code&gt;[SYN/ACK]&lt;/code&gt; 包（即第二个包）之后、收到客户端的 &lt;code&gt;[ACK]&lt;/code&gt; 包（即第三个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 &lt;code&gt;SYN_RECV&lt;/code&gt;（等待客户端响应）状态。如果接收到客户端的 &lt;code&gt;[ACK]&lt;/code&gt;，则 TCP 连接成功，如果未接收到，则会不断重发请求直至成功。&lt;/li&gt;
&lt;li&gt;SYN 攻击的攻击者在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 &lt;code&gt;[SYN]&lt;/code&gt; 包，服务器回复 &lt;code&gt;[SYN/ACK]&lt;/code&gt; 包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时。&lt;/li&gt;
&lt;li&gt;这些伪造的 &lt;code&gt;[SYN]&lt;/code&gt; 包将长时间占用未连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络堵塞甚至系统瘫痪。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检测：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。&lt;/p&gt;
&lt;p&gt;防范：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过防火墙、路由器等过滤网关防护。&lt;/li&gt;
&lt;li&gt;通过加固 TCP/IP 协议栈防范，如增加最大半连接数，缩短超时时间。&lt;/li&gt;
&lt;li&gt;SYN Cookies 技术。SYN Cookies 是对 TCP 服务器端的三次握手做一些修改，专门用来防范 SYN 洪泛攻击的一种手段。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-11-TCP-的四次挥手过程是什么？&#34;&gt;3.11 TCP 的四次挥手过程是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第一次挥手：客户端向服务器发送连接释放报文（&lt;code&gt;FIN = 1, ACK = 1&lt;/code&gt;），主动关闭连接，同时等待服务器的确认，客户端进入 &lt;code&gt;FIN_WAIT_1&lt;/code&gt;（终止等待 1）状态。序列号 &lt;code&gt;seq = u&lt;/code&gt;，为客户端上次发送的报文的最后一个字节的序号 + 1。&lt;/li&gt;
&lt;li&gt;第二次挥手：服务器收到 FIN 报文后，立即发出确认报文（&lt;code&gt;ACK = 1&lt;/code&gt;），序列号 &lt;code&gt;seq = v&lt;/code&gt;，为服务器上次发送的报文的最后一个字节的序号 + 1，确认号 &lt;code&gt;ack = u + 1&lt;/code&gt;，服务器进入 &lt;code&gt;CLOSE_WAIT&lt;/code&gt;（关闭等待）状态。在收到 FIN 报文的时候，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，服务器应用程序可以通过 &lt;code&gt;read&lt;/code&gt; 调用来感知这个 FIN 包，这个 EOF 会被放在已排队等候的其他已接收的数据之后，所以必须得继续 &lt;code&gt;read&lt;/code&gt; 接收缓冲区已接收的数据。此时 TCP 连接处于&lt;strong&gt;半关闭&lt;/strong&gt;状态，即客户端到服务器的连接已经释放了，但是服务器到客户端的连接还未释放。这表示客户端已经没有数据发送了，但是服务器可能还要给客户端发送数据。&lt;/li&gt;
&lt;li&gt;第三次挥手：客户端收到服务器的确认后进入 &lt;code&gt;FIN_WAIT_2&lt;/code&gt;（终止等待 2）状态，等待服务器发出连接释放报文段。服务器向客户端发送连接释放报文（&lt;code&gt;FIN = 1, ACK = 1&lt;/code&gt;），主动关闭连接，同时等待客户端的确认，服务器进入 &lt;code&gt;LAST_ACK&lt;/code&gt;（最后确认）状态。
&lt;ul&gt;
&lt;li&gt;序列号 &lt;code&gt;seq = w&lt;/code&gt;，即服务器上次发送的报文的最后一个字节的序号 + 1，可能在半关闭状态服务器又发送了一些数据。&lt;/li&gt;
&lt;li&gt;确认号 &lt;code&gt;ack = u + 1&lt;/code&gt;，与第二次挥手相同，因为这段时间客户端没有发送数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第四次挥手：客户端收到服务器的连接释放报文后，立即发出确认报文（&lt;code&gt;ACK = 1&lt;/code&gt;），序列号 &lt;code&gt;seq = u + 1&lt;/code&gt;，确认号为 &lt;code&gt;ack = w + 1&lt;/code&gt;。此时，客户端就进入了 &lt;code&gt;TIME_WAIT&lt;/code&gt;（时间等待）状态。注意此时客户端的 TCP 连接还没有释放，必须经过 2 * MSL（最长报文段寿命）的时间后，才进入 &lt;code&gt;CLOSED&lt;/code&gt; 状态。而服务器只要收到客户端发出的确认，就立即进入 &lt;code&gt;CLOSED&lt;/code&gt; 状态。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-12-为什么连接的时候是三次握手，关闭的时候却是四次挥手？&#34;&gt;3.12 为什么连接的时候是三次握手，关闭的时候却是四次挥手？&lt;/h3&gt;
&lt;p&gt;服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会马上对客户端的 FIN 报文段做出应答，返回 ACK 报文段。接下来可能会继续发送数据，在数据发送完后，服务器会向客户端发送 FIN 报文，表示数据已经发送完毕，请求关团连接。&lt;/p&gt;
&lt;p&gt;关键点在于发送第三次挥手的控制权不在内核，而是在被动关闭方（前面所提到的服务器）的应用程序，因为应用程序可能还有数据要发送，由应用程序决定什么时候调用关闭连接的函数，当调用了关闭连接的函数，内核就会发送 FIN 报文了，服务器的 ACK 和 FIN 一般都会分开发送，从而导致多了一次，这也就是为什么四次挥手的中间两次不能合并为一次，一共需要四次挥手。&lt;/p&gt;
&lt;h3 id=&#34;3-13-如果第三次挥手一直没发，会发生什么？&#34;&gt;3.13 如果第三次挥手一直没发，会发生什么？&lt;/h3&gt;
&lt;p&gt;当主动方收到 ACK 报文后，会处于 &lt;code&gt;FIN_WAIT2&lt;/code&gt; 状态，就表示主动方的发送通道已经关闭，接下来将等待对方发送 FIN 报文，关闭对方的发送通道。&lt;/p&gt;
&lt;p&gt;这时，如果连接是用 &lt;code&gt;shutdown&lt;/code&gt; 函数关闭的，连接可以一直处于 &lt;code&gt;FIN_WAIT2&lt;/code&gt; 状态，因为它可能还可以发送或接收数据。但对于 &lt;code&gt;close&lt;/code&gt; 函数关闭的孤儿连接，由于无法再发送和接收数据，所以这个状态不可以持续太久，而 &lt;code&gt;tcp_fin_timeout&lt;/code&gt; 参数控制了这个状态下连接的持续时长，默认值是 60 秒，意味着对于孤儿连接（调用 &lt;code&gt;close&lt;/code&gt; 关闭的连接），如果在 60 秒后还没有收到 FIN 报文，连接就会直接关闭。&lt;/p&gt;
&lt;h3 id=&#34;3-14-主动断开连接时若客户端-FIN-包丢失，服务器的状态是什么？&#34;&gt;3.14 主动断开连接时若客户端 FIN 包丢失，服务器的状态是什么？&lt;/h3&gt;
&lt;p&gt;当客户端（主动关闭方）调用 &lt;code&gt;close&lt;/code&gt; 函数后，就会向服务器发送 FIN 报文，试图与服务器断开连接，此时客户端的连接进入到 &lt;code&gt;FIN_WAIT_1&lt;/code&gt; 状态。正常情况下，如果能及时收到服务器（被动关闭方）的 ACK，则会很快变为 &lt;code&gt;FIN_WAIT2&lt;/code&gt; 状态。&lt;/p&gt;
&lt;p&gt;如果第一次挥手丢失了，那么客户端迟迟收不到服务器的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 &lt;code&gt;tcp_orphan_retries&lt;/code&gt; 参数控制。&lt;/p&gt;
&lt;p&gt;当客户端重传 FIN 报文的次数超过 &lt;code&gt;tcp_orphan_retries&lt;/code&gt; 后，就不再发送 FIN 报文，会再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，那么客户端直接进入到 &lt;code&gt;CLOSED&lt;/code&gt; 状态，而服务器还是 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态。&lt;/p&gt;
&lt;h3 id=&#34;3-15-为什么四次挥手后客户端的-TIME-WAIT-状态必须等待-2MSL？&#34;&gt;3.15 为什么四次挥手后客户端的 TIME_WAIT 状态必须等待 2MSL？&lt;/h3&gt;
&lt;p&gt;MSL（Maximum Segment Lifetime，报文最大生存时间）是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个路由器此值就减 1，当值为 0 时数据报将被丢弃，同时发送 ICMP 报文通知源主机。&lt;/p&gt;
&lt;p&gt;MSL 与 TTL 的区别：MSL 的单位是时间，而 TTL 是经过的路由跳数。所以 MSL 应该要大于等于 TTL 消耗至 0 的时间，以确保报文已被自然消亡。&lt;/p&gt;
&lt;p&gt;TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了。&lt;/p&gt;
&lt;p&gt;TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。&lt;/p&gt;
&lt;p&gt;详细地说主要有以下两个原因:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确保最后一个 ACK 报文段能够到达服务器，从而使服务器正常关闭连接。第四次挥手时，客户端第四次挥手的 ACK 报文段不一定会到达服务器。服务器会超时重传 FIN-ACK 报文段，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务器迟迟收不到 FIN-ACK 报文段的确认，就无法正常断开连接。客户端等待 2MSL 时间即客户端 ACK 报文段 1MSL 超时 + 服务器 FIN-ACK 报文段 1MSL 传输，就能够收到服务器重传的 FIN-ACK 报文段，然后客户端重传一次 ACK 报文段，并重新启动 2MSL 计时器。如此保证服务器能够正常关闭。如果服务器重发的 FIN-ACK 报文段没有成功地在 2MSL 时间里传给客户端，服务器则会继续超时重试直到断开连接。&lt;/li&gt;
&lt;li&gt;防止已失效的连接请求报文段出现在之后的连接中。TCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-16-如果已经建立了连接，但是客户端出现故障了怎么办？&#34;&gt;3.16 如果已经建立了连接，但是客户端出现故障了怎么办？&lt;/h3&gt;
&lt;p&gt;通过&lt;strong&gt;定时器 + 超时重试机制&lt;/strong&gt;，尝试获取确认，直到最后会自动断开连接。&lt;/p&gt;
&lt;p&gt;具体而言，TCP 设有一个&lt;strong&gt;保活计时器&lt;/strong&gt;。服务器每收到一次客户端的数据，都会重新设置这个计时器，时间通常是设置为两小时，若两小时还没有收到客户端的任何数据，服务器就发送一个探测报文段，之后则每隔 75 秒发送一次，若一连发送 10 个探测报文段后客户端依然没有响应，那么服务器就认为客户端出现故障，接着就关闭这个连接。&lt;/p&gt;
&lt;h3 id=&#34;3-17-TIME-WAIT-是服务器还是客户端的状态？&#34;&gt;3.17 TIME_WAIT 是服务器还是客户端的状态？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TIME_WAIT&lt;/code&gt; 是&lt;strong&gt;主动断开连接&lt;/strong&gt;的一方会进入的状态，一般情况下，都是客户端所处的状态，服务器端一般设置不主动关闭连接。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TIME_WAIT&lt;/code&gt; 需要等待 2MSL，在大量短连接的情况下，&lt;code&gt;TIME_WAIT&lt;/code&gt; 会太多，这也会消耗很多系统资源。对于服务器来说，在 HTTP 协议里指定 KeepAlive（浏览器重用一个 TCP 连接来处理多个 HTTP 请求），由浏览器来主动断开连接，可以一定程度上减少服务器的这个问题。&lt;/p&gt;
&lt;h3 id=&#34;3-18-TCP-和-UDP-的区别是什么？&#34;&gt;3.18 TCP 和 UDP 的区别是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;连接：TCP 是面向连接的传输层协议，传输数据前先要建立连接。UDP 不需要连接，即刻传输数据。&lt;/li&gt;
&lt;li&gt;服务对象：TCP 是一对一的两点服务，即一条连接只有两个端点。UDP 支持一对一、一对多、多对多的交互通信。&lt;/li&gt;
&lt;li&gt;可靠性：TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议。&lt;/li&gt;
&lt;li&gt;拥塞控制、流量控制：TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。&lt;/li&gt;
&lt;li&gt;首部开销：TCP 首部长度较长，会有一定的开销，首部在没有使用“选项”字段时是 20 个字节。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。&lt;/li&gt;
&lt;li&gt;传输方式：TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-19-TCP-协议如何保证可靠性，即如何实现可靠传输？&#34;&gt;3.19 TCP 协议如何保证可靠性，即如何实现可靠传输？&lt;/h3&gt;
&lt;p&gt;TCP 主要提供了检验和、序列号/确认应答、超时重传、滑动窗口、拥塞控制和流量控制等方法实现了可靠性传输。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连接管理：即三次握手和四次挥手。连接管理机制能够建立起可靠的连接，这是保证传输可靠性的前提。&lt;/li&gt;
&lt;li&gt;检验和：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃 TCP 报文段，重新发送。&lt;/li&gt;
&lt;li&gt;序列号/确认应答：序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。TCP 传输的过程中，每次接收方收到数据后，都会对发送方进行确认应答。也就是发送 ACK 报文段，这个 ACK 报文段当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发，若指定时间内发送方仍未收到确认应答，就会启动超时重传。&lt;/li&gt;
&lt;li&gt;滑动窗口：滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。&lt;/li&gt;
&lt;li&gt;超时重传：超时重传的时间是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。&lt;/li&gt;
&lt;li&gt;拥塞控制：在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，当网络拥堵严重时，发送端减少数据发送，在保证 TCP 可靠性的同时，提高性能。拥塞控制是通过发送端维护一个拥塞窗口来实现的，发送端的发送速度受限于滑动窗口和拥塞窗口中的最小值。拥塞控制方法分为：慢开始，拥塞避免、快重传和快恢复。&lt;/li&gt;
&lt;li&gt;流量控制：如果主机 A 一直向主机 B 发送数据，不考虑主机 B 的接收能力，则可能导致主机 B 的接收缓冲区满了而无法再接收数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机 B 的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，TCP 支持根据接收端的处理能力，来决定发送端的发送速度，主机 B 通过告诉主机 A 自己接收缓冲区的大小，来使主机 A 控制发送的数据量。流量控制与 TCP 协议报头中的窗口大小有关。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-20-详细讲一下-TCP-的滑动窗口？&#34;&gt;3.20 详细讲一下 TCP 的滑动窗口？&lt;/h3&gt;
&lt;p&gt;在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。TCP 协议需要对数据进行确认后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。&lt;/p&gt;
&lt;p&gt;为了避免这种情况，TCP 引入了窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值。&lt;/p&gt;
&lt;p&gt;滑动窗口里面也分为有三种类型的数据，第一种是已经发送且收到确认但是未按序到达，即没有在窗口尾部形成一段连续的序列；第二种是已经发送但是未被确认的数据；第三种是等待发送的数据。随着已发送的数据不断被确认，窗口内等待发送的数据也会不断被发送。整个窗口就会不断往前移动，让还没轮到的数据进入窗口内。&lt;/p&gt;
&lt;p&gt;可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。&lt;/p&gt;
&lt;h3 id=&#34;3-21-详细讲一下拥塞控制？&#34;&gt;3.21 详细讲一下拥塞控制？&lt;/h3&gt;
&lt;p&gt;TCP 一共使用了四种算法来实现拥塞控制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;慢开始（slow-start）&lt;/li&gt;
&lt;li&gt;拥塞避免（congestion avoidance）&lt;/li&gt;
&lt;li&gt;快重传（fast retransmit）&lt;/li&gt;
&lt;li&gt;快恢复（fast recovery）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;发送方维持一个叫做拥塞窗口 cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;慢开始：不要一开始就发送大量的数据，&lt;strong&gt;由小到大逐渐增加拥塞窗口的大小&lt;/strong&gt;。&lt;br&gt;
例如一开始发送方先设置 cwnd = 1，发送第一个报文段，等发送方接收到对方的确认后把 cwnd 从 1 增大到 2。此后每经过一个传输轮次，拥塞窗口 cwnd 就加倍。&lt;br&gt;
为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个慢开始门限 &lt;code&gt;ssthresh&lt;/code&gt; 状态变量。
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;cwnd &amp;lt; ssthresh&lt;/code&gt; 时，使用慢开始算法。&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;cwnd &amp;gt; ssthresh&lt;/code&gt; 时，停止使用慢开始算法改用拥塞避免算法。&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;cwnd = ssthresh&lt;/code&gt; 时，即可使用慢开始算法，也可使用拥塞避免算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加一而不是加倍。这样拥塞窗口按线性规律缓慢增长。&lt;/li&gt;
&lt;li&gt;快重传：我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。快重传规定：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。&lt;/li&gt;
&lt;li&gt;快恢复：主要是配合快重传，当发送方连续收到三个重复确认时，就执行&lt;strong&gt;乘法减小&lt;/strong&gt;算法，把 &lt;code&gt;ssthresh&lt;/code&gt; 门限减半（为了预防网络发生拥塞），但接下来并不执行慢开始算法，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-网络场景&#34;&gt;4. 网络场景&lt;/h2&gt;
&lt;h3 id=&#34;4-1-描述一下打开百度首页后发生的网络过程？&#34;&gt;4.1 描述一下打开百度首页后发生的网络过程？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;解析 URL：分析 URL 所需要使用的传输协议和请求的资源路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，若存在则对非法字符进行转义后再进行下一过程。&lt;/li&gt;
&lt;li&gt;缓存判断：浏览器缓存 → 系统缓存（hosts 文件）→ 路由器缓存 → ISP 的 DNS 缓存，如果其中某个缓存存在，直接返回服务器的 IP 地址。&lt;/li&gt;
&lt;li&gt;DNS 解析：如果缓存未命中，浏览器向本地 DNS 服务器发起请求，最终可能通过根域名服务器、顶级域名服务器、权威域名服务器逐级查询，直到获取目标域名的 IP 地址。&lt;/li&gt;
&lt;li&gt;获取 MAC 地址：当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相结合，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 ARP 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。&lt;/li&gt;
&lt;li&gt;建立 TCP 连接：主机将使用目标 IP 地址和目标 MAC 地址发送一个 TCP SYN 包，请求建立一个 TCP 连接，然后交给路由器转发，等路由器转到目标服务器后，服务器回复一个 SYN-ACK 包，确认连接请求。最后，主机发送一个 ACK 包，确认已收到服务器的确认，TCP 连接建立完成。&lt;/li&gt;
&lt;li&gt;HTTPS 的 TLS 四次握手：如果使用的是 HTTPS 协议，在通信前还存在 TLS 的四次握手。&lt;/li&gt;
&lt;li&gt;发送 HTTP 请求：连接建立后，浏览器会向服务器发送 HTTP 请求。请求中包含了用户需要获取的资源的信息，例如网页的 URL、请求方法（如 GET、POST）等。&lt;/li&gt;
&lt;li&gt;服务器处理请求并返回响应：服务器收到请求后，会根据请求的内容进行相应的处理。例如，如果是请求网页，服务器会读取相应的网页文件，并生成 HTTP 响应。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-2-网页非常慢转圈圈的时候，要定位问题需要从哪些角度？&#34;&gt;4.2 网页非常慢转圈圈的时候，要定位问题需要从哪些角度？&lt;/h3&gt;
&lt;p&gt;最直接的办法就是抓包，排查的思路大概有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先确定是服务器的问题，还是客户端的问题。先确认浏览器是否可以访问其他网站，如果不可以，说明客户端网络自身的问题，然后检查客户端网络配置（连接 WIFI 正不正常，有没有插网线）。如果可以正常浏览其他网页，说明客户端网络是可以正常上网的。&lt;/li&gt;
&lt;li&gt;如果客户端网络没问题，就抓包确认 DNS 是否解析出了 IP 地址，如果没有解析出来，说明域名写错了，如果解析出了 IP 地址，抓包确认有没有和服务器建立三次握手，如果能成功建立三次握手，并且发出了 HTTP 请求，但是就是没有显示页面，可以查看服务器返回的响应码：
&lt;ul&gt;
&lt;li&gt;如果是 404 错误码，检查输入的 URL 是否正确；&lt;/li&gt;
&lt;li&gt;如果是 500，说明服务器此时有问题；&lt;/li&gt;
&lt;li&gt;如果是 200，F12 看看前端代码是否有问题导致浏览器没有渲染出页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果客户端网络是正常的，但是访问速度很慢，导致很久才显示出来。这时候要看客户端的网口流量是否太大了，导致 TCP 发生丢包之类的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总之就是一层一层排查，有没有插网线、网络配置是否正确、DNS 有没有解析出 IP 地址、TCP 有没有三次握手、HTTP 返回的响应码是什么等等。&lt;/p&gt;
&lt;h2 id=&#34;5-网络攻击&#34;&gt;5. 网络攻击&lt;/h2&gt;
&lt;h3 id=&#34;5-1-什么是-DDoS-攻击？怎么防范？&#34;&gt;5.1 什么是 DDoS 攻击？怎么防范？&lt;/h3&gt;
&lt;p&gt;分布式拒绝服务（DDoS）攻击是通过大规模互联网流量淹没目标服务器或其周边基础设施，以破坏目标服务器、服务或网络正常流量的恶意行为。&lt;/p&gt;
&lt;p&gt;DDoS 攻击是通过连接互联网的计算机网络进行的。这些网络由计算机和其他设备（例如 IoT 设备）组成，它们感染了恶意软件，从而被攻击者远程控制。这些个体设备称为机器人（或僵尸），一组机器人则称为僵尸网络。&lt;/p&gt;
&lt;p&gt;一旦建立了僵尸网络，攻击者就可通过向每个机器人发送远程指令来发动攻击。当僵尸网络将受害者的服务器或网络作为目标时，每个机器人会将请求发送到目标的 IP 地址，这可能导致服务器或网络不堪重负，从而造成对正常流量的拒绝服务。由于每个机器人都是合法的互联网设备，因而可能很难区分攻击流量与正常流量。&lt;/p&gt;
&lt;p&gt;常见的 DDoS 攻击包括以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络层攻击：比较典型的攻击类型是 UDP 反射攻击，例如：NTP Flood 攻击，这类攻击主要&lt;strong&gt;利用大流量拥塞被攻击者的网络带宽&lt;/strong&gt;，导致被攻击者的业务无法正常响应客户访问。&lt;/li&gt;
&lt;li&gt;传输层攻击：比较典型的攻击类型包括 SYN Flood 攻击、连接数攻击等，这类攻击通过&lt;strong&gt;占用服务器的连接池资源&lt;/strong&gt;从而达到拒绝服务的目的。&lt;/li&gt;
&lt;li&gt;会话层攻击：比较典型的攻击类型是 SSL 连接攻击，这类攻击&lt;strong&gt;占用服务器的 SSL 会话资源&lt;/strong&gt;从而达到拒绝服务的目的。&lt;/li&gt;
&lt;li&gt;应用层攻击：比较典型的攻击类型包括 DNS Flood 攻击、HTTP Flood 攻击、游戏假人攻击等，这类攻击&lt;strong&gt;占用服务器的应用处理资源&lt;/strong&gt;极大地消耗服务器处理性能从而达到拒绝服务的目的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了防范 DDoS 攻击，可以采取以下措施：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增强网络基础设施：提升网络带宽、增加服务器的处理能力和承载能力，通过增强基础设施的能力来抵御攻击。&lt;/li&gt;
&lt;li&gt;使用防火墙和入侵检测系统：配置防火墙规则，限制不必要的网络流量，阻止来自可疑 IP 地址的流量。入侵检测系统可以帮助及时发现并响应 DDoS 攻击。&lt;/li&gt;
&lt;li&gt;流量清洗和负载均衡：使用专业的 DDoS 防护服务提供商，通过流量清洗技术过滤掉恶意流量，将合法流量转发给目标服务器。负载均衡可以将流量均匀地分发到多台服务器上，减轻单一服务器的压力。&lt;/li&gt;
&lt;li&gt;配置访问控制策略：限制特定 IP 地址或 IP 段的访问，设置访问频率限制，防止过多请求集中在单个 IP 上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-2-CSRF-攻击是什么？&#34;&gt;5.2 CSRF 攻击是什么？&lt;/h3&gt;
&lt;p&gt;CSRF（跨站请求伪造）是一种攻击手段，攻击者通过诱导用户执行恶意操作，从而获取用户数据或执行恶意代码。CSRF 攻击通常通过伪造一个合法的 HTTP 请求来实现，这个请求看起来是合法的，但实际上是为了执行一个攻击者控制的操作。&lt;/p&gt;
&lt;p&gt;解决 CSRF 攻击的方法主要有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;验证用户会话：在服务器端对用户会话进行验证，确保请求的会话标识符与当前会话标识符匹配。这样可以防止攻击者伪造会话标识符。&lt;/li&gt;
&lt;li&gt;使用双重验证：除了会话验证，还可以使用其他验证方式，例如验证码、签名验证等。这些验证方式可以增加攻击的难度。&lt;/li&gt;
&lt;li&gt;防止跨站请求：通过设置 CSP（内容安全策略）来防止跨站请求，限制网页中可执行的脚本源，减少攻击者诱导用户执行恶意操作的可能性。&lt;/li&gt;
&lt;li&gt;避免使用自动提交表单：禁用默认的自动提交功能，要求用户在提交表单前确认操作，防止攻击者诱导用户在未经授权的情况下提交表单。&lt;/li&gt;
&lt;li&gt;强制 Referer 头部：在服务器端检查请求的 Referer 头部，确保请求来自可信来源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-3-XSS-攻击是什么？&#34;&gt;5.3 XSS 攻击是什么？&lt;/h3&gt;
&lt;p&gt;XSS 是跨站脚本攻击，攻击者通过在 Web 页面中插入恶意脚本代码，然后诱使用户访问该页面，从而使得恶意脚本在用户浏览器中执行，从而盗取用户信息、会话信息等敏感数据，甚至控制用户账户。&lt;/p&gt;
&lt;p&gt;XSS 攻击可以分为 3 类：存储型（持久型）、反射型（非持久型）、DOM 型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储型 XSS：注入型脚本永久存储在目标服务器上，当浏览器请求数据时，脚本从服务器上传回并执行。&lt;/li&gt;
&lt;li&gt;反射型 XSS：当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web 服务器将注入脚本，比如一个错误信息，搜索结果等返回到用户的浏览器上。由于浏览器认为这个响应来自“可信任”的服务器，所以会执行这段脚本。&lt;/li&gt;
&lt;li&gt;基于 DOM 的 XSS：通过修改原始的客户端代码，受害者浏览器的 DOM 环境改变，导致有效载荷的执行。也就是说，页面本身并没有变化，但由于 DOM 环境被恶意修改，有客户端代码被包含进了页面，并且意外执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;预防 XSS 攻击的方法主要包括以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入验证：对所有用户输入的数据进行有效性检验，过滤或转义特殊字符。例如，禁止用户输入 HTML 标签和 JavaScript 代码。&lt;/li&gt;
&lt;li&gt;输出编码：在网页输出用户输入内容时，使用合适的编码方式，如 HTML 转义、URL 编码等，防止恶意脚本注入。&lt;/li&gt;
&lt;li&gt;Content Security Policy（CSP）：通过设置 CSP 策略，限制网页中可执行的脚本源，有效防范 XSS 攻击。&lt;/li&gt;
&lt;li&gt;使用 HttpOnly 标记：在设置 Cookie 时，设置 HttpOnly 属性，使得 Cookie 无法被 JavaScript 代码读取，减少受到 XSS 攻击的可能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-4-了解过-DNS-劫持吗？&#34;&gt;5.4 了解过 DNS 劫持吗？&lt;/h3&gt;
&lt;p&gt;DNS 劫持的原理是攻击者在用户查询 DNS 服务器时篡改响应，将用户请求的域名映射到攻击者控制的虚假 IP 地址上，使用户误以为访问的是正常网站，实际上被重定向到攻击者操控的恶意网站。这种劫持可以通过植入恶意的 DNS 记录或劫持用户的 DNS 流量来实现。&lt;/p&gt;
</content>
        <category term="Interview" />
        <updated>2022-11-24T03:14:00.000Z</updated>
    </entry>
</feed>
