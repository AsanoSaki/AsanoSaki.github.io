{
    "version": "https://jsonfeed.org/version/1",
    "title": "AsanoSaki • All posts by \"c++\" tag",
    "description": "",
    "home_page_url": "https://asanosaki.github.io",
    "items": [
        {
            "id": "https://asanosaki.github.io/posts/46520.html",
            "url": "https://asanosaki.github.io/posts/46520.html",
            "title": "算法竞赛C++ STL详解",
            "date_published": "2021-10-05T09:40:00.000Z",
            "content_html": "<blockquote>\n<p>本文介绍了什么是 STL 以及如何使用 STL 更高效<s>偷懒</s>地解题。本篇文章将会长期更新，欢迎大家一起监督学习。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"一、STL概念\">一、STL概念</h2>\n<p>STL（<code>Standard Template Library</code>，标准模板库），是惠普实验室开发的一系列软件的统称。现主要出现在 C++ 中，STL 从广义上分为：容器（<code>Container</code>）、算法（<code>Algorithm</code>）和迭代器（<code>Iterator</code>）。STL 几乎所有的代码都采用了<strong>模板类或者模板函数</strong>，这相比传统的由函数和类组成的库来说提供了更好的代码重用机会。</p>\n<h2 id=\"二、STL六大组件\">二、STL六大组件</h2>\n<p>STL 提供了六大组件，彼此之间可以组合套用，这六大组件分别是容器、算法、迭代器、仿函数、适配器、空间配置器。其中，在算法竞赛中用到最多的为<strong>容器、算法与迭代器</strong>。</p>\n<ul>\n<li>容器（<code>Container</code>）：STL 容器为各种<strong>数据结构</strong>，如 <code>vector</code>、<code>stack</code>、<code>queue</code>、<code>map</code>、<code>set</code> 等，用来存放数据，从实现角度来看，STL 容器是一种 <code>class template</code>。</li>\n<li>算法（<code>Algorithm</code>）：STL 的算法多数定义在 <code>&lt;algorithm&gt;</code> 头文件中，其中包括了各种常用的算法，如 <code>sort</code>、<code>find</code>、<code>copy</code>、<code>reverse</code> 等，从实现角度来看，STL 算法是一种 <code>function template</code>。</li>\n<li>迭代器（<code>Iterator</code>）：STL 迭代器扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将 <code>opetator*</code>、<code>opetator-&gt;</code>、<code>operator++</code> 等指针相关操作予以重载的 <code>class template</code>。所有 STL 容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。</li>\n<li>仿函数（<code>Functor</code>）：行为类似函数，可作为算法的某种策略，从实现角度来看，仿函数是一种重载了 <code>operator()</code> 的 <code>class</code> 或者 <code>class template</code>。</li>\n<li>适配器（<code>Adaptor</code>）：一种用来修饰容器或仿函数或迭代器接口的东西。</li>\n<li>空间配置器（<code>Allocator</code>）：负责空间的配置与管理。从实现角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的 <code>class template</code>。</li>\n</ul>\n<h2 id=\"三、STL容器\">三、STL容器</h2>\n<p>相信很多人学习 STL 就是为了在比赛中能够更好地<s>装B</s>运用各种数据结构和算法，提高解题速度。确实，使用 STL 中的容器能够不需要自己手写定义各种数据结构，使用 STL 中的算法能够不需要自己手写实现各种基本算法，因此本部分对于算法巨巨们是最为重要的一部分，那么 STL 容器究竟有哪些呢？在做题中该如何使用呢？</p>\n<h3 id=\"3-1-vector\">3.1 vector</h3>\n<p><code>vector</code> 又称<strong>变长数组</strong>，定义在 <code>&lt;vector&gt;</code> 头文件中，<code>vector</code> 容器是<strong>动态空间</strong>，随着元素的加入，它的内部机制会自动扩充空间以容纳新的元素。因此 <code>vector</code> 的运用对于内存的合理利用与运用的灵活性有很大的帮助。</p>\n<ul>\n<li><code>vector</code> 的定义方式：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; v;  <span class=\"comment\">// 定义一个vector，其中的元素为int类型</span></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; v[N];  <span class=\"comment\">// 定义一个vector数组，其中有N个vector</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v</span><span class=\"params\">(len)</span></span>;  <span class=\"comment\">// 定义一个长度为len的vector</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v</span><span class=\"params\">(len, x)</span></span>;  <span class=\"comment\">// 定义一个长度为len的vector，初始化每个元素为x</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v2</span><span class=\"params\">(v1)</span></span>;  <span class=\"comment\">// 用v1给v2赋值，v1的类型为vector</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v2</span><span class=\"params\">(v1.begin(), v1.begin() + <span class=\"number\">3</span>)</span></span>;  <span class=\"comment\">// 将v1中第0~2三个元素赋值给v2</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>vector</code> 的常用内置函数：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vector中的常用内置函数</span></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; v = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;  <span class=\"comment\">// 初始化vector，v:&#123;1, 2, 3&#125;</span></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt;::iterator it = v.<span class=\"built_in\">begin</span>();  <span class=\"comment\">// 定义vector的迭代器，指向begin()</span></span><br><span class=\"line\"></span><br><span class=\"line\">v.<span class=\"built_in\">push_back</span>(<span class=\"number\">4</span>);  <span class=\"comment\">// 在vector的尾部插入元素4，v:&#123;1, 2, 3, 4&#125;</span></span><br><span class=\"line\">v.<span class=\"built_in\">pop_back</span>();  <span class=\"comment\">// 删除vector的最后一个元素，v:&#123;1, 2, 3&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 注意使用lower_bound()与upper_bound()函数时vector必须是有序的，upper_bound()在&lt;algorithm&gt;中</span></span><br><span class=\"line\"><span class=\"built_in\">lower_bound</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), <span class=\"number\">2</span>);  <span class=\"comment\">// 返回第一个大于等于2的元素的迭代器v.begin() + 1，若不存在则返回v.end()</span></span><br><span class=\"line\"><span class=\"built_in\">upper_bound</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), <span class=\"number\">2</span>);  <span class=\"comment\">// 返回第一个大于2的元素的迭代器v.begin() + 2，若不存在则返回v.end()</span></span><br><span class=\"line\">v.<span class=\"built_in\">size</span>();  <span class=\"comment\">// 返回vector中元素的个数</span></span><br><span class=\"line\">v.<span class=\"built_in\">empty</span>();  <span class=\"comment\">// 返回vector是否为空，若为空则返回true否则返回false</span></span><br><span class=\"line\">v.<span class=\"built_in\">front</span>();  <span class=\"comment\">// 返回vector中的第一个元素</span></span><br><span class=\"line\">v.<span class=\"built_in\">back</span>();  <span class=\"comment\">// 返回vector中的最后一个元素</span></span><br><span class=\"line\">v.<span class=\"built_in\">begin</span>();  <span class=\"comment\">// 返回vector第一个元素的迭代器</span></span><br><span class=\"line\">v.<span class=\"built_in\">end</span>();  <span class=\"comment\">// 返回vector最后一个元素后一个位置的迭代器</span></span><br><span class=\"line\">v.<span class=\"built_in\">clear</span>();  <span class=\"comment\">// 清空vector</span></span><br><span class=\"line\">v.<span class=\"built_in\">erase</span>(v.<span class=\"built_in\">begin</span>());  <span class=\"comment\">// 删除迭代器it所指向的元素，即删除第一个元素</span></span><br><span class=\"line\">v.<span class=\"built_in\">erase</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">begin</span>() + <span class=\"number\">2</span>);  <span class=\"comment\">// 删除区间[v.begin(), v.begin() + 2)的所有元素</span></span><br><span class=\"line\">v.<span class=\"built_in\">insert</span>(v.<span class=\"built_in\">begin</span>(), <span class=\"number\">1</span>);  <span class=\"comment\">// 在迭代器it所指向的位置前插入元素1，返回插入元素的迭代器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据下标进行遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; v.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">    cout &lt;&lt; v[i] &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用迭代器遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (vector&lt;<span class=\"type\">int</span>&gt;::iterator it = v.<span class=\"built_in\">begin</span>(); it != v.<span class=\"built_in\">end</span>(); it++)</span><br><span class=\"line\">    cout &lt;&lt; *it &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// for_each遍历(C++11)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : v)</span><br><span class=\"line\">    cout &lt;&lt; x &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-stack\">3.2 stack</h3>\n<p><code>stack</code> 又称<strong>栈</strong>，是一种<strong>后进先出</strong>（Last In First Out，LIFO）的数据结构，定义在 <code>&lt;stack&gt;</code> 头文件中，<code>stack</code> 容器允许新增元素、移除元素、取得栈顶元素，但是除了最顶端以外，没有任何方法可以存取 <code>stack</code> 的其它元素，换言之，<code>stack</code> <strong>不允许有遍历行为</strong>。</p>\n<ul>\n<li><code>stack</code> 的定义方式：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stack&lt;<span class=\"type\">int</span>&gt; stk;  <span class=\"comment\">// 定义一个stack，其中元素的类型为int</span></span><br><span class=\"line\">stack&lt;<span class=\"type\">int</span>&gt; stk[N];  <span class=\"comment\">// 定义一个stack数组，其中有N个stack</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>stack</code> 的常用内置函数：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// stack中的常用内置函数</span></span><br><span class=\"line\">stack&lt;<span class=\"type\">int</span>&gt; stk;</span><br><span class=\"line\">stk.<span class=\"built_in\">push</span>(x);  <span class=\"comment\">// 在stack中插入元素x</span></span><br><span class=\"line\">stk.<span class=\"built_in\">pop</span>();  <span class=\"comment\">// 弹出stack的栈顶元素</span></span><br><span class=\"line\">stk.<span class=\"built_in\">top</span>();  <span class=\"comment\">// 返回stack的栈顶元素</span></span><br><span class=\"line\">stk.<span class=\"built_in\">size</span>();  <span class=\"comment\">// 返回stack中元素的个数</span></span><br><span class=\"line\">stk.<span class=\"built_in\">empty</span>();  <span class=\"comment\">// 返回stack是否为空，若为空则返回true否则返回false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-string\">3.3 string</h3>\n<p><code>string</code> 又称<strong>字符串</strong>，定义在 <code>&lt;string&gt;</code> 头文件中。C 风格的字符串（以空字符结尾的字符数组）太过复杂难于掌握，因此 C++ 标准库定义了一种 <code>string</code> 类。<code>string</code> 和 <code>vector&lt;char&gt;</code> 在数据结构、内存管理等方面都是相同的。但是，<code>vector&lt;char&gt;</code> 只是单纯的一个“<code>char</code> 元素的容器”，而 <code>string</code> 不仅是一个“<code>char</code> 元素的容器”，它还扩展了一些针对字符串的操作，例如 <code>string</code> 可以使用 <code>c_str()</code> 函数转换为 C 风格的字符串，<code>vector</code> 中并未对输入输出流操作符进行重载，因此无法直接对 <code>vector&lt;char&gt;</code> 进行 <code>cin</code> 或者 <code>cout</code> 这样的操作，但是 <code>string</code> 可以，且 <code>vector&lt;char&gt;</code> 并不能直接实现字符串的拼接，但是 <code>string</code> 可以，<code>string</code> 中重载了 <code>+, +=</code> 运算符。</p>\n<ul>\n<li><code>string</code> 的定义方式：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str;  <span class=\"comment\">// 定义一个空的字符串</span></span><br><span class=\"line\">string str[N];  <span class=\"comment\">// 定义一个string数组，其中有N个string</span></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">str</span><span class=\"params\">(<span class=\"number\">5</span>, <span class=\"string\">&#x27;a&#x27;</span>)</span></span>;  <span class=\"comment\">// 使用5个字符&#x27;a&#x27;初始化</span></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">str</span><span class=\"params\">(<span class=\"string\">&quot;abc&quot;</span>)</span></span>;  <span class=\"comment\">// 使用字符串初始化</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>string</code> 的常用内置函数：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// string中的常用内置函数</span></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">str</span><span class=\"params\">(<span class=\"string\">&quot;abcabc&quot;</span>)</span></span>;</span><br><span class=\"line\">str.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;d&#x27;</span>);  <span class=\"comment\">// 在string尾部插入字符，&quot;abcabcd&quot;</span></span><br><span class=\"line\">str.<span class=\"built_in\">pop_back</span>();  <span class=\"comment\">// 删除string尾部的字符，&quot;abcabc&quot;</span></span><br><span class=\"line\">str.<span class=\"built_in\">length</span>();  <span class=\"comment\">// 返回string中字符的个数</span></span><br><span class=\"line\">str.<span class=\"built_in\">size</span>();  <span class=\"comment\">// 作用与length()相同</span></span><br><span class=\"line\">str.<span class=\"built_in\">empty</span>();  <span class=\"comment\">// 返回string是否为空，若为空返回true否则返回false</span></span><br><span class=\"line\">str.<span class=\"built_in\">substr</span>(<span class=\"number\">1</span>);  <span class=\"comment\">// 返回string中从下标为1开始至末尾的子串，&quot;bcabc&quot;</span></span><br><span class=\"line\">str.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, <span class=\"number\">2</span>);  <span class=\"comment\">// 返回string中从下标为0开始长度为2的子串，&quot;ab&quot;</span></span><br><span class=\"line\">str.<span class=\"built_in\">insert</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">&#x27;x&#x27;</span>);  <span class=\"comment\">// 在下标为1的字符前插入2个字符&#x27;x&#x27;，&quot;axxbcabc&quot;</span></span><br><span class=\"line\">str.<span class=\"built_in\">insert</span>(<span class=\"number\">1</span>, <span class=\"string\">&quot;yy&quot;</span>);  <span class=\"comment\">// 在下标为1的字符前插入字符串&quot;yy&quot;，&quot;ayyxxbcabc&quot;</span></span><br><span class=\"line\">str.<span class=\"built_in\">erase</span>(<span class=\"number\">1</span>, <span class=\"number\">4</span>);  <span class=\"comment\">// 删除从位置1开始的4个字符，&quot;abcabc&quot;</span></span><br><span class=\"line\">str.<span class=\"built_in\">find</span>(<span class=\"string\">&#x27;b&#x27;</span>);  <span class=\"comment\">// 返回字符&#x27;b&#x27;在string中第一次出现的位置，返回1，若不存在则返回-1</span></span><br><span class=\"line\">str.<span class=\"built_in\">find</span>(<span class=\"string\">&#x27;b&#x27;</span>, <span class=\"number\">2</span>);  <span class=\"comment\">// 返回从位置2开始字符&#x27;b&#x27;在string中第一次出现的位置，返回4</span></span><br><span class=\"line\">str.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;bc&quot;</span>);  <span class=\"comment\">// 同上，返回字符串第一次出现的位置，返回1，若不存在则返回-1</span></span><br><span class=\"line\">str.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;bc&quot;</span>, <span class=\"number\">2</span>);  <span class=\"comment\">// 返回4</span></span><br><span class=\"line\">str.<span class=\"built_in\">rfind</span>(<span class=\"string\">&#x27;b&#x27;</span>);  <span class=\"comment\">// 反向查找，原理同上，返回4，若不存在则返回-1</span></span><br><span class=\"line\">str.<span class=\"built_in\">rfind</span>(<span class=\"string\">&#x27;b&#x27;</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// 返回1</span></span><br><span class=\"line\">str.<span class=\"built_in\">rfind</span>(<span class=\"string\">&quot;bc&quot;</span>);  <span class=\"comment\">// 返回4，若不存在则返回-1</span></span><br><span class=\"line\">str.<span class=\"built_in\">rfind</span>(<span class=\"string\">&quot;bc&quot;</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// 返回1</span></span><br><span class=\"line\"><span class=\"built_in\">stoi</span>(str);  <span class=\"comment\">// 返回str的整数形式</span></span><br><span class=\"line\"><span class=\"built_in\">to_string</span>(value);  <span class=\"comment\">// 返回value的字符串形式，value为整型、浮点型等</span></span><br><span class=\"line\">str[<span class=\"number\">0</span>];  <span class=\"comment\">// 用下标访问string中的字符</span></span><br><span class=\"line\">cout &lt;&lt; (str == str) &lt;&lt; endl;  <span class=\"comment\">// string可比较大小，按字典序</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>string</code> 的 <code>erase()</code> 与 <code>remove()</code> 函数的用法：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// string中erase()与remove()的用法</span></span><br><span class=\"line\">string str1, str2, str3, str4, str5;</span><br><span class=\"line\">str1 = str2 = str3 = str4 = str5 = <span class=\"string\">&quot;I love AcWing! It&#x27;s very funny!&quot;</span>;</span><br><span class=\"line\">str1.<span class=\"built_in\">erase</span>(<span class=\"number\">15</span>);  <span class=\"comment\">// 删除[15,end())的所有元素，&quot;I love AcWing!&quot;</span></span><br><span class=\"line\">str2.<span class=\"built_in\">erase</span>(<span class=\"number\">6</span>, <span class=\"number\">11</span>);  <span class=\"comment\">// 从第6个元素(包括)开始往后删除11个元素，&quot;I love&#x27;s very funny!&quot;</span></span><br><span class=\"line\">str3.<span class=\"built_in\">erase</span>(str3.<span class=\"built_in\">begin</span>() + <span class=\"number\">2</span>);  <span class=\"comment\">// 删除迭代器所指的元素，&quot;I ove AcWing! It&#x27;s very funny!&quot;</span></span><br><span class=\"line\">str4.<span class=\"built_in\">erase</span>(str4.<span class=\"built_in\">begin</span>() + <span class=\"number\">7</span>, str4.<span class=\"built_in\">end</span>() - <span class=\"number\">11</span>);  <span class=\"comment\">// 删除[str4.begin()+7,str4.end()-11)的所有元素，&quot;I love very funny!&quot;</span></span><br><span class=\"line\">str5.<span class=\"built_in\">erase</span>(<span class=\"built_in\">remove</span>(str5.<span class=\"built_in\">begin</span>(), str5.<span class=\"built_in\">end</span>(), <span class=\"string\">&#x27;n&#x27;</span>), str5.<span class=\"built_in\">end</span>());  <span class=\"comment\">// 删除[str5.begin(),str5.end())中所有字符&#x27;n&#x27;，&quot;I love AcWig! It&#x27;s very fuy!&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-queue-priority-queue\">3.4 queue/priority_queue</h3>\n<p><code>queue</code> 又称<strong>队列</strong>，是一种<strong>先进先出</strong>（First In First Out，FIFO）的数据结构，定义在 <code>&lt;queue&gt;</code> 头文件中，<code>queue</code> 容器允许从一端（称为<strong>队尾</strong>）新增元素（入队），从另一端（称为<strong>队头</strong>）移除元素（出队）。</p>\n<p><code>priority_queue</code> 又称<strong>优先队列</strong>，同样定义在 <code>&lt;queue&gt;</code> 头文件中，与 <code>queue</code> 不同的地方在于我们可以自定义其中数据的优先级，优先级高的排在队列前面，优先出队。<code>priority_queue</code> 具有 <code>queue</code> 的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它的本质是用<strong>堆</strong>实现的，因此可分为<strong>小根堆</strong>与<strong>大根堆</strong>，<strong>小根堆</strong>中较小的元素排在前面，<strong>大根堆</strong>中较大的元素排在前面。（创建 <code>priority_queue</code> 时<strong>默认是大根堆！</strong>）</p>\n<ul>\n<li><code>queue/priority_queue</code> 的定义方式：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; que;  <span class=\"comment\">// 定义一个queue，其中元素的类型为int</span></span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; que[N];  <span class=\"comment\">// 定义一个queue数组，其中有N个queue</span></span><br><span class=\"line\">priority_queue&lt;<span class=\"type\">int</span>&gt; bigHeap;  <span class=\"comment\">// 定义一个大根堆</span></span><br><span class=\"line\">priority_queue&lt;<span class=\"type\">int</span>, vector&lt;<span class=\"type\">int</span>&gt;, greater&lt;<span class=\"type\">int</span>&gt; &gt; smallHeap;  <span class=\"comment\">// 定义一个小根堆</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>queue/priority_queue</code> 的常用内置函数：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// queue/priority_queue中的常用内置函数</span></span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; que;</span><br><span class=\"line\">priority_queue&lt;<span class=\"type\">int</span>&gt; bigHeap;</span><br><span class=\"line\">que.<span class=\"built_in\">push</span>(x);  <span class=\"comment\">// 在queue的队尾插入元素x</span></span><br><span class=\"line\">que.<span class=\"built_in\">pop</span>();  <span class=\"comment\">// 出队queue的队头元素</span></span><br><span class=\"line\">que.<span class=\"built_in\">front</span>();  <span class=\"comment\">// 返回queue的队头元素</span></span><br><span class=\"line\">que.<span class=\"built_in\">back</span>();  <span class=\"comment\">// 返回queue的队尾元素</span></span><br><span class=\"line\">que.<span class=\"built_in\">size</span>();  <span class=\"comment\">// 返回queue中元素的个数</span></span><br><span class=\"line\">que.<span class=\"built_in\">empty</span>();  <span class=\"comment\">// 返回queue是否为空，若为空则返回true否则返回false</span></span><br><span class=\"line\">bigHeap.<span class=\"built_in\">top</span>();  <span class=\"comment\">// 返回priority_queue的队头元素</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-deque\">3.5 deque</h3>\n<p><code>deque</code> 又称<strong>双端队列</strong>，定义在 <code>&lt;deque&gt;</code> 头文件中，<code>vector</code> 容器是单向开口的连续内存空间，<code>deque</code> 则是一种<strong>双向开口的连续线性空间</strong>。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，<code>vector</code>也可以在头尾两端插入元素，但是在其头部进行插入操作效率很低。<code>deque</code> 和 <code>vector</code> 最大的差异一是在于 <code>deque</code> 允许使用常数项时间在头部进行元素的插入和删除操作，二是在于 <code>deque</code> 没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。</p>\n<ul>\n<li><code>deque</code> 的定义方式：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deque&lt;<span class=\"type\">int</span>&gt; deq;  <span class=\"comment\">// 定义一个deque，其中的元素为int类型</span></span><br><span class=\"line\">deque&lt;<span class=\"type\">int</span>&gt; deq[N];  <span class=\"comment\">// 定义一个deque数组，其中有N个deque</span></span><br><span class=\"line\"><span class=\"function\">deque&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">deq</span><span class=\"params\">(len)</span></span>;  <span class=\"comment\">// 定义一个长度为len的deque</span></span><br><span class=\"line\"><span class=\"function\">deque&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">deq</span><span class=\"params\">(len, x)</span></span>;  <span class=\"comment\">// 定义一个长度为len的deque，初始化每个元素为x</span></span><br><span class=\"line\"><span class=\"function\">deque&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">deq2</span><span class=\"params\">(deq1)</span></span>;  <span class=\"comment\">// 用deq1给v2赋值，deq2的类型为deque</span></span><br><span class=\"line\"><span class=\"function\">deque&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">deq2</span><span class=\"params\">(deq1.begin(), deq1.begin() + <span class=\"number\">3</span>)</span></span>;  <span class=\"comment\">// 将deq1中第0~2三个元素赋值给deq2</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>deque</code> 的常用内置函数：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//deque中的常用内置函数</span></span><br><span class=\"line\">deque&lt;<span class=\"type\">int</span>&gt; deq = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;  <span class=\"comment\">// 初始化vector，v:&#123;1, 2, 3&#125;</span></span><br><span class=\"line\">deque&lt;<span class=\"type\">int</span>&gt;::iterator it = deq.<span class=\"built_in\">begin</span>();  <span class=\"comment\">// 定义vector的迭代器，指向begin()</span></span><br><span class=\"line\"></span><br><span class=\"line\">deq.<span class=\"built_in\">push_back</span>(<span class=\"number\">4</span>);  <span class=\"comment\">// 在deque的尾部插入元素4，v:&#123;1, 2, 3, 4&#125;</span></span><br><span class=\"line\">deq.<span class=\"built_in\">pop_back</span>();  <span class=\"comment\">// 删除deque的尾部元素，v:&#123;1, 2, 3&#125;</span></span><br><span class=\"line\">deq.<span class=\"built_in\">push_front</span>(<span class=\"number\">4</span>);  <span class=\"comment\">// 在deque的头部插入元素4，v:&#123;4, 1, 2, 3&#125;</span></span><br><span class=\"line\">deq.<span class=\"built_in\">pop_front</span>();  <span class=\"comment\">// 删除deque的头部元素，v:&#123;1, 2, 3&#125;</span></span><br><span class=\"line\">deq.<span class=\"built_in\">size</span>();  <span class=\"comment\">// 返回deque中元素的个数</span></span><br><span class=\"line\">deq.<span class=\"built_in\">empty</span>();  <span class=\"comment\">// 返回deque是否为空，若为空则返回true否则返回false</span></span><br><span class=\"line\">deq.<span class=\"built_in\">front</span>();  <span class=\"comment\">// 返回deque中的第一个元素</span></span><br><span class=\"line\">deq.<span class=\"built_in\">back</span>();  <span class=\"comment\">// 返回deque中的最后一个元素</span></span><br><span class=\"line\">deq.<span class=\"built_in\">begin</span>();  <span class=\"comment\">// 返回deque第一个元素的迭代器</span></span><br><span class=\"line\">deq.<span class=\"built_in\">end</span>();  <span class=\"comment\">// 返回deque最后一个元素后一个位置的迭代器</span></span><br><span class=\"line\">deq.<span class=\"built_in\">clear</span>();  <span class=\"comment\">// 清空deque</span></span><br><span class=\"line\">deq.<span class=\"built_in\">erase</span>(deq.<span class=\"built_in\">begin</span>());  <span class=\"comment\">// 删除迭代器it所指向的元素，即删除第一个元素</span></span><br><span class=\"line\">deq.<span class=\"built_in\">erase</span>(deq.<span class=\"built_in\">begin</span>(), deq.<span class=\"built_in\">begin</span>() + <span class=\"number\">2</span>);  <span class=\"comment\">// 删除区间[v.begin(), v.begin() + 2)的所有元素</span></span><br><span class=\"line\">deq.<span class=\"built_in\">insert</span>(deq.<span class=\"built_in\">begin</span>(), <span class=\"number\">1</span>);  <span class=\"comment\">// 在迭代器it所指向的位置前插入元素1，返回插入元素的迭代器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据下标进行遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; deq.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">    cout &lt;&lt; deq[i] &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用迭代器遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (deque&lt;<span class=\"type\">int</span>&gt;::iterator it = deq.<span class=\"built_in\">begin</span>(); it != deq.<span class=\"built_in\">end</span>(); it++)</span><br><span class=\"line\">    cout &lt;&lt; *it &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// for_each遍历(C++11)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : deq)</span><br><span class=\"line\">    cout &lt;&lt; x &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-map-multimap\">3.6 map/multimap</h3>\n<p><code>map/multimap</code> 又称<strong>映射</strong>，定义在 <code>&lt;map&gt;</code> 头文件中，<code>map</code> 和 <code>multimap</code> 的底层实现机制都是红黑树。<code>map</code> 的功能是<strong>能够将任意类型的元素映射到另一个任意类型的元素上</strong>，并且所有的元素都会根据元素的键值自动排序。<code>map</code> 所有的元素都是 <code>pair</code>，同时拥有<strong>键值</strong>和<strong>实值</strong>（即 <code>(key, value)</code> 对），<code>key</code> 被视为<strong>键值</strong>，<code>value</code> 被视为<strong>实值</strong>，<code>map</code> 不允许两个元素有相同的键值。<code>multimap</code> 和 <code>map</code> 的操作类似，唯一区别是 <code>multimap</code> 的键值允许重复。</p>\n<ul>\n<li><code>map/multimap</code> 的定义方式：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map&lt;string, <span class=\"type\">int</span>&gt; mp;  <span class=\"comment\">// 定义一个将string映射成int的map</span></span><br><span class=\"line\">map&lt;string, <span class=\"type\">int</span>&gt; mp[N];  <span class=\"comment\">// 定义一个map数组，其中有N个map</span></span><br><span class=\"line\">multimap&lt;string, <span class=\"type\">int</span>&gt; mulmp;  <span class=\"comment\">// 定义一个将string映射成int的multimap</span></span><br><span class=\"line\">multimap&lt;string, <span class=\"type\">int</span>&gt; mulmp[N];  <span class=\"comment\">// 定义一个multimap数组，其中有N个multimap</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>map/multimap</code> 的常用内置函数：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// map/multimap中的常用内置函数</span></span><br><span class=\"line\">map&lt;string, <span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">mp[<span class=\"string\">&quot;abc&quot;</span>] = <span class=\"number\">3</span>;  <span class=\"comment\">// 将&quot;abc&quot;映射到3</span></span><br><span class=\"line\">mp[<span class=\"string\">&quot;ab&quot;</span>]++;  <span class=\"comment\">// 将&quot;ab&quot;所映射的整数++</span></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"string\">&quot;cd&quot;</span>, <span class=\"number\">2</span>));  <span class=\"comment\">// 插入元素</span></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(&#123; <span class=\"string\">&quot;ef&quot;</span>, <span class=\"number\">5</span> &#125;);  <span class=\"comment\">// 同上</span></span><br><span class=\"line\">mp.<span class=\"built_in\">size</span>();  <span class=\"comment\">// 返回map中元素的个数</span></span><br><span class=\"line\">mp.<span class=\"built_in\">empty</span>();  <span class=\"comment\">// 返回map是否为空，若为空返回true否则返回false</span></span><br><span class=\"line\">mp.<span class=\"built_in\">clear</span>();  <span class=\"comment\">// 清空map</span></span><br><span class=\"line\">mp.<span class=\"built_in\">erase</span>(<span class=\"string\">&quot;ef&quot;</span>);  <span class=\"comment\">// 清除元素&#123;&quot;ef&quot;, 5&#125;</span></span><br><span class=\"line\">mp[<span class=\"string\">&quot;abc&quot;</span>];  <span class=\"comment\">// 返回&quot;abc&quot;映射的值</span></span><br><span class=\"line\">mp.<span class=\"built_in\">begin</span>();  <span class=\"comment\">// 返回map第一个元素的迭代器</span></span><br><span class=\"line\">mp.<span class=\"built_in\">end</span>();  <span class=\"comment\">// 返回map最后一个元素后一个位置的迭代器</span></span><br><span class=\"line\">mp.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;ab&quot;</span>);  <span class=\"comment\">// 返回第一个键值为&quot;ab&quot;的迭代器，若不存在则返回mp.end()</span></span><br><span class=\"line\">mp.<span class=\"built_in\">find</span>(&#123; <span class=\"string\">&quot;abc&quot;</span>, <span class=\"number\">3</span> &#125;);  <span class=\"comment\">// 返回元素&#123;&quot;abc&quot;, 3&#125;的迭代器，若不存在则返回mp.end()</span></span><br><span class=\"line\">mp.<span class=\"built_in\">count</span>(<span class=\"string\">&quot;abc&quot;</span>);  <span class=\"comment\">// 返回第一个键值为&quot;abc&quot;的元素数量1，由于map元素不能重复因此count返回值只有0或1</span></span><br><span class=\"line\">mp.<span class=\"built_in\">count</span>(&#123; <span class=\"string\">&quot;abc&quot;</span>, <span class=\"number\">2</span> &#125;);  <span class=\"comment\">// 返回第一个键值为&quot;abc&quot;的元素数量1，注意和find不一样，count只判断第一个键值</span></span><br><span class=\"line\">mp.<span class=\"built_in\">lower_bound</span>(<span class=\"string\">&quot;abc&quot;</span>);  <span class=\"comment\">// 返回第一个键值大于等于&quot;abc&quot;的元素的迭代器，&#123;&quot;abc&quot;, 3&#125;</span></span><br><span class=\"line\">mp.<span class=\"built_in\">upper_bound</span>(<span class=\"string\">&quot;abc&quot;</span>);  <span class=\"comment\">// 返回第一个键值大于&quot;abc&quot;的元素的迭代器，&#123;&quot;cd&quot;, 2&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用迭代器遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (map&lt;string, <span class=\"type\">int</span>&gt;::iterator it = mp.<span class=\"built_in\">begin</span>(); it != mp.<span class=\"built_in\">end</span>(); it++)</span><br><span class=\"line\">    cout &lt;&lt; (*it).first &lt;&lt; <span class=\"string\">&#x27; &#x27;</span> &lt;&lt; (*it).second &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// for_each遍历(C++11)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : mp)</span><br><span class=\"line\">    cout &lt;&lt; x.first &lt;&lt; <span class=\"string\">&#x27; &#x27;</span> &lt;&lt; x.second &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 扩展推断范围的for_each遍历(C++17)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;[k, v] : mp)</span><br><span class=\"line\">    cout &lt;&lt; k &lt;&lt; <span class=\"string\">&#x27; &#x27;</span> &lt;&lt; v &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-7-set-multiset\">3.7 set/multiset</h3>\n<p><code>set/multiset</code> 又称<strong>集合</strong>，定义在 <code>&lt;set&gt;</code> 头文件中。<code>set</code> 的特性是所有元素都会根据元素的键值自动被排序，<code>set</code> 的元素不像 <code>map</code> 那样可以同时拥有键值和实值，<code>set</code> 的元素既是键值又是实值，<code>set</code> 不允许两个元素有相同的键值，因此总结来说就是 <code>set</code> 中的元素是<strong>有序且不重复的</strong>。<code>multiset</code> 的特性和用法和 <code>set</code> 完全相同，唯一的区别在于 <code>multiset</code> 允许有重复元素，<code>set</code> 和 <code>multiset</code> 的底层实现都是红黑树。</p>\n<ul>\n<li><code>set/multiset</code> 的定义方式：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set&lt;<span class=\"type\">int</span>&gt; st;  <span class=\"comment\">// 定义一个set，其中的元素类型为int</span></span><br><span class=\"line\">set&lt;<span class=\"type\">int</span>&gt; st[N];  <span class=\"comment\">// 定义一个set数组，其中有N个set</span></span><br><span class=\"line\">multiset&lt;<span class=\"type\">int</span>&gt; mulst;  <span class=\"comment\">// 定义一个multiset</span></span><br><span class=\"line\">multiset&lt;<span class=\"type\">int</span>&gt; mulst[N];  <span class=\"comment\">// 定义一个multiset数组，其中有N个multiset</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>set/multiset</code> 的常用内置函数：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// set/multiset中的常用内置函数</span></span><br><span class=\"line\">set&lt;<span class=\"type\">int</span>&gt; st;</span><br><span class=\"line\">st.<span class=\"built_in\">insert</span>(<span class=\"number\">5</span>);  <span class=\"comment\">// 插入元素5</span></span><br><span class=\"line\">st.<span class=\"built_in\">insert</span>(<span class=\"number\">6</span>);  <span class=\"comment\">// 同上</span></span><br><span class=\"line\">st.<span class=\"built_in\">insert</span>(<span class=\"number\">7</span>);  <span class=\"comment\">// 同上</span></span><br><span class=\"line\">st.<span class=\"built_in\">size</span>();  <span class=\"comment\">// 返回set中元素的个数</span></span><br><span class=\"line\">st.<span class=\"built_in\">empty</span>();  <span class=\"comment\">// 返回set是否为空，若为空返回true否则返回false</span></span><br><span class=\"line\">st.<span class=\"built_in\">erase</span>(<span class=\"number\">6</span>);  <span class=\"comment\">// 清除元素6</span></span><br><span class=\"line\">st.<span class=\"built_in\">begin</span>();  <span class=\"comment\">// 返回set第一个元素的迭代器</span></span><br><span class=\"line\">st.<span class=\"built_in\">end</span>();  <span class=\"comment\">// 返回set最后一个元素后一个位置的迭代器</span></span><br><span class=\"line\">st.<span class=\"built_in\">clear</span>();  <span class=\"comment\">// 清空set</span></span><br><span class=\"line\">st.<span class=\"built_in\">find</span>(<span class=\"number\">5</span>);  <span class=\"comment\">// 返回元素5的迭代器，若不存在则返回st.end()</span></span><br><span class=\"line\">st.<span class=\"built_in\">count</span>(<span class=\"number\">5</span>);  <span class=\"comment\">// 返回元素5的个数1，由于set元素不会重复，因此count返回值只有0或1</span></span><br><span class=\"line\">st.<span class=\"built_in\">lower_bound</span>(<span class=\"number\">5</span>);  <span class=\"comment\">// 返回第一个键值大于等于5的元素的迭代器，返回元素5的迭代器</span></span><br><span class=\"line\">st.<span class=\"built_in\">upper_bound</span>(<span class=\"number\">5</span>);  <span class=\"comment\">// 返回第一个键值大于5的元素的迭代器，返回元素7的迭代器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用迭代器遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (set&lt;<span class=\"type\">int</span>&gt;::iterator it = st.<span class=\"built_in\">begin</span>(); it != st.<span class=\"built_in\">end</span>(); it++)</span><br><span class=\"line\">    cout &lt;&lt; (*it) &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// for_each遍历(C++11)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : st)</span><br><span class=\"line\">    cout &lt;&lt; x &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-8-unordered-map-unordered-set\">3.8 unordered_map/unordered_set</h3>\n<p><code>unordered_map/unordered_set</code> 分别定义在 <code>&lt;unordered_map&gt;</code> 与 <code>&lt;unordered_set&gt;</code> 头文件中，内部采用的是 <code>hash</code> 表结构，拥有快速检索的功能。与 <code>map/set</code> 相比最大的区别在于 <code>unordered_map/unordered_set</code> 中的元素是<strong>无序</strong>的，增删改查的时间复杂度为 <code>O(1)</code>（<code>map/set</code> 增删改查的时间复杂度为 <code>O(logn)</code>），但是不支持 <code>lower_bound()/upper_bound()</code> 函数。</p>\n<ul>\n<li><code>unordered_map/unordered_set</code> 的定义方式：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unordered_set&lt;<span class=\"type\">int</span>&gt; st;  <span class=\"comment\">// 定义一个unordered_set，其中的元素类型为int</span></span><br><span class=\"line\">unordered_set&lt;<span class=\"type\">int</span>&gt; st[N];  <span class=\"comment\">// 定义一个unordered_set数组，其中有N个unordered_set</span></span><br><span class=\"line\">unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; mp;  <span class=\"comment\">// 定义一个unordered_map</span></span><br><span class=\"line\">unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; mp[N];  <span class=\"comment\">// 定义一个unordered_map数组，其中有N个unordered_map</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>unordered_map/unordered_set</code> 的常用内置函数：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// unordered_map/unordered_set中的常用内置函数</span></span><br><span class=\"line\">unordered_set&lt;<span class=\"type\">int</span>&gt; st;</span><br><span class=\"line\">unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">st.<span class=\"built_in\">insert</span>(<span class=\"number\">5</span>);  <span class=\"comment\">// 插入元素5</span></span><br><span class=\"line\">st.<span class=\"built_in\">insert</span>(<span class=\"number\">6</span>);  <span class=\"comment\">// 同上</span></span><br><span class=\"line\">st.<span class=\"built_in\">insert</span>(<span class=\"number\">7</span>);  <span class=\"comment\">// 同上</span></span><br><span class=\"line\">st.<span class=\"built_in\">size</span>();  <span class=\"comment\">// 返回unordered_set中元素的个数</span></span><br><span class=\"line\">st.<span class=\"built_in\">empty</span>();  <span class=\"comment\">// 返回unordered_set是否为空，若为空返回true否则返回false</span></span><br><span class=\"line\">st.<span class=\"built_in\">erase</span>(<span class=\"number\">6</span>);  <span class=\"comment\">// 清除元素6</span></span><br><span class=\"line\">st.<span class=\"built_in\">find</span>(<span class=\"number\">5</span>);  <span class=\"comment\">// 返回元素5的迭代器，若不存在则返回st.end()</span></span><br><span class=\"line\">st.<span class=\"built_in\">count</span>(<span class=\"number\">5</span>);  <span class=\"comment\">// 返回元素5的个数，由于unordered_set元素不会重复，因此count返回值只有0或1</span></span><br><span class=\"line\">st.<span class=\"built_in\">begin</span>();  <span class=\"comment\">// 返回unordered_set第一个元素的迭代器</span></span><br><span class=\"line\">st.<span class=\"built_in\">end</span>();  <span class=\"comment\">// 返回unordered_set最后一个元素后一个位置的迭代器</span></span><br><span class=\"line\">st.<span class=\"built_in\">clear</span>();  <span class=\"comment\">// 清空unordered_set</span></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>));  <span class=\"comment\">// 插入元素&#123;1, 2&#125;</span></span><br><span class=\"line\">mp.<span class=\"built_in\">insert</span>(&#123; <span class=\"number\">3</span>, <span class=\"number\">4</span> &#125;);  <span class=\"comment\">// 同上</span></span><br><span class=\"line\">mp.<span class=\"built_in\">size</span>();  <span class=\"comment\">// 返回unordered_map中元素的个数</span></span><br><span class=\"line\">mp.<span class=\"built_in\">empty</span>();  <span class=\"comment\">// 返回unordered_map是否为空，若为空返回true否则返回false</span></span><br><span class=\"line\">mp.<span class=\"built_in\">erase</span>(<span class=\"number\">3</span>);  <span class=\"comment\">// 清除元素&#123;3, 4&#125;</span></span><br><span class=\"line\">mp.<span class=\"built_in\">find</span>(<span class=\"number\">1</span>);  <span class=\"comment\">// 返回第一个键值为1的迭代器，若不存在则返回mp.end()</span></span><br><span class=\"line\">mp.<span class=\"built_in\">count</span>(<span class=\"number\">1</span>);  <span class=\"comment\">// 返回第一个键值为1的元素数量，由于unordered_map元素不能重复因此count返回值只有0或1</span></span><br><span class=\"line\">mp.<span class=\"built_in\">begin</span>();  <span class=\"comment\">// 返回unordered_map第一个元素的迭代器</span></span><br><span class=\"line\">mp.<span class=\"built_in\">end</span>();  <span class=\"comment\">// 返回unordered_map最后一个元素后一个位置的迭代器</span></span><br><span class=\"line\">mp.<span class=\"built_in\">clear</span>();  <span class=\"comment\">// 清空unordered_map</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用迭代器遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (unordered_set&lt;<span class=\"type\">int</span>&gt;::iterator it = st.<span class=\"built_in\">begin</span>(); it != st.<span class=\"built_in\">end</span>(); it++)</span><br><span class=\"line\">    cout &lt;&lt; (*it) &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// for_each遍历(C++11)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : st)</span><br><span class=\"line\">    cout &lt;&lt; x &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用迭代器遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;::iterator it = mp.<span class=\"built_in\">begin</span>(); it != mp.<span class=\"built_in\">end</span>(); it++)</span><br><span class=\"line\">    cout &lt;&lt; (*it).first &lt;&lt; <span class=\"string\">&#x27; &#x27;</span> &lt;&lt; (*it).second &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// for_each遍历(C++11)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : mp)</span><br><span class=\"line\">    cout &lt;&lt; x.first &lt;&lt; <span class=\"string\">&#x27; &#x27;</span> &lt;&lt; x.second &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 扩展推断范围的for_each遍历(C++17)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;[k, v] : mp)</span><br><span class=\"line\">    cout &lt;&lt; k &lt;&lt; <span class=\"string\">&#x27; &#x27;</span> &lt;&lt; v &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<h2 id=\"四、STL算法\">四、STL算法</h2>\n<p>C++ 标准库定义了一组<strong>泛型算法</strong>，之所以称为泛型指的是它们可以操作在多种容器上，<strong>不但可以作用于标准库类型，还可以用在内置数组类型甚至其它类型的序列上</strong>。泛型算法定义在 <code>&lt;algorithm&gt;</code> 头文件中，标准库还定义了一组<strong>泛化的算术算法</strong>（Generalized Numeric Algorithm），定义在 <code>&lt;numeric&gt;</code> 头文件中。使用方法如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;numeric&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用STL容器时将数组指针改为迭代器即可</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> a[<span class=\"number\">5</span>] = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> b[<span class=\"number\">5</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 排序算法</span></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(a, a + <span class=\"number\">5</span>);  <span class=\"comment\">// 将区间[0, 5)内元素按字典序从小到大排序</span></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(a, a + <span class=\"number\">5</span>, <span class=\"built_in\">greater</span>&lt;<span class=\"type\">int</span>&gt;());  <span class=\"comment\">// 将区间[0, 5)内元素按字典序从大到小排序</span></span><br><span class=\"line\">    <span class=\"built_in\">reverse</span>(a, a + <span class=\"number\">5</span>);  <span class=\"comment\">// 将区间[0, 5)内元素翻转</span></span><br><span class=\"line\">    <span class=\"built_in\">nth_element</span>(a, a + <span class=\"number\">3</span>, a + <span class=\"number\">5</span>);  <span class=\"comment\">// 将区间[0, 5)中第a + 3个数归位，即将第3大的元素放到正确的位置上，该元素前后的元素不一定有序</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 查找与统计算法</span></span><br><span class=\"line\">    <span class=\"built_in\">find</span>(a, a + <span class=\"number\">5</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// 在区间[0, 5)内查找等于3的元素，返回迭代器，若不存在则返回end()</span></span><br><span class=\"line\">    <span class=\"built_in\">binary_search</span>(a, a + <span class=\"number\">5</span>, <span class=\"number\">2</span>);  <span class=\"comment\">// 二分查找区间[0, 5)内是否存在元素2，若存在返回true否则返回false</span></span><br><span class=\"line\">    <span class=\"built_in\">count</span>(a, a + <span class=\"number\">5</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// 返回区间[0, 5)内元素3的个数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 可变序列算法</span></span><br><span class=\"line\">    <span class=\"built_in\">copy</span>(a, a + <span class=\"number\">2</span>, a + <span class=\"number\">3</span>);  <span class=\"comment\">// 将区间[0, 2)的元素复制到以a+3开始的区间，即[3, 5)</span></span><br><span class=\"line\">    <span class=\"built_in\">replace</span>(a, a + <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>);  <span class=\"comment\">// 将区间[0, 5)内等于3的元素替换为4</span></span><br><span class=\"line\">    <span class=\"built_in\">fill</span>(a, a + <span class=\"number\">5</span>, <span class=\"number\">1</span>);  <span class=\"comment\">// 将1写入区间[0, 5)中(初始化数组函数)</span></span><br><span class=\"line\">    <span class=\"built_in\">unique</span>(a, a + <span class=\"number\">5</span>);  <span class=\"comment\">// 将相邻元素间的重复元素全部移动至末端，返回去重之后数组最后一个元素之后的地址</span></span><br><span class=\"line\">    <span class=\"built_in\">remove</span>(a, a + <span class=\"number\">5</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// 将区间[0, 5)中的元素3移至末端，返回新数组最后一个元素之后的地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 排列算法</span></span><br><span class=\"line\">    <span class=\"built_in\">next_permutation</span>(a, a + <span class=\"number\">5</span>);  <span class=\"comment\">// 产生下一个排列&#123; 1, 2, 3, 5, 4 &#125;，若已经是最后一个排列则返回false，否则返回true</span></span><br><span class=\"line\">    <span class=\"built_in\">prev_permutation</span>(a, a + <span class=\"number\">5</span>);  <span class=\"comment\">// 产生上一个排列&#123; 1, 2, 3, 4, 5 &#125;，若已经是第一个排列则返回false，否则返回true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 前缀和算法</span></span><br><span class=\"line\">    <span class=\"built_in\">partial_sum</span>(a, a + <span class=\"number\">5</span>, b);  <span class=\"comment\">// 计算数组a在区间[0, 5)内的前缀和并将结果保存至数组b中，b = &#123; 1, 3, 6, 10, 15 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 差分算法(感谢willem248同学的补充)</span></span><br><span class=\"line\">    <span class=\"built_in\">adjacent_difference</span>(a, a + <span class=\"number\">5</span>, b);  <span class=\"comment\">// 计算数组a区间[0, 5)内的差分并将结果保存至数组b中，b = &#123; 1, 1, 1, 1, 1 &#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">adjacent_difference</span>(a, a + <span class=\"number\">5</span>, b, <span class=\"built_in\">plus</span>&lt;<span class=\"type\">int</span>&gt;());  <span class=\"comment\">// 计算相邻两元素的和，b = &#123; 1, 3, 5, 7, 9 &#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">adjacent_difference</span>(a, a + <span class=\"number\">5</span>, b, <span class=\"built_in\">multiplies</span>&lt;<span class=\"type\">int</span>&gt;());  <span class=\"comment\">// 计算相邻两元素的乘积，b = &#123; 1, 2, 6, 12, 20 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "C++"
            ]
        }
    ]
}